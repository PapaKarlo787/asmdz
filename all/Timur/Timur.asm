;{ Тимур Рифович 2015 год Email hostingurifa@gmail.com                  .
;INFO    Кодировка файла должна быть CP 866
;GITS    https://gist.github.com/MisterTimur/7c64ae327d8d9dcf02f5
;Site    http://sites.google.com/site/abdulovtimuros/
;Youtube http://www.youtube.com/channel/UCUhQNuTAQ933YBTy6awC0Pw
;Google+ http://plus.google.com/u/0/+%D0%A2%D0%B8%D0%BC%D1%83%D1%80%D0%90%D0%B1%D0%B4%D1%83%D0%BB%D0%BE%D0%B2/posts
;
; Для Компиляции
;
; fasm.exe TimOs16.Pas Tim-Lib.com   -d PLA=1 для  доса Com файл
; fasm.exe TimOs16.Pas TimOs16.bin   -d PLA=2 диск 1.44 загрузочный 16 битная версия
; fasm.exe TimOs16.Pas TimOs32.bin   -d PLA=3 диск 1.44 загрузочный 32 битная версия
; fasm.exe TimOs16.Pas TimOs16CD.bin -d PLA=2 -d DIS=1 диск CD загрузочный 16 битная версия
; fasm.exe TimOs16.Pas TimOs32CD.bin -d PLA=3 -d DIS=1 диск CD загрузочный 32 битная версия
; pause
;
;------------------------------------------------------------------------------}
;{ НАСТРОЙКИ ЗАПУСКА ВЫБОР ПЛАТФОРМЫ И ОБРАЗА                           .

ДОС = 1 ;// Работа из под DOS обычный COM файл
T16 = 2 ;// Работа 16 битная версия для 3/5 дюма дискеты
T32 = 3 ;// 32 битная версия для для 3/5 дюма дискеты
        ;// Тут будут разные режимы и разные форматы файла
        ;// Пока только для Дискетки сделаю так отлаживать проще
        ;// PLA Выбор режима компиляции из коммандной строки
        ;// например компиляции для 16 бит образ
        ;// fasm.exe TimOs16.Pas TimOs32.bin  -d PLA=2
T33 = 4 ;// 32 битная версия для для 3/5 дюма дискеты

IF      ( defined PLA )  ;{
   ПЛАТФОРМА = PLA ; // Выбор режима компиляции режимы описаны ниже
END IF;}
IF      ( ~ defined PLA );{
   ПЛАТФОРМА = 1
END IF;}

IF      ( defined DIS )  ;{
   NOS = 1 ; // Выбор режима компиляции режимы описаны ниже
END IF;}
IF      ( ~ defined DIS );{
   NOS = 0
END IF;}


IF      ( NOS = 1 );{
   display ' Образ CD ';
END IF;}

IF      ( ПЛАТФОРМА = ДОС );{
   display ' Компиляция для DOS COM Файл';
END IF;}
IF      ( ПЛАТФОРМА = T16 );{
   display ' Компиляция 16 БИТ ';
END IF;}
IF      ( ПЛАТФОРМА = T32 );{
   display ' Компиляция 32 БИТ ';
END IF;}

;------------------------------------------------------------------------------}
;{ ПОДГОТОВКА К ЗАПУСКУ ТУТ РАСПОЛОЖЕНЫ ЗАГРУЗЧИКИ                      .

;{ Загрузка из под доса 16 бит

   ;---------------------;
   IF  (ПЛАТФОРМА = ДОС) ; // Если запуск из под доса то просто указываем
   ORG 100h              ; // адрес для запуска обычного COM файла 100h
   USE16                 ; // Указываем что используем 16 битные инструкции
   MOV SP,0FFFFh         ;
   END IF                ;
   ;---------------------;

;------------------------------------------------------------------------------}
;{ Загрузочный Cектор для 3/5 Дюймовой дискеты 16 бит.

          IF  (ПЛАТФОРМА = T16)

          ЗАГРУЗОЧНЫЙ_СЕКТОР:
          ;-------------------; Настройка сегментных регистров
          cli                 ; запрещаем прерывания
          xor ax,ax           ; обнуляем регистр ах
          mov ds,ax           ; настраиваем сегмент ds данных на нулевой адрес
          mov es,ax           ; настраиваем сегмент es на нулевой адрес
          mov ss,ax           ; настраиваем сегмент ss стека на нулевой адрес
          mov sp,0FFFFh       ; сегмент sp указывает на текущую вершину стека
          sti                 ; разрешаем прерывания
          ;-------------------;
          IF ( NOS = 0 ) ;{
          ;-------------------; DL Номер Диска прередается при запуске загрузочного сектора из биос
          mov dh, 0           ; головка  1
          mov ch, 0           ; дорожка
          mov cl, 2           ; 2-й сектор
          mov ax, 0000h       ; Адрес сегмента куда загружаем
          mov es, ax          ; Адрес куда загружаем
          mov bx, 1000h       ; Адрес куда загружаем
          mov al, 17          ; кол-во читаемых секторов  Не забываем указывать
          mov ah, 2h          ; Номер Функции в биос для чтения с диска
          int 13h             ; Загружаем первыую часть программы 17 секторов так как первый сектор это загрузочный а всего в 1 дорожке 18 секторов
          ;-------------------;

          ;-------------------; DL Номер Диска прередается при запуске загрузочного сектора из биос
          mov dh, 1           ; головка  2
          mov ch, 0           ; дорожка
          mov cl, 1           ; 1-й сектор
          mov ax, 0000h       ; Адрес сегмента куда загружаем
          mov es, ax          ; Адрес куда загружаем
          mov bx, 1000h+8704  ; Адрес куда загружаем  первые 17 секторов уже загружены по этому  +8704
          mov al, 18          ; кол-во читаемых секторов  Не забываем указывать
          mov ah, 2h          ; Номер Функции в биос для чтения с диска
          int 13h             ; Прерывание для работы с диском
          ;-------------------;
          END IF              ;}
          IF ( NOS = 1 ) ;{
          ;-------------------; DL Номер Диска прередается при запуске загрузочного сектора из биос
          mov dh, 0           ; головка  1
          mov ch, 0           ; дорожка
          mov cl, 2           ; 2-й сектор
          mov ax, 0000h       ; Адрес сегмента куда загружаем
          mov es, ax          ; Адрес куда загружаем
          mov bx, 1000h       ; Адрес куда загружаем
          mov al, 35          ; кол-во читаемых секторов  Не забываем указывать
          mov ah, 2h          ; Номер Функции в биос для чтения с диска
          int 13h             ; Загружаем первыую часть программы 17 секторов так как первый сектор это загрузочный а всего в 1 дорожке 18 секторов
          ;-------------------;
          END IF              ;}
          ;-------------------; Настройка сегментных регистров
          cli                 ; запрещаем прерывания
          xor ax,ax           ; обнуляем регистр ах
          mov ds,ax           ; настраиваем сегмент ds данных на нулевой адрес
          mov es,ax           ; настраиваем сегмент es на нулевой адрес
          mov ss,ax           ; настраиваем сегмент ss стека на нулевой адрес
          mov sp,0FFFFh       ; сегмент sp указывает на текущую вершину стека
          sti                 ; разрешаем прерывания
          ;-------------------;

          jmp far 0:1000h     ; В 16 битном автономном режиме программа запускаеться с 1000h адреса
          ;-------------------;
          times 0x200 - 2 - ($ - ЗАГРУЗОЧНЫЙ_СЕКТОР) db 0x90
          DB    055h, 0AAh    ; Сигнатура загрузчного сктора по ней BIOS узнает что это загрузочный сектор
          org   1000h;
          use16 ;
          END IF              ;
          ;-------------------;
;------------------------------------------------------------------------------}
;{ Загрузочный Cектор для 3/5 Дюймовой дискеты 32 бит.
          ;Помощь при создании 32 битного загрузчика оказал robohacker.ru
          ;Автор 32 битного загрузчика robohacker.ru а я его немного изменил для своей ОС
          IF  (ПЛАТФОРМА = T32)
          ORG 0;
          ЗАГРУЗОЧНЫЙ_СЕКТОР:; { Загрузочный сектор
          ;------------------------;
          mov  ah,00h              ; // Функция установки видео режима 80 на 25
          mov  al,03h              ; // Устаналиваем Видео режим
          int  10h                 ; // Вызываем функцию биос
          ;------------------------;

          ;------------------------;
          mov ah,05h               ; // Выбираем видео страницу
          mov al,0                 ;
          int 10h                  ;
          ;------------------------;

          ;------------------------;
          mov bx,0                 ; // Номер видеостраницы
          mov dl,0                 ; // Координата по X
          mov dh,25                ; // уст. позицию курсора. установка на строку 25 делает курсор невидимым.
          mov ah,02h               ; // ПОдпрограмма установки курсора
          int 10h                  ;
          ;------------------------;

          cli
          ;cld

          xor ax, ax
          mov ds, ax
          mov es, ax
          mov ss, ax
          mov sp, 0xFFFF;
          sti


          IF ( NOS = 0 )       ;{
          ;-------------------; DL Номер Диска прередается при запуске загрузочного сектора из биос
          mov dh, 0           ; головка  1
          mov ch, 0           ; дорожка
          mov cl, 2           ; 2-й сектор
          mov ax, 0000h       ; Адрес сегмента куда загружаем
          mov es, ax          ; Адрес куда загружаем
          mov bx, 0x8000      ; Адрес куда загружаем
          mov al, 17          ; кол-во читаемых секторов  Не забываем указывать
          mov ah, 2h          ; Номер Функции в биос для чтения с диска
          int 13h             ; Загружаем первыую часть программы 17 секторов так как первый сектор это загрузочный а всего в 1 дорожке 18 секторов
          ;-------------------;

          ;-------------------; DL Номер Диска прередается при запуске загрузочного сектора из биос
          mov dh, 1           ; головка  2
          mov ch, 0           ; дорожка
          mov cl, 1           ; 1-й сектор
          mov ax, 0000h       ; Адрес сегмента куда загружаем
          mov es, ax          ; Адрес куда загружаем
          mov bx, 0x8000+8704 ; Адрес куда загружаем  первые 17 секторов уже загружены по этому  +8704
          mov al, 18          ; кол-во читаемых секторов  Не забываем указывать
          mov ah, 2h          ; Номер Функции в биос для чтения с диска
          int 13h             ; Прерывание для работы с диском
          ;-------------------;

          ;-------------------; DL Номер Диска прередается при запуске загрузочного сектора из биос
          mov dh, 0           ; головка  2
          mov ch, 1           ; дорожка
          mov cl, 1           ; 1-й сектор
          mov ax, 0000h       ; Адрес сегмента куда загружаем
          mov es, ax          ; Адрес куда загружаем
          mov bx, 0x8000+17920; Адрес куда загружаем  первые 17 секторов уже загружены по этому  +8704
          mov al, 18          ; кол-во читаемых секторов  Не забываем указывать
          mov ah, 2h          ; Номер Функции в биос для чтения с диска
          int 13h             ; Прерывание для работы с диском
          ;-------------------;


          END IF;}
          IF ( NOS = 1 )       ;{
          ;-------------------; DL Номер Диска прередается при запуске загрузочного сектора из биос
          mov dh, 0           ; головка  1
          mov ch, 0           ; дорожка
          mov cl, 2           ; 2-й сектор
          mov ax, 0000h       ; Адрес сегмента куда загружаем
          mov es, ax          ; Адрес куда загружаем
          mov bx, 0x8000      ; Адрес куда загружаем
          mov al, 60          ; кол-во читаемых секторов  Не забываем указывать
          mov ah, 2h          ; Номер Функции в биос для чтения с диска
          int 13h             ; Загружаем первыую часть программы 17 секторов так как первый сектор это загрузочный а всего в 1 дорожке 18 секторов
          ;-------------------;

          END IF;}


          jmp far 0:8000h     ;
          ;-------------------;
          times 0x200 - 2 - ($ - ЗАГРУЗОЧНЫЙ_СЕКТОР) db 0x90
          db  055h, 0AAh      ; Сигнатруа загрузочного сектора
;------------------------------------------------------------------------------}
          ORG 0x8000         ;
          РЕАЛЬНЫЙ_РЕЖИМ    :; { Реальный режим

Start:
          ;------------------; // Загрузка шрифтов используя биос пока не перешли в защищеный режим
          mov     bp,Font    ; // Первый набор от А до п
          mov     dx, 128    ; // код символа с котрого начинаем загрузку шрифтов
          mov     cx, 48     ; // Количество загружаемых символов
          mov     bx, 1000h  ; // Далее указываем высотук символов 16 пик и другие настройки
          mov     ax, 1100h  ; // Номер функции и подфункции загрузки шрифтов прерывания 10h
          int     10h        ; // В данном случае для видео режима 80x25 16 пик высоту
          ;------------------;

          ;------------------; // Второй набор от р до яеЁ
          mov     bp,Font2   ;
          mov     dx, 224    ; // код символа с котрого начинаем загрузку шрифтов
          mov     cx, 18     ; // Количество загружаемых символов
          mov     bx, 1000h  ; // Далее указываем высотук символов 16 пик и другие настройки
          mov     ax, 1100h  ; // Номер функции загрузки шрифтов прерывания 10h
          int     10h        ; // В данном случае для видео режима 80x25 16 пик высоту
          ;------------------;

          ;------------------; // запрет всех прерываний
          cli                ;
          in   al, 70h       ;
          or   al, 80h       ;
          out  70h, al       ; // запрет NMI
          ;------------------;
          in   al, 92h
          or   al, 2
          out  92h, al


          call СОЗДАТЬ_GDT   ; // Сдесь потребуються уточнения еще не достаточно
          mov eax, cr0       ;
          or  al,  1         ;
          mov cr0, eax       ;
          jmp 0x0008:0x0000  ;
          ;------------------;

          Font:;{ Руские буквы
          ;-------------;А
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00011100b ;2
          DB 00010100b ;3
          DB 00010100b ;4
          DB 00010110b ;5
          DB 00100010b ;6
          DB 00100010b ;7
          DB 00100010b ;8
          DB 01111111b ;9
          DB 01000001b ;10
          DB 01000001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Б
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01111100b ;2
          DB 01000000b ;3
          DB 01000000b ;4
          DB 01000000b ;5
          DB 01111100b ;6
          DB 01000110b ;7
          DB 01000010b ;8
          DB 01000010b ;9
          DB 01000110b ;10
          DB 01111100b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;В
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01111100b ;2
          DB 01000010b ;3
          DB 01000010b ;4
          DB 01000110b ;5
          DB 01111100b ;6
          DB 01000110b ;7
          DB 01000010b ;8
          DB 01000010b ;9
          DB 01000110b ;10
          DB 01111100b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Г
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00111111b ;2
          DB 00100000b ;3
          DB 00100000b ;4
          DB 00100000b ;5
          DB 00100000b ;6
          DB 00100000b ;7
          DB 00100000b ;8
          DB 00100000b ;9
          DB 00100000b ;10
          DB 00100000b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Д
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00111111b ;2
          DB 00100001b ;3
          DB 00100001b ;4
          DB 00100001b ;5
          DB 00100001b ;6
          DB 00100001b ;7
          DB 00100001b ;8
          DB 00100001b ;9
          DB 01000001b ;10
          DB 11111111b ;11
          DB 10000000b ;12
          DB 10000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Е
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00111111b ;2
          DB 00100000b ;3
          DB 00100000b ;4
          DB 00100000b ;5
          DB 00111111b ;6
          DB 00100000b ;7
          DB 00100000b ;8
          DB 00100000b ;9
          DB 00100000b ;10
          DB 00111111b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Ж
          DB 00000000b ;0
          DB 00000000b ;1
          DB 10001000b ;2
          DB 01001001b ;3
          DB 00101010b ;4
          DB 00101010b ;5
          DB 00011100b ;6
          DB 00011100b ;7
          DB 00101010b ;8
          DB 01001001b ;9
          DB 01001001b ;10
          DB 10001000b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;З
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00111100b ;2
          DB 01000010b ;3
          DB 00000010b ;4
          DB 00000010b ;5
          DB 00111100b ;6
          DB 00000110b ;7
          DB 00000010b ;8
          DB 00000010b ;9
          DB 01000110b ;10
          DB 00111100b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;И
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01000001b ;2
          DB 01000011b ;3
          DB 01000111b ;4
          DB 01000101b ;5
          DB 01001101b ;6
          DB 01011001b ;7
          DB 01010001b ;8
          DB 01110001b ;9
          DB 01100001b ;10
          DB 01000001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Й
          DB 00111000b ;0
          DB 00000000b ;1
          DB 01000001b ;2
          DB 01000011b ;3
          DB 01000111b ;4
          DB 01000101b ;5
          DB 01001101b ;6
          DB 01011001b ;7
          DB 01010001b ;8
          DB 01110001b ;9
          DB 01100001b ;10
          DB 01000001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;К
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01000010b ;2
          DB 01000100b ;3
          DB 01001100b ;4
          DB 01011000b ;5
          DB 01110000b ;6
          DB 01110000b ;7
          DB 01011000b ;8
          DB 01001100b ;9
          DB 01000100b ;10
          DB 01000010b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Л
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00111110b ;2
          DB 00100010b ;3
          DB 00100010b ;4
          DB 00100010b ;5
          DB 00100010b ;6
          DB 00100010b ;7
          DB 01100010b ;8
          DB 01000010b ;9
          DB 01000010b ;10
          DB 11000010b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;М
          DB 00000000b ;0
          DB 00000000b ;1
          DB 11000001b ;2
          DB 11100011b ;3
          DB 11100011b ;4
          DB 11110101b ;5
          DB 11010101b ;6
          DB 11010101b ;7
          DB 11001001b ;8
          DB 11000001b ;9
          DB 11000001b ;10
          DB 11000001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Н
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01000001b ;2
          DB 01000001b ;3
          DB 01000001b ;4
          DB 01000001b ;5
          DB 01111111b ;6
          DB 01000001b ;7
          DB 01000001b ;8
          DB 01000001b ;9
          DB 01000001b ;10
          DB 01000001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;О
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00111100b ;2
          DB 01000010b ;3
          DB 11000001b ;4
          DB 10000001b ;5
          DB 10000001b ;6
          DB 10000001b ;7
          DB 10000001b ;8
          DB 10000011b ;9
          DB 01000010b ;10
          DB 00111100b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;П
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01111111b ;2
          DB 01000001b ;3
          DB 01000001b ;4
          DB 01000001b ;5
          DB 01000001b ;6
          DB 01000001b ;7
          DB 01000001b ;8
          DB 01000001b ;9
          DB 01000001b ;10
          DB 01000001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Р
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01111100b ;2
          DB 01000110b ;3
          DB 01000010b ;4
          DB 01000010b ;5
          DB 01000110b ;6
          DB 01111000b ;7
          DB 01000000b ;8
          DB 01000000b ;9
          DB 01000000b ;10
          DB 01000000b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;С
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00011110b ;2
          DB 00110001b ;3
          DB 00100000b ;4
          DB 01000000b ;5
          DB 01000000b ;6
          DB 01000000b ;7
          DB 01000000b ;8
          DB 01100000b ;9
          DB 00100001b ;10
          DB 00011110b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Т
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01111111b ;2
          DB 00001000b ;3
          DB 00001000b ;4
          DB 00001000b ;5
          DB 00001000b ;6
          DB 00001000b ;7
          DB 00001000b ;8
          DB 00001000b ;9
          DB 00001000b ;10
          DB 00001000b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;У
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01000001b ;2
          DB 01100011b ;3
          DB 00100010b ;4
          DB 00110110b ;5
          DB 00010100b ;6
          DB 00011100b ;7
          DB 00001000b ;8
          DB 00001000b ;9
          DB 00011000b ;10
          DB 01110000b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Ф
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00001000b ;2
          DB 00011110b ;3
          DB 00101010b ;4
          DB 01001001b ;5
          DB 01001001b ;6
          DB 01001001b ;7
          DB 01001001b ;8
          DB 01101010b ;9
          DB 00111100b ;10
          DB 00001000b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Х
          DB 00000000b ;0
          DB 00000000b ;1
          DB 11000011b ;2
          DB 01100110b ;3
          DB 00110100b ;4
          DB 00011100b ;5
          DB 00011000b ;6
          DB 00011100b ;7
          DB 00110100b ;8
          DB 00100110b ;9
          DB 01100011b ;10
          DB 11000001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Ц
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01000001b ;2
          DB 01000001b ;3
          DB 01000001b ;4
          DB 01000001b ;5
          DB 01000001b ;6
          DB 01000001b ;7
          DB 01000001b ;8
          DB 01000001b ;9
          DB 01000001b ;10
          DB 01111111b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Ч
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01000001b ;2
          DB 01000001b ;3
          DB 01000001b ;4
          DB 01000001b ;5
          DB 01100001b ;6
          DB 00111111b ;7
          DB 00000001b ;8
          DB 00000001b ;9
          DB 00000001b ;10
          DB 00000001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Ш
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01001001b ;2
          DB 01001001b ;3
          DB 01001001b ;4
          DB 01001001b ;5
          DB 01001001b ;6
          DB 01001001b ;7
          DB 01001001b ;8
          DB 01001001b ;9
          DB 01001001b ;10
          DB 01111111b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Щ
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01001001b ;2
          DB 01001001b ;3
          DB 01001001b ;4
          DB 01001001b ;5
          DB 01001001b ;6
          DB 01001001b ;7
          DB 01001001b ;8
          DB 01001001b ;9
          DB 01001001b ;10
          DB 01111111b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Ъ
          DB 00000000b ;0
          DB 00000000b ;1
          DB 11100000b ;2
          DB 00100000b ;3
          DB 00100000b ;4
          DB 00100000b ;5
          DB 00111110b ;6
          DB 00100011b ;7
          DB 00100001b ;8
          DB 00100001b ;9
          DB 00100011b ;10
          DB 00111110b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Ы
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01000001b ;2
          DB 01000001b ;3
          DB 01000001b ;4
          DB 01000001b ;5
          DB 01111001b ;6
          DB 01000101b ;7
          DB 01000101b ;8
          DB 01000101b ;9
          DB 01001101b ;10
          DB 01111001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Ь
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01000000b ;2
          DB 01000000b ;3
          DB 01000000b ;4
          DB 01000000b ;5
          DB 01111100b ;6
          DB 01000110b ;7
          DB 01000010b ;8
          DB 01000010b ;9
          DB 01000110b ;10
          DB 01111100b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Э
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00111100b ;2
          DB 01000010b ;3
          DB 00000001b ;4
          DB 00000001b ;5
          DB 00111111b ;6
          DB 00000001b ;7
          DB 00000001b ;8
          DB 00000011b ;9
          DB 01000010b ;10
          DB 00111100b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Ю
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01001111b ;2
          DB 01011001b ;3
          DB 01010000b ;4
          DB 01010000b ;5
          DB 01110000b ;6
          DB 01010000b ;7
          DB 01010000b ;8
          DB 01010000b ;9
          DB 01001001b ;10
          DB 01001111b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Я
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00011110b ;2
          DB 00100010b ;3
          DB 00100010b ;4
          DB 00100010b ;5
          DB 00110010b ;6
          DB 00011110b ;7
          DB 00110010b ;8
          DB 00100010b ;9
          DB 01100010b ;10
          DB 01100010b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;а
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 00011100b ;5
          DB 00100010b ;6
          DB 00000010b ;7
          DB 00111110b ;8
          DB 01000010b ;9
          DB 01000110b ;10
          DB 00111010b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;б
          DB 00000000b ;0
          DB 00011110b ;1
          DB 00100000b ;2
          DB 00100000b ;3
          DB 01011110b ;4
          DB 01100010b ;5
          DB 01000001b ;6
          DB 01000001b ;7
          DB 01000001b ;8
          DB 01000001b ;9
          DB 00100010b ;10
          DB 00011100b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;в
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01111100b ;5
          DB 01000010b ;6
          DB 01000010b ;7
          DB 01111100b ;8
          DB 01000010b ;9
          DB 01000010b ;10
          DB 01111100b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;г
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 00111111b ;5
          DB 00100000b ;6
          DB 00100000b ;7
          DB 00100000b ;8
          DB 00100000b ;9
          DB 00100000b ;10
          DB 00100000b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;д
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 00111110b ;5
          DB 00100010b ;6
          DB 00100010b ;7
          DB 00100010b ;8
          DB 01100010b ;9
          DB 01000010b ;10
          DB 11111111b ;11
          DB 10000001b ;12
          DB 10000001b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;е
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 00011110b ;5
          DB 00100011b ;6
          DB 01000001b ;7
          DB 01111111b ;8
          DB 01000000b ;9
          DB 01100000b ;10
          DB 00011111b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;ж
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 10001000b ;5
          DB 01001001b ;6
          DB 00101010b ;7
          DB 00011100b ;8
          DB 00101010b ;9
          DB 01101011b ;10
          DB 11001001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;з
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01111100b ;5
          DB 00000010b ;6
          DB 00000010b ;7
          DB 00111100b ;8
          DB 00000010b ;9
          DB 00000010b ;10
          DB 01111100b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;и
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01000010b ;5
          DB 01000110b ;6
          DB 01001110b ;7
          DB 01011010b ;8
          DB 01110010b ;9
          DB 01100010b ;10
          DB 01000010b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;й
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00100100b ;2
          DB 00111000b ;3
          DB 00000000b ;4
          DB 01000010b ;5
          DB 01000110b ;6
          DB 01001110b ;7
          DB 01011010b ;8
          DB 01110010b ;9
          DB 01100010b ;10
          DB 01000010b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;к
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01000010b ;5
          DB 01001100b ;6
          DB 01010000b ;7
          DB 01100000b ;8
          DB 01011000b ;9
          DB 01001100b ;10
          DB 01000110b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;л
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 00111110b ;5
          DB 00100010b ;6
          DB 00100010b ;7
          DB 00100010b ;8
          DB 00100010b ;9
          DB 01000010b ;10
          DB 11000010b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;м
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01100011b ;5
          DB 01010101b ;6
          DB 01010101b ;7
          DB 01010101b ;8
          DB 01001001b ;9
          DB 01000001b ;10
          DB 01000001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;н
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01000010b ;5
          DB 01000010b ;6
          DB 01000010b ;7
          DB 01111110b ;8
          DB 01000010b ;9
          DB 01000010b ;10
          DB 01000010b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;о
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 00011110b ;5
          DB 00100011b ;6
          DB 01000001b ;7
          DB 01000001b ;8
          DB 01000001b ;9
          DB 01100010b ;10
          DB 00111100b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;п
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01111110b ;5
          DB 01000010b ;6
          DB 01000010b ;7
          DB 01000010b ;8
          DB 01000010b ;9
          DB 01000010b ;10
          DB 01000010b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
Font2:    ;-------------;р
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01011110b ;5
          DB 01100011b ;6
          DB 01000001b ;7
          DB 01000001b ;8
          DB 01000001b ;9
          DB 01000010b ;10
          DB 01111100b ;11
          DB 01000000b ;12
          DB 01000000b ;13
          DB 01000000b ;14
          DB 00000000b ;15
          ;-------------;с
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 00011110b ;5
          DB 00100000b ;6
          DB 01000000b ;7
          DB 01000000b ;8
          DB 01000000b ;9
          DB 01100000b ;10
          DB 00011110b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;т
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01111111b ;5
          DB 00001000b ;6
          DB 00001000b ;7
          DB 00001000b ;8
          DB 00001000b ;9
          DB 00001000b ;10
          DB 00001000b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;у
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01000001b ;5
          DB 01100011b ;6
          DB 00100010b ;7
          DB 00100110b ;8
          DB 00010100b ;9
          DB 00010100b ;10
          DB 00011000b ;11
          DB 00011000b ;12
          DB 00010000b ;13
          DB 11100000b ;14
          DB 00000000b ;15
          ;-------------;ф
          DB 00000000b ;0
          DB 00001000b ;1
          DB 00001000b ;2
          DB 00001000b ;3
          DB 00011110b ;4
          DB 00101011b ;5
          DB 01001001b ;6
          DB 01001001b ;7
          DB 01001001b ;8
          DB 01001001b ;9
          DB 01101010b ;10
          DB 00111100b ;11
          DB 00001000b ;12
          DB 00001000b ;13
          DB 00001000b ;14
          DB 00000000b ;15
          ;-------------;х
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01100011b ;5
          DB 00110110b ;6
          DB 00011100b ;7
          DB 00001100b ;8
          DB 00010110b ;9
          DB 00110011b ;10
          DB 01100001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;ц
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01000010b ;5
          DB 01000010b ;6
          DB 01000010b ;7
          DB 01000010b ;8
          DB 01000010b ;9
          DB 01000010b ;10
          DB 01111111b ;11
          DB 00000001b ;12
          DB 00000001b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;ч
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01000010b ;5
          DB 01000010b ;6
          DB 01000010b ;7
          DB 00111110b ;8
          DB 00000010b ;9
          DB 00000010b ;10
          DB 00000010b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;ш
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01001001b ;5
          DB 01001001b ;6
          DB 01001001b ;7
          DB 01001001b ;8
          DB 01001001b ;9
          DB 01001001b ;10
          DB 01111111b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;щ
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01001001b ;5
          DB 01001001b ;6
          DB 01001001b ;7
          DB 01001001b ;8
          DB 01001001b ;9
          DB 01001001b ;10
          DB 01111111b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;ъ
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 11100000b ;5
          DB 00100000b ;6
          DB 00100000b ;7
          DB 00111100b ;8
          DB 00100010b ;9
          DB 00100010b ;10
          DB 00111100b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;ы
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01000001b ;5
          DB 01000001b ;6
          DB 01000001b ;7
          DB 01111001b ;8
          DB 01000101b ;9
          DB 01000101b ;10
          DB 01111001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;ь
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01000000b ;5
          DB 01000000b ;6
          DB 01000000b ;7
          DB 01111100b ;8
          DB 01000010b ;9
          DB 01000010b ;10
          DB 01111100b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;э
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01111100b ;5
          DB 00000110b ;6
          DB 00000010b ;7
          DB 01111110b ;8
          DB 00000010b ;9
          DB 00000110b ;10
          DB 01111000b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;ю
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01001111b ;5
          DB 01011001b ;6
          DB 01010000b ;7
          DB 01110000b ;8
          DB 01010000b ;9
          DB 01011001b ;10
          DB 01001111b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;я
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 00011110b ;5
          DB 00100010b ;6
          DB 00100010b ;7
          DB 00011110b ;8
          DB 00110010b ;9
          DB 00100010b ;10
          DB 01100010b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
Font3:    ;-------------;Ё
          DB 00100100b ;0
          DB 00000000b ;1
          DB 00111111b ;2
          DB 00100000b ;3
          DB 00100000b ;4
          DB 00100000b ;5
          DB 00111111b ;6
          DB 00100000b ;7
          DB 00100000b ;8
          DB 00100000b ;9
          DB 00100000b ;10
          DB 00111111b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;ё
          DB 00000000b ;0
          DB 00110110b ;1
          DB 00110110b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 00011110b ;5
          DB 00100011b ;6
          DB 01000001b ;7
          DB 01111111b ;8
          DB 01000000b ;9
          DB 01100000b ;10
          DB 00011111b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
;---}
          СОЗДАТЬ_GDT:;{ Создание первичной таблицы GDT

          mov ax, 0x0400
          mov es, ax

          ; Очистить GDT (1024 элементов)
          xor di, di
          mov cx, 0x2000
          xor ax, ax
          rep stosb

          mov di, 8

    ; ~600 kb кода, который может быть загружен
    mov eax, 0x93FFF
    mov ebx, ЗАЩИЩЕННЫЙ_РЕЖИМ ; начало
    mov cx,  0x90  + 0x8 + 0x4000 ; DPL=0, PRESENT=0x80, BIT_SYSTEM=0x10, CODE_EXEC_ONLY=0x8, BIT_DEFAULT_SIZE_32=0x4000
    call СОЗДАТЬ_ДЕСКРИПТОР

    ; повтор сегмента, но уже для данных
    mov eax, 0x93FFF
    mov ebx, ЗАЩИЩЕННЫЙ_РЕЖИМ ; начало
    mov cx,  0x90 + 0x2 + 0x4000 ; DATA_READ_WRITE=0x2
    call СОЗДАТЬ_ДЕСКРИПТОР

    ; сегмент стека (256 кб)
    mov eax, 0x93FFF
    mov ebx, ЗАЩИЩЕННЫЙ_РЕЖИМ ; Начало в HI-mem
    mov cx,  0x90 + 0x2 + 0x4000 ; DATA_READ_WRITE=0x2
    call СОЗДАТЬ_ДЕСКРИПТОР

    ; Память в целом (es)
    mov eax, 0xFFFFF
    xor ebx, ebx
    mov cx,  0x90 + 0x2 + 0x8000 + 0x4000 ; GRANUL=0x8000
    call СОЗДАТЬ_ДЕСКРИПТОР

    ; Загрузка IDT
    mov word  [0x7C00], 0x1FFF
    mov dword [0x7C02], 0x4000
    lgdt [0x7C00]
    lidt [IDTR];
    ret
    ;{ ТАБЛИЦА ПРЕРЫВАНИЙ

    ; Interrupt Descriptor Table
    IDT:    dw I00,08h, 1000111000000000b, 0   ; 0 Division by zero
            dw I01,08h, 1000111000000000b, 0   ; 1 Debugger
            dd   0,0  ; 2  NMI
            dd   0,0  ; 3  Breakpoint
            dd   0,0  ; 4  Overflow
            dd   0,0  ; 5  Bounds
            dd   0,0  ; 6  Invalid Opcode
            dd   0,0  ; 7  Coprocessor not available
            dd   0,0  ; 8  Double fault
            dd   0,0  ; 9  Coprocessor Segment Overrun (386 or earlier only)
            dd   0,0  ; 10 Invalid Task State Segment
            dd   0,0  ; 11 Segment not present
            dd   0,0  ; 12 Stack Fault
            dw I13,08h, 1000111000000000b, 0   ; 13  General protection fault
            dd   0,0  ; 14 Page fault
            dd   0,0  ; 15 reserved
            dd   0,0  ; 16 Math Fault
            dd   0,0  ; 17 Alignment Check
            dd   0,0  ; 18 Machine Check
            dd   0,0  ; 19 SIMD Floating-Point Exception
            dd   0,0  ; 20 Virtualization Exception
            dd   0,0  ; 21 Control Protection Exception
            dd   0,0  ; 22
            dd   0,0  ; 23
            dd   0,0  ; 24
            dd   0,0  ; 25
            dd   0,0  ; 26
            dd   0,0  ; 27
            dd   0,0  ; 28
            dd   0,0  ; 29
            dd   0,0  ; 30
            dd   0,0  ; 31
            dw I32,08h, 1000111000000000b, 0   ; IRQ 0 - системный таймер
            dw I33,08h, 1000111000000000b, 0   ; IRQ 1 - клавиатура
            dd   0,0  ; IRQ 2 - Дополнительный контроллер прерываний (для совместимости с 8-битной шиной)
            dd   0,0  ; IRQ 3 - Порты Com 1 и 3
            dd   0,0  ; IRQ 4 - Порты Com 2 и 4
            dd   0,0  ; IRQ 5 - Свободно
            dd   0,0  ; IRQ 6 - Контроллер гибких дисков (FDD)
            dd   0,0  ; IRQ 7 - Параллельный порт LPT
            dd   0,0  ; IRQ 8 - Часы реального времени CMOS
            dd   0,0  ; IRQ 9 - Совмещено с IRQ 2
            dd   0,0  ; IRQ 10- Свободно
            dd   0,0  ; IRQ 11- Свободно
            dw I44,08h, 1000111000000000b, 0   ; IRQ 12- Порт мыши PS/2
            dd   0,0  ; IRQ 13- Сопроцессор (в настоящее время практически не используется)
            dd   0,0  ; IRQ 14- Первый контроллер IDE
            dd   0,0  ; IRQ 15- Второй контроллер IDE

       IDT_size  =    $-IDT
       IDTR     :     dw IDT_size-1
                      dd IDT ;

    ;}


;==============================================================================}
          СОЗДАТЬ_ДЕСКРИПТОР:;{Создание дескриптора в реальном режиме
; --------------------------------------------------------
; EAX - Лимит 24
; EBX - Адрес 32
; CX  - Конфигурация
; ES:DI - Указатель на элемент GDT
; --------------------------------------------------------

    stosw ; limit

    xchg  eax, ebx
    stosw ; address 0..15

    shr   eax, 16
    stosb ; addr 16..23

    xchg  eax, ebx
    mov   al, cl
    stosb ; config low

    shr   eax, 16
    or    al, ch
    stosb ; config + limit

    xchg  eax, ebx
    shr   ax, 8
    stosb ; addr 24..31

    ret
;==============================================================================}
          РАЗМЕР_КОДА_РЕАЛЬНОГО_РЕЖИМА = $ - РЕАЛЬНЫЙ_РЕЖИМ
;------------------------------------------------------------------------------}
          ЗАЩИЩЕННЫЙ_РЕЖИМ  :; { Защищенный режим

          org 0
          use32

.СТАРТ:






          mov ax, 0x10
          mov ds, ax

          mov ax, 0x10;
          mov ss, ax
          mov esp,0x2FFFF; 0x40000

          mov ax, 0x20
          mov es, ax

          mov ax, 0
          mov fs, ax
          mov gs, ax

          ; [ES:0B8000h] Адрес видеопамяти
          mov  dx, 0xFFFF
          mov  bx, 2820h
          call redirect_IRQ

;------------------------------------------------------------------------------}
          END IF
;------------------------------------------------------------------------------}

;==============================================================================}
;{ ОСНОВНОЕ ТЕЛО ПРОГРАММЫ                                              .

   ;-------------------------;
   Call ПОДГОТОВКА_К_ЗАПУСКУ ; // Очистка видеобуфера полготовка диспетчера памяти и тд и тп
   ;-------------------------;

   call КНОП_ПОМ_ОКНА        ; // Создает окно помощи

   ;-------------------------;
   .ОСНОВНОЙ_ЦИКЛ:           ;
   ;-------------------------;
   call ПРЕРЫВАНИЕ           ; // Програмное прерывание эмуляция много задачности передача управления другому потоку на время
   call КЛАВИАТУРА_ЧИТАТЬ    ; // Читает нажатую кнопку на клавиатуре и запоминает в переменную [НАЖ_КНОПК]
   call КНОПКИ               ; // Обработка нажатой кнопки
   call МЫШКА_ЧИТАТЬ         ; // Читает координаты мышки
   call СБРОС_КЕША
   call ОКНО_ПЕРЕМЕЩЕ        ; // Перемещает окна процеду отвечает за перемещение окошек

   call ЭКРАН_ОЧИСТКА        ; // Очитка видеобуфера для рисования
   Call БИОС_ИНФОРМАЦИЯ      ; // Выводит отладочную информацию выпилим на время
   call КОРНЕВОЙ_ЭЛЕМЕНТ     ; // Читает корневой элемент в регистр Di
   call СБРОС_КЕША
   call ОКНО_РИСО_ВСЕ        ; // Рисует окна в видеобуфере

   call МЫШКА_НАРИСОВАТЬ     ; // РИсует мышку
   call ЭКРАН_ВЫВОД          ; // Вывод содержимого видеобуфера на экран
   call ОКНО_ПОРЯДОК         ; // Определяет порядок прорисовки окон
   JMP .ОСНОВНОЙ_ЦИКЛ        ;
   ;-------------------------;
   ;-------------------------;
   Call ЗАВЕРШЕНИЕ_РАБОТЫ    ;
   ;-------------------------;
   ret                       ;
   TR_TIMER2:dd 00000010b;
   TR_TIMER:dd 0;
;{
;call ПРЕРЫВАНИЕ           ; // Програмное прерывание эмуляция много задачности передача управления другому потоку на время
;call МЫШКА_ЧИТАТЬ         ; // Читает координаты мышки
;call КЛАВИАТУРА_ЧИТАТЬ    ; // Читает нажатую кнопку на клавиатуре и запоминает в переменную [НАЖ_КНОПК]
;call КНОПКИ               ; // Обработка нажатой кнопки
;call ОКНО_ПЕРЕМЕЩЕ        ; // Перемещает окна процеду отвечает за перемещение окошек
;call ЭКРАН_ОЧИСТКА        ; // Очитка видеобуфера для рисования
;Call БИОС_ИНФОРМАЦИЯ      ; // Выводит отладочную информацию выпилим на время
;call КОРНЕВОЙ_ЭЛЕМЕНТ     ; // Читает корневой элемент в регистр Di
;call ОКНО_РИСО_ВСЕ        ; // Рисует окна в видеобуфере
;call МЫШКА_НАРИСОВАТЬ     ; // РИсует мышку
;call ЭКРАН_ВЫВОД          ; // Вывод содержимого видеобуфера на экран
;call ОКНО_ПОРЯДОК         ; // Определяет порядок прорисовки окон
;JMP .ОСНОВНОЙ_ЦИКЛ        ;
;}


;ЗАПРЕТ:DB 0;
;==============================================================================};
;{ ФУНКЦИИ ДЛЯ РАБОТЫ C ЯЗЫКОМ ПРОГРАМИРОВАНИЯ                          .
                                                              ;-ПРОГРАМИРОВАНИЕ:
                                                                       ;-ЖШРИФТ:
                                                                      ;-clGreen:
                          ;{описание раздела

; В этой части кода расположены функции для работы с языком програмирвоания
;
;
;
;
;}
РАЗ_НА_СЛОВА:;{ Разбивает строку DI указатель на окно с программой на слова возврвщет элемнт DI со списком слов

                             ;{Описание
;        Функция предназначена для разбивки строки на слова
;        Создает списко слов из строки ну и всего там что есть в строке
;        Слова Цифры Чзнаки Скобки все такое вообщем
;        В DI Содержиться адрес Окна Элемент окно в не  есть набор параметров
;        среди них есть параметр текста окна имено этот параметр содержит
;        Строку содержащию текст программы строка заканчиваеться 0
;        вовращает в DI элемент содержащий Консоль и список слов
;        Так что при закрытии консоли будет разрушена и структура с программой
;        В дальнейшем можно будет сделать и по другому но пока так это проще
;}
IF  (ПЛАТФОРМА = ДОС)   ;{ Версия для работы в ДОС
            pushad                    ; // { ОПИСАНИЕ
            ;-------------------------------------------------------------------
            ; Разбивает текст программы из окна DI на слова
            ; Возращает в регистре DI адрес на структуру содержащию список слов
            ; На Входе DI адрес окна
            ; На выходе адрес DI элемента содеражего список слов
            ;------------------------------------------------------------------}
            ;-------------------------; // ОКНО_ТЕК Возвращает в AX Адрес строки с текстом
            call ОКНО_ТЕК             ; // Записываем в AX адрес строки с текстом прогрыммы
            JZ  .ВЫХОД                ; // Если нету текста прогрммы то выход c DI 0
            mov  si,ax                ; // Запоминаем адрес текста программы
            call ОКНО_МОНИТОР         ; // Содаем консоль внутри консоли размещаеться
            call СОЗДАТЬ_ЭЛЕ_DI_С_ПРОГ; // Структура исполнительная с программой это сделано
            ;-------------------------; // Для того что бы при закрытии консоли удалялася и сама программа .....

.ЦИКЛ:      ;-------------------------; // тут обычный цикл до конца строки 0
            mov  al,[si]              ;
            test al,al                ;
            jZ  .КЦИКЛ                ; // Выход приокончании строки
            ;-------------------------;
            call ДОБАВИТЬ_КАК_СЛОВО   ; // Пытаеться прочитать слово если удалося Цикл
            jnz .ЦИКЛ                 ; // Если не удалося
            call ДОБАВИТЬ_КАК_ЧИСЛО   ; // Пытаеться прочитать как число
            jnz .ЦИКЛ                 ; // И так далее .... надеюся тут не запутаюся
            Call ДОБАВИТЬ_КАК_ЗНАК    ; // Хмм.... тут вроде бы ничего оптимизировать ))))
            jnz .ЦИКЛ                 ; // Хотя конечно оптимизировать всегда есть что
            Call ДОБАВИТЬ_КАК_КАВЫЧКУ ; // Но времени не бесконечное количество
            jnz .ЦИКЛ                 ;
            ;-------------------------;
            inc  SI                   ; // Если ничего прочитать не удалося
            Jmp .ЦИКЛ                 ; // Пропускаем символ ..........
            ;-------------------------;

.КЦИКЛ:


.ВЫХОД:
            ;-------------------------;
            call ВОЗВРАТИТЬ_DI        ; // Возвращает адрес консоли
            test di,di                ; // Внтури котрой расположна сама программа
            popad                     ; // Если прочитать ничего не удалося возвращет
            ret                       ; // DI = 0  Флаг Z 0
            ;-------------------------;
            END IF                    ;}
IF  (ПЛАТФОРМА = T16)   ;{ Версия для 16 бит
            pushad                    ; // { ОПИСАНИЕ
            ;-------------------------------------------------------------------
            ; Разбивает текст программы из окна DI на слова
            ; Возращает в регистре DI адрес на структуру содержащию список слов
            ; На Входе DI адрес окна
            ; На выходе адрес DI элемента содеражего список слов
            ;------------------------------------------------------------------}
            ;-------------------------;
            call ОКНО_ТЕК             ; // Записываем в AX адрес строки с текстом прогрыммы
            JZ  .ВЫХОД                ; // Если нету текста прогрммы то выход c DI 0
            mov  si,ax                ; // Запоминаем адрес текста программы
            call ОКНО_МОНИТОР         ; // Содаем консоль
            call СОЗДАТЬ_ЭЛЕ_DI_С_ПРОГ;
            ;-------------------------;

.ЦИКЛ:      ;-------------------------;
            mov  al,[si]              ;
            test al,al                ;
            jZ  .КЦИКЛ                ; // Выход приокончании строки
            ;-------------------------;
            call ДОБАВИТЬ_КАК_СЛОВО   ;
            jnz .ЦИКЛ                 ;
            call ДОБАВИТЬ_КАК_ЧИСЛО   ;
            jnz .ЦИКЛ                 ;
            Call ДОБАВИТЬ_КАК_ЗНАК    ;
            jnz .ЦИКЛ                 ;
            Call ДОБАВИТЬ_КАК_КАВЫЧКУ ;
            jnz .ЦИКЛ                 ;
            ;-------------------------;
            inc  SI                   ; // Если ничего прочитать не удалося
            Jmp .ЦИКЛ                 ; // Пропускаем символ
            ;-------------------------;

.КЦИКЛ:


.ВЫХОД:
            ;-------------------------;
            call ВОЗВРАТИТЬ_DI        ;
            test di,di                ;
            popad                     ;
            ret                       ;
            ;-------------------------;
            END IF                    ;}
IF  (ПЛАТФОРМА = T32)   ;{ Версия для 32 бит
            pushad                    ; // { ОПИСАНИЕ
            ;-------------------------------------------------------------------
            ; Разбивает текст программы из окна DI на слова
            ; Возращает в регистре DI адрес на структуру содержащию список слов
            ; На Входе DI адрес окна
            ; На выходе адрес DI элемента содеражего список слов
            ;------------------------------------------------------------------}
            ;-------------------------;
            call ОКНО_ТЕК             ; // Записываем в AX адрес строки с текстом прогрыммы
            JZ  .ВЫХОД                ; // Если нету текста прогрммы то выход c DI 0
            mov  esi,eax              ; // Запоминаем адрес текста программы
            call ОКНО_МОНИТОР         ; // Содаем консоль
            call СОЗДАТЬ_ЭЛЕ_DI_С_ПРОГ;
            ;-------------------------;

.ЦИКЛ:      ;-------------------------;
            mov  al,[esi]             ;
            test al,al                ;
            jZ  .КЦИКЛ                ; // Выход приокончании строки
            ;-------------------------;
            call ДОБАВИТЬ_КАК_СЛОВО   ;
            jnz .ЦИКЛ                 ;
            call ДОБАВИТЬ_КАК_ЧИСЛО   ;
            jnz .ЦИКЛ                 ;
            Call ДОБАВИТЬ_КАК_ЗНАК    ;
            jnz .ЦИКЛ                 ;
            Call ДОБАВИТЬ_КАК_КАВЫЧКУ ;
            jnz .ЦИКЛ                 ;
            ;-------------------------;
            inc  eSI                  ; // Если ничего прочитать не удалося
            Jmp .ЦИКЛ                 ; // Пропускаем символ
            ;-------------------------;

.КЦИКЛ:


.ВЫХОД:
            ;-------------------------;
            call ВОЗВРАТИТЬ_DI        ;
            test edi,edi              ;
            popad                     ;
            ret                       ;
            ;-------------------------;
            END IF                    ;}

СОЗДАТЬ_ЭЛЕ_DI_С_ПРОГ:;{ Создает Элемент DI с испонительной программой Внутри DI
                        ;{ Описание
;     Создает элемент внтри элемента DI то есть внутри консоли возвращет его адрес в DI
;     Структура содеращия программу имеет тип число незнай почему имено число
;     Но поками что так дело в том что каждый элемент должен иметь свой тип
;     Строка или число пока тока 2 типа вернее 3 еще есть тип 0 это корневая структура
;     С котрой начинаються все остальные структуры в системе в будуещем будут еще
;     ТИпы например REAL числа с плавающей точкой так же тип элемента важен
;     При его разрушении что бы правельно освобождать память
;}
IF  (ПЛАТФОРМА = ДОС)   ;{
          ;-------------------------;
          PUSHAD                    ;
          mov  al,ТИП_ЧИСЛ          ; // Тип Число
          mov  ah,1                 ; // Участвует в поиске
          mov  si,.ИМЯ              ; // Имя элемента
          mov  bx,0                 ; // Значение 0 как число
          call ЭЛЕ_СОЗДАТЬ          ; // Создаем элемнт где будет спис слов
          call ВОЗВРАТИТЬ_DI        ;
          POPAD                     ;
          ret                       ;
          ;-------------------------;
          END IF                    ;}
IF  (ПЛАТФОРМА = T16)   ;{
          ;-------------------------; // Чаек попить нужно 1 мин
          PUSHAD                    ;
          mov  al,ТИП_ЧИСЛ          ; // Тип Число
          mov  ah,1                 ; // Участвует в поиске
          mov  si,.ИМЯ              ; // Имя элемента
          mov  bx,0                 ; // Значение 0 как число
          call ЭЛЕ_СОЗДАТЬ          ; // Создаем элемнт где будет спис слов
          call ВОЗВРАТИТЬ_DI        ;
          POPAD                     ;
          ;-------------------------;
          ret                       ;
          END IF                    ;}
IF  (ПЛАТФОРМА = T32)   ;{
          ;-------------------------; // Чаек попить нужно 1 мин
          PUSHAD                    ;
          mov  al,ТИП_ЧИСЛ          ; // Тип Число
          mov  ah,1                 ; // Участвует в поиске
          mov  esi,.ИМЯ              ; // Имя элемента
          mov  ebx,0                 ; // Значение 0 как число
          call ЭЛЕ_СОЗДАТЬ          ; // Создаем элемнт где будет спис слов
          call ВОЗВРАТИТЬ_DI        ;
          POPAD                     ;
          ;-------------------------;
          ret                       ;
          END IF                    ;}
.ИМЯ: db "PROG",0 ; Имя элемнта содержащего стуркутуру программы
;------------------------------------------------------------------------------}
ДОБАВИТЬ_КАК_СЛОВО   :;{ Делает c буквы SI стр  эле и добавлет в DI как СТРОКУ .
IF  (ПЛАТФОРМА = ДОС)   ;{
         pushad
                                  ; {ОПИСАНИЕ
         ;----------------------------------------------------------------------
         ; DI - Родительсикй элемнт в котром нужно создать элемент
         ; SI - Указатель на букву с котрой нужно попытаться прочитать слово
         ; Изменяет SI в случаае успеха флаг Z = 1
         ; Не изменяет SI если прочитать не удалося флаг Z = 0
         ; --------------------------------------------------------------------}
         mov  cx,0                ; // Длина прочитаного слова равна 0
         call ЧИТ_СЛОВО_С_SI_В_DX ; // Читает слово с строки SI Создает элемент  DX
         jz  .ВЫХОД               ; // Если это не слово то выход
         ;------------------------;
         call ДЛИНА_СТРОКИ_DX_В_CX; // Читаю длину прочитаной строки в CX
         ;------------------------;
         pushad                   ; // Сохраняю указатель
         mov  si,dx               ; // Имя котрое будет у элемента
         mov  bx,dx               ; // Значение котрое будет у элемента
         mov  al,ТИП_СТРО         ; // Тип Строка
         mov  ah,0                ; // Не участвует в поиске
         call ЭЛЕ_СОЗДАТЬ         ; // Содаею Элемнт добавлю в уонец элемнта DI
         popad                    ; // Востанавливаю указатель
         ;------------------------;
         add  si,cx               ; // Изменяю указатель на длину проч строки CX
         ;------------------------;
.ВЫХОД:
         call ВОЗВРАТИТЬ_SI       ; // Изменяет указатель на символ с котрого читаем
         test cx,cx               ; // Если длина слова равна 0 то прочитать ничего не удалося
         popad                    ;
         ret                      ;
         END IF                   ;}
IF  (ПЛАТФОРМА = T16)   ;{
         pushad                   ; {ОПИСАНИЕ
         ;----------------------------------------------------------------------
         ; DI - Родительсикй элемнт в котром нужно создать элемент
         ; SI - Указатель на букву с котрой нужно попытаться прочитать слово
         ; Изменяет SI в случаае успеха JNZ
         ; Не изменяет SI если прочитать не удалося JZ
         ; --------------------------------------------------------------------}
         mov  cx,0                ; // Длина прочитаного слова равна 0
         call ЧИТ_СЛОВО_С_SI_В_DX ; // Читает слово с строки SI Создает стр DX
         jz  .ВЫХОД               ; // Если это не слово то выход
         ;------------------------;
         call ДЛИНА_СТРОКИ_DX_В_CX; // Читаю длину прочитаной строки в CX
         ;------------------------;
         pushad                   ; // Сохраняю указатель
         mov  si,dx               ; // Имя котрое будет у элемента
         mov  bx,dx               ; // Значение котрое будет у элемента
         mov  al,ТИП_СТРО         ; // Тип Строка
         mov  ah,0                ; // Не участвует в поиске
         call ЭЛЕ_СОЗДАТЬ         ; // Содаею Элемнт добавлю в уонец элемнта DI
         popad                    ; // Востанавливаю указатель
         ;------------------------;
         add  si,cx               ; // Изменяю указатель на длину проч строки CX
         ;------------------------;
.ВЫХОД:
         call ВОЗВРАТИТЬ_SI       ;
         test cx,cx               ;
         popad                    ;
         ret                      ;
         END IF                   ;}
IF  (ПЛАТФОРМА = T32)   ;{
         pushad                   ; {ОПИСАНИЕ
         ;----------------------------------------------------------------------
         ; DI - Родительсикй элемнт в котром нужно создать элемент
         ; SI - Указатель на букву с котрой нужно попытаться прочитать слово
         ; Изменяет SI в случаае успеха JNZ
         ; Не изменяет SI если прочитать не удалося JZ
         ; --------------------------------------------------------------------}

         mov  ecx,0                ; // Длина прочитаного слова равна 0
         call ЧИТ_СЛОВО_С_SI_В_DX ; // Читает слово с строки SI Создает стр DX
         jz  .ВЫХОД               ; // Если это не слово то выход
         ;------------------------;
         call ДЛИНА_СТРОКИ_DX_В_CX; // Читаю длину прочитаной строки в CX
         ;------------------------;
         pushad                   ; // Сохраняю указатель
         mov  esi,edx             ; // Имя котрое будет у элемента
         mov  ebx,edx             ; // Значение котрое будет у элемента
         mov  al,ТИП_СТРО         ; // Тип Строка
         mov  ah,0                ; // Не участвует в поиске
         call ЭЛЕ_СОЗДАТЬ         ; // Содаею Элемнт добавлю в уонец элемнта DI
         popad                    ; // Востанавливаю указатель
         ;------------------------;
         add  esi,ecx               ; // Изменяю указатель на длину проч строки CX
         ;------------------------;
.ВЫХОД:
         call ВОЗВРАТИТЬ_SI       ;
         test ecx,ecx               ;
         popad                    ;
         ret                      ;
         END IF                   ;}
;}
ДОБАВИТЬ_КАК_ЧИСЛО   :;{ Делает из стр DX число эле и добавлет в DI как число. .
IF  (ПЛАТФОРМА = ДОС)   ;{
         pushad                    ; {ОПИСАНИЕ
         ;----------------------------------------------------------------------
         ; DI - Родительсикй элемнт в котром нужно создать элемент
         ; SI - Указатель на букву с котрой нужно попытаться прочитать Число
         ; Изменяет SI в случаае успеха JNZ
         ; Не изменяет SI если прочитать не удалося JZ
         ; --------------------------------------------------------------------}
         mov  cx,0                 ; // Длина прочитаного слова равна 0
         call ЧИТ_ЧИСЛО_С_SI_В_DX  ; // Читает число с строки SI Возвращает слово DX
         jz  .ВЫХОД                ; // Если прочитать не удалося Выход
         ;-------------------------;
         call ДЛИНА_СТРОКИ_DX_В_CX ; // Запоминаю длину строки в CX;
         ;-------------------------;
         pushad                    ;
         mov  Si,dx                ; // Имя элемента
         mov  bx,dx                ; // Значение элемента
         call СТРО_BX_В_ЧИСЛ_BX    ; // Переводит строку BX в число BX Значение
         mov  al,ТИП_ЧИСЛ          ; // Тип Число
         mov  ah,0                 ; // Не участвует в поиске поками что
         call ЭЛЕ_СОЗДАТЬ          ; // Создаю Элемнт добавлю в конец элемнта DI
         call УДАЛИТЬ_СТРОКУ_DX    ; // Удаляю стролку прочитаную из SI;
         popad                     ;
         ;-------------------------;
         add  SI,CX                ; // Увеличиваю Указатель на длину числа CX
         ;-------------------------;
.ВЫХОД:
         ;-------------------------;
         call ВОЗВРАТИТЬ_SI        ; // Возвращает Указатель на читаемое число
         test cx,cx                ; // Если что то удалося прочитать CX<>0
         popad                     ; // Если прочитать не удалося Si не меняеться
         ret                       ;
         END IF                    ;}
IF  (ПЛАТФОРМА = T16)   ;{
         pushad                    ; {ОПИСАНИЕ
         ;----------------------------------------------------------------------
         ; DI - Родительсикй элемнт в котром нужно создать элемент
         ; SI - Указатель на букву с котрой нужно попытаться прочитать Число
         ; Изменяет SI в случаае успеха JNZ
         ; Не изменяет SI если прочитать не удалося JZ
         ; --------------------------------------------------------------------}
         mov  cx,0                 ; // Длина прочитаного слова равна 0
         call ЧИТ_ЧИСЛО_С_SI_В_DX  ; // Читает слово с строки SI Возвращает слово DX
         jz  .ВЫХОД                ; // Если прочитать не удалося Выход
         ;-------------------------;
         call ДЛИНА_СТРОКИ_DX_В_CX ; // Запоминаю длину строки в CX;
         ;-------------------------;
         pushad                    ;
         mov  Si,dx                ; // Имя элемента
         mov  bx,dx                ; // Значение элемента
         call СТРО_BX_В_ЧИСЛ_BX    ; // Переводит строку BX в число BX Значение
         mov  al,ТИП_ЧИСЛ          ; // Тип Число
         mov  ah,0                 ; // Не участвует в поиске поками что
         call ЭЛЕ_СОЗДАТЬ          ; // Создаю Элемнт добавлю в уонец элемнта DI
         call УДАЛИТЬ_СТРОКУ_DX    ; // Удаляю стролку прочитаную из SI;
         popad                     ;
         ;-------------------------;
         add  SI,CX                ; // Увеличиваю Указатель на длину слова CX
         ;-------------------------;
.ВЫХОД:
         ;-------------------------;
         call ВОЗВРАТИТЬ_SI        ; // Возвращает Указатель на читаемое слово
         test cx,cx                ; // Если что то удалося прочитать CX<>0
         popad                     ; // Если прочитать не удалося Si не меняеться
         ret                       ;
         END IF                    ;}
IF  (ПЛАТФОРМА = T32)   ;{
         pushad                    ; {ОПИСАНИЕ
         ;----------------------------------------------------------------------
         ; DI - Родительсикй элемнт в котром нужно создать элемент
         ; SI - Указатель на букву с котрой нужно попытаться прочитать Число
         ; Изменяет SI в случаае успеха JNZ
         ; Не изменяет SI если прочитать не удалося JZ
         ; --------------------------------------------------------------------}
         mov  ecx,0                 ; // Длина прочитаного слова равна 0
         call ЧИТ_ЧИСЛО_С_SI_В_DX  ; // Читает слово с строки SI Возвращает слово DX
         jz  .ВЫХОД                ; // Если прочитать не удалося Выход
         ;-------------------------;
         call ДЛИНА_СТРОКИ_DX_В_CX ; // Запоминаю длину строки в CX;
         ;-------------------------;


         pushad                    ;
         mov  eSi,edx                ; // Имя элемента
         mov  ebx,edx                ; // Значение элемента
         call СТРО_BX_В_ЧИСЛ_BX    ; // Переводит строку BX в число BX Значение
         mov  al,ТИП_ЧИСЛ          ; // Тип Число
         mov  ah,0                 ; // Не участвует в поиске поками что
         call ЭЛЕ_СОЗДАТЬ          ; // Создаю Элемнт добавлю в уонец элемнта DI
         call УДАЛИТЬ_СТРОКУ_DX    ; // Удаляю стролку прочитаную из SI;
         popad                     ;
         ;-------------------------;
         add  eSI,eCX                ; // Увеличиваю Указатель на длину слова CX
         ;-------------------------;
.ВЫХОД:
         ;-------------------------;
         call ВОЗВРАТИТЬ_SI        ; // Возвращает Указатель на читаемое слово
         test ecx,ecx                ; // Если что то удалося прочитать CX<>0
         popad                     ; // Если прочитать не удалося Si не меняеться
         ret                       ;
         END IF                    ;}
;}
ДОБАВИТЬ_КАК_ЗНАК    :;{ Делает из стр DX ЗНАК  эле и добавлет в DI как Знак   .
IF  (ПЛАТФОРМА = ДОС)   ;{
         pushad                    ; {ОПИСАНИЕ
         ;----------------------------------------------------------------------
         ; DI - Родительсикй элемнт в котром нужно создать элемент
         ; SI - Указатель на букву с котрой нужно попытаться прочитать Знак
         ; Изменяет SI в случаае успеха JNZ
         ; Не изменяет SI если прочитать не удалося JZ
         ; --------------------------------------------------------------------}
         mov  cx,0                 ; // Длина прочитаного слова равна 0
         call ЧИТ_ЗНАК_С_SI_В_DX   ; // Читает Знак с строки SI Возвращает строку DX
         jz  .ВЫХОД                ; // Если прочитать не удалося Выход
         ;-------------------------;
         call ДЛИНА_СТРОКИ_DX_В_CX ; // Запоминаю длину строки в CX;
         ;-------------------------;
         pushad                    ;
         mov  Si,dx                ; // Имя элемента
         mov  bx,dx                ; // Значение элемента
         mov  al,ТИП_СТРО          ; // Тип СТрока
         mov  ah,0                 ; // Не участвует в поиске поками что
         call ЭЛЕ_СОЗДАТЬ          ; // Создаю Элемнт добавлю в уонец элемнта DI
         popad                     ;
         ;-------------------------;
         add  SI,CX                ; // Увеличиваю Указатель на длину слова CX
         ;-------------------------;
.ВЫХОД:
         ;-------------------------;
         call ВОЗВРАТИТЬ_SI        ; // Возвращает Указатель на читаемое слово
         test cx,cx                ; // Если что то удалося прочитать CX<>0
         popad                     ; // Если прочитать не удалося Si не меняеться
         ret                       ;
         END IF                    ;}
IF  (ПЛАТФОРМА = T16)   ;{
         pushad                    ; {ОПИСАНИЕ
         ;----------------------------------------------------------------------
         ; DI - Родительсикй элемнт в котром нужно создать элемент
         ; SI - Указатель на букву с котрой нужно попытаться прочитать Число
         ; Изменяет SI в случаае успеха JNZ
         ; Не изменяет SI если прочитать не удалося JZ
         ; --------------------------------------------------------------------}
         mov  cx,0                 ; // Длина прочитаного слова равна 0
         call ЧИТ_ЗНАК_С_SI_В_DX   ; // Читает слово с строки SI Возвращает слово DX
         jz  .ВЫХОД                ; // Если прочитать не удалося Выход
         ;-------------------------;
         call ДЛИНА_СТРОКИ_DX_В_CX ; // Запоминаю длину строки в CX;
         ;-------------------------;
         pushad                    ;
         mov  Si,dx                ; // Имя элемента
         mov  bx,dx                ; // Значение элемента
         mov  al,ТИП_СТРО          ; // Тип СТрока
         mov  ah,0                 ; // Не участвует в поиске поками что
         call ЭЛЕ_СОЗДАТЬ          ; // Создаю Элемнт добавлю в уонец элемнта DI
         popad                     ;
         ;-------------------------;
         add  SI,CX                ; // Увеличиваю Указатель на длину слова CX
         ;-------------------------;
.ВЫХОД:
         ;-------------------------;
         call ВОЗВРАТИТЬ_SI        ; // Возвращает Указатель на читаемое слово
         test cx,cx                ; // Если что то удалося прочитать CX<>0
         popad                     ; // Если прочитать не удалося Si не меняеться
         ret                       ;
         END IF                    ;}
IF  (ПЛАТФОРМА = T32)   ;{
         pushad                    ; {ОПИСАНИЕ
         ;----------------------------------------------------------------------
         ; DI - Родительсикй элемнт в котром нужно создать элемент
         ; SI - Указатель на букву с котрой нужно попытаться прочитать Число
         ; Изменяет SI в случаае успеха JNZ
         ; Не изменяет SI если прочитать не удалося JZ
         ; --------------------------------------------------------------------}
         mov  ecx,0                 ; // Длина прочитаного слова равна 0

         call ЧИТ_ЗНАК_С_SI_В_DX   ; // Читает слово с строки SI Возвращает слово DX
         jz  .ВЫХОД                ; // Если прочитать не удалося Выход
         ;-------------------------;
         call ДЛИНА_СТРОКИ_DX_В_CX ; // Запоминаю длину строки в CX;
         ;-------------------------;
         pushad                    ;
         mov  eSi,edx                ; // Имя элемента
         mov  ebx,edx                ; // Значение элемента
         mov  al,ТИП_СТРО          ; // Тип СТрока
         mov  ah,0                 ; // Не участвует в поиске поками что
         call ЭЛЕ_СОЗДАТЬ          ; // Создаю Элемнт добавлю в уонец элемнта DI
         popad                     ;
         ;-------------------------;
         add  eSI,eCX                ; // Увеличиваю Указатель на длину слова CX
         ;-------------------------;
.ВЫХОД:
         ;-------------------------;
         call ВОЗВРАТИТЬ_SI        ; // Возвращает Указатель на читаемое слово
         test ecx,ecx                ; // Если что то удалося прочитать CX<>0
         popad                     ; // Если прочитать не удалося Si не меняеться
         ret                       ;
         END IF                    ;}
;}
ДОБАВИТЬ_КАК_КАВЫЧКУ :;{ Делает из стр DX КАВЫЧ эле и добавлет в DI как Кавычку.
IF  (ПЛАТФОРМА = ДОС)   ;{
         pushad                    ; {ОПИСАНИЕ
         ;----------------------------------------------------------------------
         ; DI - Родительсикй элемнт в котром нужно создать элемент
         ; SI - Указатель на букву с котрой нужно попытаться прочитать Число
         ; Изменяет SI в случаае успеха JNZ
         ; Не изменяет SI если прочитать не удалося JZ
         ; --------------------------------------------------------------------}
         mov  cx,0                 ; // Длина прочитаного слова равна 0
         call ЧИТ_КАВЫЧКУ_С_SI_В_DX; // Читает слово с строки SI Возвращает слово DX
         jz  .ВЫХОД                ; // Если прочитать не удалося Выход

         ;-------------------------;
         call ДЛИНА_СТРОКИ_DX_В_CX ; // Запоминаю длину строки в CX;
         ;-------------------------;
         pushad                    ;
         mov  Si,dx                ; // Имя элемента
         mov  bx,dx                ; // Значение элемента
         mov  al,ТИП_СТРО          ; // Тип Строка
         mov  ah,0                 ; // Не участвует в поиске поками что
         call ЭЛЕ_СОЗДАТЬ          ; // Создаю Элемнт добавлю в уонец элемнта DI
         popad                     ;
         ;-------------------------;
         add  SI,CX                ; // Увеличиваю Указатель на длину слова CX
         add  si,2                 ;
         ;-------------------------;
.ВЫХОД:
         ;-------------------------;
         call ВОЗВРАТИТЬ_SI        ; // Возвращает Указатель на читаемое слово
         test cx,cx                ; // Если что то удалося прочитать CX<>0
         popad                     ; // Если прочитать не удалося Si не меняеться
         ret                       ;
         END IF                    ;}
IF  (ПЛАТФОРМА = T16)   ;{
         pushad                    ; {ОПИСАНИЕ
         ;----------------------------------------------------------------------
         ; DI - Родительсикй элемнт в котром нужно создать элемент
         ; SI - Указатель на букву с котрой нужно попытаться прочитать Число
         ; Изменяет SI в случаае успеха JNZ
         ; Не изменяет SI если прочитать не удалося JZ
         ; --------------------------------------------------------------------}
         mov  cx,0                 ; // Длина прочитаного слова равна 0
         call ЧИТ_КАВЫЧКУ_С_SI_В_DX; // Читает слово с строки SI Возвращает слово DX
         jz  .ВЫХОД                ; // Если прочитать не удалося Выход

         ;-------------------------;
         call ДЛИНА_СТРОКИ_DX_В_CX ; // Запоминаю длину строки в CX;
         ;-------------------------;
         pushad                    ;
         mov  Si,dx                ; // Имя элемента
         mov  bx,dx                ; // Значение элемента
         mov  al,ТИП_СТРО          ; // Тип Строка
         mov  ah,0                 ; // Не участвует в поиске поками что
         call ЭЛЕ_СОЗДАТЬ          ; // Создаю Элемнт добавлю в уонец элемнта DI
         popad                     ;
         ;-------------------------;
         add  SI,CX                ; // Увеличиваю Указатель на длину слова CX
         add  si,2                 ;
         ;-------------------------;
.ВЫХОД:
         ;-------------------------;
         call ВОЗВРАТИТЬ_SI        ; // Возвращает Указатель на читаемое слово
         test cx,cx                ; // Если что то удалося прочитать CX<>0
         popad                     ; // Если прочитать не удалося Si не меняеться
         ret                       ;
         END IF                    ;}
IF  (ПЛАТФОРМА = T32)   ;{
         pushad                    ; {ОПИСАНИЕ
         ;----------------------------------------------------------------------
         ; DI - Родительсикй элемнт в котром нужно создать элемент
         ; SI - Указатель на букву с котрой нужно попытаться прочитать Число
         ; Изменяет SI в случаае успеха JNZ
         ; Не изменяет SI если прочитать не удалося JZ
         ; --------------------------------------------------------------------}
         mov  ecx,0                 ; // Длина прочитаного слова равна 0
         call ЧИТ_КАВЫЧКУ_С_SI_В_DX; // Читает слово с строки SI Возвращает слово DX
         jz  .ВЫХОД                ; // Если прочитать не удалося Выход

         ;-------------------------;
         call ДЛИНА_СТРОКИ_DX_В_CX ; // Запоминаю длину строки в CX;
         ;-------------------------;
         pushad                    ;
         mov  eSi,edx                ; // Имя элемента
         mov  ebx,edx                ; // Значение элемента
         mov  al,ТИП_СТРО          ; // Тип Строка
         mov  ah,0                 ; // Не участвует в поиске поками что
         call ЭЛЕ_СОЗДАТЬ          ; // Создаю Элемнт добавлю в уонец элемнта DI
         popad                     ;
         ;-------------------------;
         add  eSI,eCX                ; // Увеличиваю Указатель на длину слова CX
         add  esi,2                 ;
         ;-------------------------;
.ВЫХОД:
         ;-------------------------;
         call ВОЗВРАТИТЬ_SI        ; // Возвращает Указатель на читаемое слово
         test ecx,ecx                ; // Если что то удалося прочитать CX<>0
         popad                     ; // Если прочитать не удалося Si не меняеться
         ret                       ;
         END IF                    ;}

;}

;==============================================================================}
ДОП_ТИП_СЛОВ:;{ Определяет доп типы слов в списке элемента DI ; Сюда еще вернуться нада будет убрать BX
IF  (ПЛАТФОРМА = ДОС)   ;{
            pushad                  ; { ОПИСАНИЕ
            ; В этом блоку из программы удаляються не нужные слова
            ; Например ( 2 * 4 ) или ( 2 умножить на 4) Частица НА удаляеться )
            ; Так же тут идет привдение логических типов например
            ; Преобразует слова TRUE ПРАВДА в число  1
            ; ПРеобразует слова FALSE ЛОЖ в число  0
            ;}
            call ЭЛЕ_ВЛО            ; // первый вложеный элемент элемента DI
                                    ;
            ;-----------------------;
.ЦИКЛ:      test  ax,ax             ; // Если в AX = 0 ТО выход
            jz   .ВЫХОД             ;
            mov   di,ax             ; // Переносим результат из AX в DI
            call  ЭЛЕ_СЛЕ           ; // Переходим к следующему элменту
            mov   bx,ax             ; // Запоминаем адрес след элемента в BX
            ;-----------------------;
            call  ЭЛЕ_КОД           ; // Читаем код элемента у каждого слова есть код в словаре
            mov   si,.ЛОГИЧ         ; // Тут видимо ЛОгический тип аааа точно
            call  ПОИСК_AX_В_СТР_SI ; // В SI Список 2 операций например := <=
            jnz  .ЭТО_ЛОГИКА        ; // Ищит одну из комбинаций
            ;-----------------------;
            mov   si,.УДАЛЯЕМЫЕ     ;
            call  ПОИСК_AX_В_СТР_SI ;
            jnz  .ЭТО_УДАЛ          ;
.ДАЛЕЕ:     call  ЭЛЕ_СЛЕ           ; // Переходим к следующему элементу в списке
            jmp  .ЦИКЛ              ; // Адр след элемнта в AX
            ;-----------------------l
.ЭТО_УДАЛ:
            ;-----------------------; // А тут удаляемые слова из программы
            call ЭЛЕ_УДАЛИТЬ        ; // Пустые выражения
            mov  ax,bx              ; // Задумвалося например
            jmp .ЦИКЛ               ; // Если пишеш УМНОЖИТЬ Вместо *
            ;-----------------------; // УМНОЖИТЬ НА удаляемое слово НА
.ЭТО_ЛОГИКА:call ЭЛЕ_СТР_В_ЛОГ      ;
            jmp .ДАЛЕЕ              ;
            ;-----------------------;
.ВЫХОД:
            popad ;
            ret   ;

.ЗНАКИ    : DW КОД_КОМ_ЛОГИ,КОД_КОМ_ЛОГИЛИ,0; // Через заптяую я тут перечислял коды операций
.ЛОГИЧ    : DW КОД_КОМ_ПРАВДА,КОД_КОМ_ЛОЖ,0 ; // Тут логические выражения ПРАВДА , ЛОЖ
.УДАЛЯЕМЫЕ: DW КОД_КОМ_НА,0                 ; // А тут удаляемые слова котрые не нужны

            END IF                   ;}
IF  (ПЛАТФОРМА = T16)   ;{
            pushad                  ; { ОПИСАНИЕ
            ; В этом блоку из программы удаляються не нужные слова
            ; Например ( 2 * 4 ) или ( 2 умножить на 4) Частица НА удаляеться )
            ; Так же тут идет привдение логических типов например
            ; Преобразует слова TRUE ПРАВДА в число  1
            ; ПРеобразует слова FALSE ЛОЖ в число  0
            ;}
            call ЭЛЕ_ВЛО            ; // первый вложеный элемент элемента DI
                                    ;
            ;-----------------------;
.ЦИКЛ:      test  ax,ax             ; // Если в AX = 0 ТО выход
            jz   .ВЫХОД             ;
            mov   di,ax             ; // Переносим результат из AX в DI
            call  ЭЛЕ_СЛЕ           ; // Переходим к следующему элменту
            mov   bx,ax             ; // Запоминаем адрес след элемента в BX
            ;-----------------------;
            call  ЭЛЕ_КОД           ; // Читаем код элемента у каждого слова есть код в словаре
            mov   si,.ЛОГИЧ         ; // Тут видимо ЛОгический тип аааа точно
            call  ПОИСК_AX_В_СТР_SI ; // В SI Список 2 операций например := <=
            jnz  .ЭТО_ЛОГИКА        ; // Ищит одну из комбинаций
            ;-----------------------;
            mov   si,.УДАЛЯЕМЫЕ     ;
            call  ПОИСК_AX_В_СТР_SI ;
            jnz  .ЭТО_УДАЛ          ;
.ДАЛЕЕ:     call  ЭЛЕ_СЛЕ           ; // Переходим к следующему элементу в списке
            jmp  .ЦИКЛ              ; // Адр след элемнта в AX
            ;-----------------------l
.ЭТО_УДАЛ:
            ;-----------------------; // А тут удаляемые слова из программы
            call ЭЛЕ_УДАЛИТЬ        ; // Пустые выражения
            mov  ax,bx              ; // Задумвалося например
            jmp .ЦИКЛ               ; // Если пишеш УМНОЖИТЬ Вместо *
            ;-----------------------; // УМНОЖИТЬ НА удаляемое слово НА
.ЭТО_ЛОГИКА:call ЭЛЕ_СТР_В_ЛОГ      ;
            jmp .ДАЛЕЕ              ;
            ;-----------------------;
.ВЫХОД:
            popad ;
            ret   ;

.ЗНАКИ    : DW КОД_КОМ_ЛОГИ,КОД_КОМ_ЛОГИЛИ,0; // Через заптяую я тут перечислял коды операций
.ЛОГИЧ    : DW КОД_КОМ_ПРАВДА,КОД_КОМ_ЛОЖ,0 ; // Тут логические выражения ПРАВДА , ЛОЖ
.УДАЛЯЕМЫЕ: DW КОД_КОМ_НА,0                 ; // А тут удаляемые слова котрые не нужны

            END IF                   ;}
IF  (ПЛАТФОРМА = T32)   ;{
            pushad                  ; { ОПИСАНИЕ
            ; В этом блоку из программы удаляються не нужные слова
            ; Например ( 2 * 4 ) или ( 2 умножить на 4) Частица НА удаляеться )
            ; Так же тут идет привдение логических типов например
            ; Преобразует слова TRUE ПРАВДА в число  1
            ; ПРеобразует слова FALSE ЛОЖ в число  0
            ;}
            call ЭЛЕ_ВЛО            ; // первый вложеный элемент элемента DI
                                    ;
            ;-----------------------;
.ЦИКЛ:      test  eax,eax           ; // Если в AX = 0 ТО выход
            jz   .ВЫХОД             ;
            mov   edi,eax           ; // Переносим результат из AX в DI
            call  ЭЛЕ_СЛЕ           ; // Переходим к следующему элменту
            mov   ebx,eax           ; // Запоминаем адрес след элемента в BX
            ;-----------------------;
            call  ЭЛЕ_КОД           ; // Читаем код элемента у каждого слова есть код в словаре
            mov   esi,.ЛОГИЧ        ; // Тут видимо ЛОгический тип аааа точно
            call  ПОИСК_AX_В_СТР_SI ; // В SI Список 2 операций например := <=
            jnz  .ЭТО_ЛОГИКА        ; // Ищит одну из комбинаций
            ;-----------------------;
            mov   esi,.УДАЛЯЕМЫЕ     ;
            call  ПОИСК_AX_В_СТР_SI ;
            jnz  .ЭТО_УДАЛ          ;
.ДАЛЕЕ:     call  ЭЛЕ_СЛЕ           ; // Переходим к следующему элементу в списке
            jmp  .ЦИКЛ              ; // Адр след элемнта в AX
            ;-----------------------l
.ЭТО_УДАЛ:
            ;-----------------------; // А тут удаляемые слова из программы
            call ЭЛЕ_УДАЛИТЬ        ; // Пустые выражения
            mov  eax,ebx              ; // Задумвалося например
            jmp .ЦИКЛ               ; // Если пишеш УМНОЖИТЬ Вместо *
            ;-----------------------; // УМНОЖИТЬ НА удаляемое слово НА
.ЭТО_ЛОГИКА:call ЭЛЕ_СТР_В_ЛОГ      ;
            jmp .ДАЛЕЕ              ;
            ;-----------------------;
.ВЫХОД:
            popad ;
            ret   ;

.ЗНАКИ    : DD КОД_КОМ_ЛОГИ,КОД_КОМ_ЛОГИЛИ,0; // Через заптяую я тут перечислял коды операций
.ЛОГИЧ    : DD КОД_КОМ_ПРАВДА,КОД_КОМ_ЛОЖ,0 ; // Тут логические выражения ПРАВДА , ЛОЖ
.УДАЛЯЕМЫЕ: DD КОД_КОМ_НА,0                 ; // А тут удаляемые слова котрые не нужны

            END IF                   ;}

; А пока тут размещю
ЭЛЕ_СТР_В_ЛОГ:;{ Меняет тип элемнта с строки на логику
IF  (ПЛАТФОРМА = ДОС)   ;{
         pushad                  ;
         ;-----------------------;
         Mov  si,DI              ; // В Si Записываю адрес элемента с логикой
         add  SI,ЭЛ_ТИП          ; // ПРибавляю смещение ТИПА меняю тип элемнта
         mov  Byte [si],ТИП_ЧИСЛ ; // На число вся логика представлена как 1 и 0
         ;-----------------------;
         CALL ЭЛЕ_КОД            ; // Например TRUE это 1 ПРАВДА тоже 1 FALSE 0
         cmp  ax,КОД_КОМ_ЛОЖ     ; // ПРоверяем правда или лож
         mov  dx,0               ; // ПО умолчанию лож 0
         jz  .ЭТО_ЛОЖ            ; // Если ЛОж Переход определяем по коду слова
         Mov  dx,1               ; // Если же не лож то значит правда то биш 1 )))
.ЭТО_ЛОЖ:;-----------------------; // СТрано такой огромнгый блок а всего то для
         call ЭЛЕ_ЗНА            ; // TRUE хмм............
         call УДАЛИТЬ_СТРОКУ_AX  ; // Освобождаю строку что бы память не занимала
         mov  si,Di              ; // Потому что элемент теперь число
         add  si,ЭЛ_ЗНА          ;
         mov  word [si],dx       ; // Записываю
         popad                   ;
         ret                     ;
         END IF                  ;}
IF  (ПЛАТФОРМА = T16)   ;{
         pushad                  ;
         ;-----------------------;
         Mov  si,DI              ; // В Si Записываю адрес элемента с логикой
         add  SI,ЭЛ_ТИП          ; // ПРибавляю смещение ТИПА меняю тип элемнта
         mov  Byte [si],ТИП_ЧИСЛ ; // На число вся логика представлена как 1 и 0
         ;-----------------------;
         CALL ЭЛЕ_КОД            ; // Например TRUE это 1 ПРАВДА тоже 1 FALSE 0
         cmp  ax,КОД_КОМ_ЛОЖ     ; // ПРоверяем правда или лож
         mov  dx,0               ; // ПО умолчанию лож 0
         jz  .ЭТО_ЛОЖ            ; // Если ЛОж Переход определяем по коду слова
         Mov  dx,1               ; // Если же не лож то значит правда то биш 1 )))
.ЭТО_ЛОЖ:;-----------------------; // СТрано такой огромнгый блок а всего то для
         call ЭЛЕ_ЗНА            ; // TRUE хмм............
         call УДАЛИТЬ_СТРОКУ_AX  ; // Освобождаю строку что бы память не занимала
         mov  si,Di              ; // Потому что элемент теперь число
         add  si,ЭЛ_ЗНА          ;
         mov  word [si],dx       ; // Записываю
         popad                   ;
         ret                     ;
         END IF                  ;}
IF  (ПЛАТФОРМА = T32)   ;{
         pushad                  ;
         ;-----------------------;
         Mov  esi,eDI             ; // В Si Записываю адрес элемента с логикой
         add  eSI,ЭЛ_ТИП          ; // ПРибавляю смещение ТИПА меняю тип элемнта
         mov  [esi],Byte ТИП_ЧИСЛ ; // На число вся логика представлена как 1 и 0
         ;-----------------------;
         CALL ЭЛЕ_КОД            ; // Например TRUE это 1 ПРАВДА тоже 1 FALSE 0
         cmp  eax,КОД_КОМ_ЛОЖ    ; // ПРоверяем правда или лож
         mov  edx,0              ; // ПО умолчанию лож 0
         jz  .ЭТО_ЛОЖ            ; // Если ЛОж Переход определяем по коду слова
         Mov  edx,1              ; // Если же не лож то значит правда то биш 1 )))
.ЭТО_ЛОЖ:;-----------------------; // СТрано такой огромнгый блок а всего то для
         call ЭЛЕ_ЗНА            ; // TRUE хмм............
         call УДАЛИТЬ_СТРОКУ_AX  ; // Освобождаю строку что бы память не занимала
         mov  esi,eDi            ; // Потому что элемент теперь число
         add  esi,ЭЛ_ЗНА         ;
         mov  [esi],edx          ; // Записываю
         popad                   ;
         ret                     ;
         END IF                  ;}
;}

;==============================================================================}
ВЛО_СКО     :;{ Вкладывание скобок (SI)(SI+1) в списке элемента DI
IF  (ПЛАТФОРМА = ДОС)   ;{
             pushad            ; { ОПИСАНИЕ
             ; Вложение скобок то есть например (2 3 4  5 и тд..)
             ; Внутри элемента скобка будет списко 2 3 4 5 и тд...
             ; ПОследняя скобка закрывающаяся удаляеться
             ;}

             mov    dx,di      ; // Запоминаем адрес элемента котирый сканируем
             mov    cx,DI      ; // По умолчани. контенер равен сканируемуму элемегту
             Call   ЭЛЕ_ВЛО    ; // Читаем первый вложеный Элемент в списке

.ЦИКЛ:       ;-----------------;
             test   ax,ax      ; // ПРоверяем есть ли элемент ил элементы кончилися
             JZ    .КЦИКЛ      ;
             mov    di,ax      ;
             ;-----------------;
             call   ЭЛЕ_СЛЕ    ; // ПОлучаем следующий элемент списка и запоминаем его на всяк случай
             mov    bx,ax      ;
             ;-----------------;
             call   ЭЛЕ_КОД    ; // Читаем Код имени элемента
             ;-----------------;
             cmp    cx,dx      ; // Провека что бы контенер не был равен сканируемому элемнту в таком случае мы в него складываем даллее идущие элементы
             jz    .НЕДОБАВЛЯЕМ;
             call .ДОБ_DI_В_CX ; // добавить элмент DI(Сканируемый элеминт) в элемент CX(Коннтенер )
             ;-----------------;
.НЕДОБАВЛЯЕМ:
             ;-----------------;
             cmp   ax,SI;
             JNZ  .ДАЛЕЕ2      ;
             mov   cx,di       ;
             ;-----------------;

.ДАЛЕЕ2:     ;-----------------;
             dec   ax          ; // SI+1 код закрывающейся скобки
             cmp   aX,SI       ;
             JNZ  .ДАЛЕЕ       ;
             call .ЭЛЕ_Р_CX    ; // Назначаем родительский элемнт CX в CX перемещаеимся в конетенере в родительский элемнт
             ;-----------------;

.ДАЛЕЕ:      ;-----------------;
             mov   ax,bx       ;
             jmp .ЦИКЛ         ;
             ;-----------------;

.КЦИКЛ:

             popad ;
             ret   ;


.ЭЛЕ_Р_CX:
             ;----------------;
             push di          ;
             mov  di,cx       ;
             call ЭЛЕ_РОДИТЕЛЬ;
             mov  cx,DI       ;
             pop  DI          ;
             ret              ;
             ;----------------;

.ДОБ_DI_В_CX:
             ;----------------;
             pushad           ;
             call ЭЛЕ_КОД     ; // ЧИтаем код элемента
             cmp  ax,КОД_КОМ_ЗСКОБКА;
             jz  .ПРОСТО_УДА  ;
             mov  dx,di       ;
             mov  di,CX       ;
             Call ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI;
             jmp .КВЫХОДУ     ;
.ПРОСТО_УДА:
             call ЭЛЕ_ОСВОБОДИ;
.КВЫХОДУ:
             popad            ;
             ret              ;
             ;----------------;
             END IF           ;}
IF  (ПЛАТФОРМА = T16)   ;{
             pushad            ; { ОПИСАНИЕ
             ; Вложение скобок то есть например (2 3 4  5 и тд..)
             ; Внутри элемента скобка будет списко 2 3 4 5 и тд...
             ; ПОследняя скобка закрывающаяся удаляеться
             ;}

             mov    dx,di      ; // Запоминаем адрес элемента котирый сканируем
             mov    cx,DI      ; // По умолчани. контенер равен сканируемуму элемегту
             Call   ЭЛЕ_ВЛО    ; // Читаем первый вложеный Элемент в списке

.ЦИКЛ:       ;-----------------;
             test   ax,ax      ; // ПРоверяем есть ли элемент ил элементы кончилися
             JZ    .КЦИКЛ      ;
             mov    di,ax      ;
             ;-----------------;
             call   ЭЛЕ_СЛЕ    ; // ПОлучаем следующий элемент списка и запоминаем его на всяк случай
             mov    bx,ax      ;
             ;-----------------;
             call   ЭЛЕ_КОД    ; // Читаем Код имени элемента
             ;-----------------;
             cmp    cx,dx      ; // Провека что бы контенер не был равен сканируемому элемнту в таком случае мы в него складываем даллее идущие элементы
             jz    .НЕДОБАВЛЯЕМ;
             call .ДОБ_DI_В_CX ; // добавить элмент DI(Сканируемый элеминт) в элемент CX(Коннтенер )
             ;-----------------;
.НЕДОБАВЛЯЕМ:
             ;-----------------;
             cmp   ax,SI;
             JNZ  .ДАЛЕЕ2      ;
             mov   cx,di       ;
             ;-----------------;

.ДАЛЕЕ2:     ;-----------------;
             dec   ax          ; // SI+1 код закрывающейся скобки
             cmp   aX,SI       ;
             JNZ  .ДАЛЕЕ       ;
             call .ЭЛЕ_Р_CX    ; // Назначаем родительский элемнт CX в CX перемещаеимся в конетенере в родительский элемнт
             ;-----------------;

.ДАЛЕЕ:      ;-----------------;
             mov   ax,bx       ;
             jmp .ЦИКЛ         ;
             ;-----------------;

.КЦИКЛ:

             popad ;
             ret   ;


.ЭЛЕ_Р_CX:
             ;----------------;
             push di          ;
             mov  di,cx       ;
             call ЭЛЕ_РОДИТЕЛЬ;
             mov  cx,DI       ;
             pop  DI          ;
             ret              ;
             ;----------------;

.ДОБ_DI_В_CX:
             ;----------------;
             pushad           ;
             call ЭЛЕ_КОД     ; // ЧИтаем код элемента
             cmp  ax,КОД_КОМ_ЗСКОБКА;
             jz  .ПРОСТО_УДА  ;
             mov  dx,di       ;
             mov  di,CX       ;
             Call ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI;
             jmp .КВЫХОДУ     ;
.ПРОСТО_УДА:
             call ЭЛЕ_ОСВОБОДИ;
.КВЫХОДУ:
             popad            ;
             ret              ;
             ;----------------;
             END IF           ;}
IF  (ПЛАТФОРМА = T32)   ;{
             pushad            ; { ОПИСАНИЕ
             ; Вложение скобок то есть например (2 3 4  5 и тд..)
             ; Внутри элемента скобка будет списко 2 3 4 5 и тд...
             ; ПОследняя скобка закрывающаяся удаляеться
             ;}

             mov    edx,edi    ; // Запоминаем адрес элемента котирый сканируем
             mov    ecx,eDI    ; // По умолчани. контенер равен сканируемуму элемегту
             Call   ЭЛЕ_ВЛО    ; // Читаем первый вложеный Элемент в списке

.ЦИКЛ:       ;-----------------;
             test   eax,eax    ; // ПРоверяем есть ли элемент ил элементы кончилися
             JZ    .КЦИКЛ      ;
             mov    edi,eax    ;
             ;-----------------;
             call   ЭЛЕ_СЛЕ    ; // ПОлучаем следующий элемент списка и запоминаем его на всяк случай
             mov    ebx,eax    ;
             ;-----------------;
             call   ЭЛЕ_КОД    ; // Читаем Код имени элемента
             ;-----------------;
             cmp    ecx,edx      ; // Провека что бы контенер не был равен сканируемому элемнту в таком случае мы в него складываем даллее идущие элементы
             jz    .НЕДОБАВЛЯЕМ;
             call .ДОБ_DI_В_CX ; // добавить элмент DI(Сканируемый элеминт) в элемент CX(Коннтенер )
             ;-----------------;
.НЕДОБАВЛЯЕМ:
             ;-----------------;
             cmp   eax,eSI     ;
             JNZ  .ДАЛЕЕ2      ;
             mov   ecx,edi     ;
             ;-----------------;

.ДАЛЕЕ2:     ;-----------------;
             dec   eax         ; // SI+1 код закрывающейся скобки
             cmp   eaX,eSI     ;
             JNZ  .ДАЛЕЕ       ;
             call .ЭЛЕ_Р_CX    ; // Назначаем родительский элемнт CX в CX перемещаеимся в конетенере в родительский элемнт
             ;-----------------;

.ДАЛЕЕ:      ;-----------------;
             mov   eax,ebx     ;
             jmp  .ЦИКЛ        ;
             ;-----------------;

.КЦИКЛ:

             popad             ;
             ret               ;


.ЭЛЕ_Р_CX:
             ;----------------;
             push edi         ;
             mov  edi,ecx     ;
             call ЭЛЕ_РОДИТЕЛЬ;
             mov  ecx,eDI     ;
             pop  eDI         ;
             ret              ;
             ;----------------;

.ДОБ_DI_В_CX:
             ;----------------;
             pushad           ;
             call ЭЛЕ_КОД     ; // ЧИтаем код элемента
             cmp  eax,КОД_КОМ_ЗСКОБКА;
             jz  .ПРОСТО_УДА  ;
             mov  edx,edi     ;
             mov  edi,eCX     ;

             Call ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI;

             jmp .КВЫХОДУ     ;
.ПРОСТО_УДА:
             call ЭЛЕ_ОСВОБОДИ;

.КВЫХОДУ:
             popad            ;
             ret              ;
             ;----------------;
             END IF           ;}

;==============================================================================}
ВЛО_МАТ     :;{ Вкладываени мат Si операций в списке DI
IF  (ПЛАТФОРМА = ДОС)   ;{
            pushad
            call ЭЛЕ_ВЛО          ; // Читаем первый вложеный элемент в элементе адрес котрого указан в регистре DI возврашает AX
.ЦИКЛ:      ;---------------------;
            test ax,ax            ;
            jz  .ВЫХОД            ; // ПРоверяем если элемнты кончилися то выход
            mov  di,ax            ;
            ;---------------------;
            call ВЛО_МАТ          ;
            ;---------------------;
            call ЭЛЕ_ПРЕ          ; // Проверяем наличае следующего элемнета
            jz  .ДАЛЕЕ            ;
            mov  cx,ax            ; // Запоминаем предыдущий  элемент в CX
            ;---------------------;
            call ЭЛЕ_СЛЕ          ; // Проверяем наличае следующего элемнета
            jz  .ВЫХОД            ;
            mov  dx,ax            ; // Запоминаем следующий элемент в DX
            ;---------------------;
            call ЭЛЕ_КОД          ; // Читаем адрес строки имени элемнта DI вовращает в AX
            call ПОИСК_AX_В_СТР_SI;
            jnz .ВЛОЖИТЬ          ;
            ;---------------------;
            jmp .ДАЛЕЕ            ;
            ;---------------------;
.ВЛОЖИТЬ:
            ;---------------------;
            push di               ;
            call ДОБ_ЭЛЕ_СX_В_ЭЛЕ_DI; // Добавляем предыдущий элемент
            call ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI; // Добаавляем следующий элемнт
            mov  di,dx            ;
            call ВЛО_МАТ          ;
            pop di                ;
            ;---------------------;
.ДАЛЕЕ:     call ЭЛЕ_СЛЕ          ;
            jmp .ЦИКЛ             ;
.ВЫХОД:
            popad;
            ret;
            END IF                ;}
IF  (ПЛАТФОРМА = T16)   ;{
            pushad
            call ЭЛЕ_ВЛО          ; // Читаем первый вложеный элемент в элементе адрес котрого указан в регистре DI возврашает AX
.ЦИКЛ:      ;---------------------;
            test ax,ax            ;
            jz  .ВЫХОД            ; // ПРоверяем если элемнты кончилися то выход
            mov  di,ax            ;
            ;---------------------;
            call ВЛО_МАТ          ;
            ;---------------------;
            call ЭЛЕ_ПРЕ          ; // Проверяем наличае следующего элемнета
            jz  .ДАЛЕЕ            ;
            mov  cx,ax            ; // Запоминаем предыдущий  элемент в CX
            ;---------------------;
            call ЭЛЕ_СЛЕ          ; // Проверяем наличае следующего элемнета
            jz  .ВЫХОД            ;
            mov  dx,ax            ; // Запоминаем следующий элемент в DX
            ;---------------------;
            call ЭЛЕ_КОД          ; // Читаем адрес строки имени элемнта DI вовращает в AX
            call ПОИСК_AX_В_СТР_SI;
            jnz .ВЛОЖИТЬ          ;
            ;---------------------;
            jmp .ДАЛЕЕ            ;
            ;---------------------;
.ВЛОЖИТЬ:
            ;---------------------;
            push di               ;
            call ДОБ_ЭЛЕ_СX_В_ЭЛЕ_DI; // Добавляем предыдущий элемент
            call ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI; // Добаавляем следующий элемнт
            mov  di,dx            ;
            call ВЛО_МАТ          ;
            pop di                ;
            ;---------------------;
.ДАЛЕЕ:     call ЭЛЕ_СЛЕ          ;
            jmp .ЦИКЛ             ;
.ВЫХОД:
            popad;
            ret;
            END IF                ;}
IF  (ПЛАТФОРМА = T32)   ;{
            pushad
            call ЭЛЕ_ВЛО          ; // Читаем первый вложеный элемент в элементе адрес котрого указан в регистре DI возврашает AX
.ЦИКЛ:      ;---------------------;
            test eax,eax            ;
            jz  .ВЫХОД            ; // ПРоверяем если элемнты кончилися то выход
            mov  edi,eax            ;
            ;---------------------;
            call ВЛО_МАТ          ;
            ;---------------------;
            call ЭЛЕ_ПРЕ          ; // Проверяем наличае следующего элемнета
            jz  .ДАЛЕЕ            ;
            mov  ecx,eax            ; // Запоминаем предыдущий  элемент в CX
            ;---------------------;
            call ЭЛЕ_СЛЕ          ; // Проверяем наличае следующего элемнета
            jz  .ВЫХОД            ;
            mov  edx,eax            ; // Запоминаем следующий элемент в DX
            ;---------------------;
            call ЭЛЕ_КОД          ; // Читаем адрес строки имени элемнта DI вовращает в AX
            call ПОИСК_AX_В_СТР_SI;
            jnz .ВЛОЖИТЬ          ;
            ;---------------------;
            jmp .ДАЛЕЕ            ;
            ;---------------------;
.ВЛОЖИТЬ:
            ;---------------------;
            push edi               ;
            call ДОБ_ЭЛЕ_СX_В_ЭЛЕ_DI; // Добавляем предыдущий элемент
            call ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI; // Добаавляем следующий элемнт
            mov  edi,edx            ;
            call ВЛО_МАТ          ;
            pop  edi                ;
            ;---------------------;
.ДАЛЕЕ:     call ЭЛЕ_СЛЕ          ;
            jmp .ЦИКЛ             ;
.ВЫХОД:
            popad;
            ret;
            END IF                ;}
;==============================================================================}
ВЛО_ПАР     :;{ Вложение параметров или блоков начинающихся с символа cx=(или фигурная скобка  summa(a,b)
IF  (ПЛАТФОРМА = ДОС)   ;{
            pushad;

            call ЭЛЕ_ВЛО          ; // Читаем первый вложеный элемнт
.ЦИКЛ:      ;---------------------;
            test ax,ax            ;
            jz  .ВЫХОД            ;
            mov  di,ax            ;
            ;---------------------;
            call ВЛО_ПАР          ;
            ;---------------------;
            call ЭЛЕ_СЛЕ          ; // Проверяем наличае следующего элемнета
            mov  dx,ax            ; // Запоминаем следующий элемент в DX
            test dx,dx            ; // Если нет Следующего элемнта то пропускаем
            jz  .ВЫХОД            ;
            ;---------------------;
            call ЭЛЕ_ТИП          ; // Во первых это дожэно быть слово
            cmp  ax,ТИП_СТРО      ;
            jnz .ДАЛЕЕ            ;
            call ЭЛЕ_КОД          ; // Во первых это дожэно быть слово
            cmp  ax,МАКС_РЕЗЕРВ_СЛОВО;
            jbE  .ДАЛЕЕ            ;
            ;----------------------;
            push di                ;
            mov  di,dx             ;
            call ЭЛЕ_КОД           ; // Читаем код следующего элемента
            cmp  ax,cx             ;
            pop  di                ;
            jnz .ДАЛЕЕ             ;
            ;----------------------;
            call ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI; // Добаавляем следующий элемнт
            cmp  ax,КОД_КОМ_НАЧАЛО ;  // Сравниваем первую букву вкладываемого элемента с началом блока
            jnz .ЭТО_НЕ_ФУН        ;

            call ЭЛЕ_КОД           ;
            mov  si,.УСЛОВИЕ_ЦИИКЛЫ;  // что бы не забыть qwe().asd().zxc():=cvb().sdf().cvb();
            call ПОИСК_AX_В_СТР_SI ;
            jnz  .ЭТО_НЕ_ФУН       ;

            mov  si,di             ;
            add  si,ЭЛ_ФУН         ;
            mov  byte[si],1        ;
.ЭТО_НЕ_ФУН:
            mov  ax,di             ;
            jmp .ЦИКЛ              ;

.ДАЛЕЕ:     ;----------------------;
            call ЭЛЕ_СЛЕ           ;
            ;----------------------;
            jmp .ЦИКЛ              ;
.КЦИКЛ:
.ВЫХОД:
            popad;
            ret;
.УСЛОВИЕ_ЦИИКЛЫ: DW КОД_КОМ_ЕСЛИ,КОД_КОМ_ПОКА,0;
            END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
            pushad;

            call ЭЛЕ_ВЛО          ; // Читаем первый вложеный элемнт
.ЦИКЛ:      ;---------------------;
            test ax,ax            ;
            jz  .ВЫХОД            ;
            mov  di,ax            ;
            ;---------------------;
            call ВЛО_ПАР          ;
            ;---------------------;
            call ЭЛЕ_СЛЕ          ; // Проверяем наличае следующего элемнета
            mov  dx,ax            ; // Запоминаем следующий элемент в DX
            test dx,dx            ; // Если нет Следующего элемнта то пропускаем
            jz  .ВЫХОД            ;
            ;---------------------;
            call ЭЛЕ_ТИП          ; // Во первых это дожэно быть слово
            cmp  ax,ТИП_СТРО      ;
            jnz .ДАЛЕЕ            ;
            call ЭЛЕ_КОД          ; // Во первых это дожэно быть слово
            cmp  ax,МАКС_РЕЗЕРВ_СЛОВО;
            jbE  .ДАЛЕЕ            ;
            ;----------------------;
            push di                ;
            mov  di,dx             ;
            call ЭЛЕ_КОД           ; // Читаем код следующего элемента
            cmp  ax,cx             ;
            pop  di                ;
            jnz .ДАЛЕЕ             ;
            ;----------------------;
            call ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI; // Добаавляем следующий элемнт
            cmp  ax,КОД_КОМ_НАЧАЛО ;  // Сравниваем первую букву вкладываемого элемента с началом блока
            jnz .ЭТО_НЕ_ФУН        ;

            call ЭЛЕ_КОД           ;
            mov  si,.УСЛОВИЕ_ЦИИКЛЫ;  // что бы не забыть qwe().asd().zxc():=cvb().sdf().cvb();
            call ПОИСК_AX_В_СТР_SI ;
            jnz  .ЭТО_НЕ_ФУН       ;

            mov  si,di             ;
            add  si,ЭЛ_ФУН         ;
            mov  byte[si],1        ;
.ЭТО_НЕ_ФУН:
            mov  ax,di             ;
            jmp .ЦИКЛ              ;

.ДАЛЕЕ:     ;----------------------;
            call ЭЛЕ_СЛЕ           ;
            ;----------------------;
            jmp .ЦИКЛ              ;
.КЦИКЛ:
.ВЫХОД:
            popad;
            ret;
.УСЛОВИЕ_ЦИИКЛЫ: DW КОД_КОМ_ЕСЛИ,КОД_КОМ_ПОКА,0;
            END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
            pushad;

            call ЭЛЕ_ВЛО          ; // Читаем первый вложеный элемнт
.ЦИКЛ:      ;---------------------;
            test eax,eax            ;
            jz  .ВЫХОД            ;
            mov  edi,eax            ;
            ;---------------------;
            call ВЛО_ПАР          ;
            ;---------------------;
            call ЭЛЕ_СЛЕ          ; // Проверяем наличае следующего элемнета
            mov  edx,eax            ; // Запоминаем следующий элемент в DX
            test edx,edx            ; // Если нет Следующего элемнта то пропускаем
            jz  .ВЫХОД            ;
            ;---------------------;
            call ЭЛЕ_ТИП          ; // Во первых это дожэно быть слово
            cmp  eax,ТИП_СТРО      ;
            jnz .ДАЛЕЕ            ;
            call ЭЛЕ_КОД          ; // Во первых это дожэно быть слово
            cmp  eax,МАКС_РЕЗЕРВ_СЛОВО;
            jbE  .ДАЛЕЕ            ;
            ;----------------------;
            push edi                ;
            mov  edi,edx             ;
            call ЭЛЕ_КОД           ; // Читаем код следующего элемента
            cmp  eax,ecx             ;
            pop  edi                ;
            jnz .ДАЛЕЕ             ;
            ;----------------------;
            call ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI; // Добаавляем следующий элемнт
            cmp  eax,КОД_КОМ_НАЧАЛО ;  // Сравниваем первую букву вкладываемого элемента с началом блока
            jnz .ЭТО_НЕ_ФУН        ;

            call ЭЛЕ_КОД           ;
            mov  esi,.УСЛОВИЕ_ЦИИКЛЫ;  // что бы не забыть qwe().asd().zxc():=cvb().sdf().cvb();
            call ПОИСК_AX_В_СТР_SI ;
            jnz  .ЭТО_НЕ_ФУН       ;

            mov  esi,edi             ;
            add  esi,ЭЛ_ФУН         ;
            mov  byte[esi],1        ;
.ЭТО_НЕ_ФУН:
            mov  eax,edi             ;
            jmp .ЦИКЛ              ;

.ДАЛЕЕ:     ;----------------------;
            call ЭЛЕ_СЛЕ           ;
            ;----------------------;
            jmp .ЦИКЛ              ;
.КЦИКЛ:
.ВЫХОД:
            popad;
            ret;
.УСЛОВИЕ_ЦИИКЛЫ: DW КОД_КОМ_ЕСЛИ,КОД_КОМ_ПОКА,0;
            END IF;}

;==============================================================================}
КОРРЕКЦИЯ   :;{ Корреекция cтруктуры
            pushad;
            ; Сдеась по идеи должна ыть какая то коррекция с готовой
            ; Структурой программы такм всякие шутковины
            ; Вобщем кагда сформирована структура
            ; Исполнительная тут можно чего нить наколдовать
            ; Например там скобки блоки ну вообщем подправлять
            ; Структуру ну или если не понятно может ошибки какие то
            ; Выводить предупредительные ))) вообщем на всякий случай
            popad ;
            ret   ;
;==============================================================================}
ВЫПОЛНИТЬ_ЭЛ:;{ Запускает элемнт на выполнение
IF  (ПЛАТФОРМА = ДОС)   ;{
             pushad            ;
             call ЭЛЕ_КОД      ;
             cmp  ax,МАКСВЛО   ;
             ja  .ФУНКЦИЯ      ;
             mov  dx,2         ;
             mul  dl           ;
             add  ax,ВЫПОЛНЕНИЕ;
             mov  si,ax        ;
             mov  cx,[si]      ;
             call ЗАПУСТИТЬ_CX ;
             jmp .ВЫХОД        ;
.ФУНКЦИЯ:    ;-----------------;
             Call ВЫПОЛНИТЬ_ФУ ;
             ;-----------------;
.ВЫХОД:
             popad ;
             ret   ;
             END IF            ;}
IF  (ПЛАТФОРМА = T16)   ;{
             pushad            ;
             call ЭЛЕ_КОД      ;
             cmp  ax,МАКСВЛО   ;
             ja  .ФУНКЦИЯ      ;
             mov  dx,2         ;
             mul  dl           ;
             add  ax,ВЫПОЛНЕНИЕ;
             mov  si,ax        ;
             mov  cx,[si]      ;
             call ЗАПУСТИТЬ_CX ;
             jmp .ВЫХОД        ;
.ФУНКЦИЯ:    ;-----------------;
             Call ВЫПОЛНИТЬ_ФУ ;
             ;-----------------;
.ВЫХОД:
             popad ;
             ret   ;
             END IF            ;}
IF  (ПЛАТФОРМА = T32)   ;{
             pushad            ;
             mov  ecx,0;       ;
             call ЭЛЕ_КОД      ;
             cmp  eax,МАКСВЛО  ;
             ja  .ФУНКЦИЯ      ;
             mov  edx,2        ;
             mul  dl           ;
             add  ax,ВЫПОЛНЕНИЕ;
             mov  esi,eax      ;
             mov  cx,[esi]     ;
             call ЗАПУСТИТЬ_CX ;
             jmp .ВЫХОД        ;
.ФУНКЦИЯ:    ;-----------------;
             Call ВЫПОЛНИТЬ_ФУ ;
             ;-----------------;
.ВЫХОД:
             popad ;
             ret   ;
             END IF            ;}

ВЫПОЛНЕНИЕ:
DW ВКОД_ТЕК_ПУСТО     ; 0
DW ВКОД_ТЕК_СЛОЖЕНИЕ  ; 1
DW ВКОД_ТЕК_ВЫЧИТАНИЕ ; 2
DW ВКОД_ТЕК_УМНОЖЕНИЕ ; 3
DW ВКОД_ТЕК_ДЕЛЕНИЕ   ; 4
DW ВКОД_ТЕК_ОСТАТОК   ; 5
DW ВКОД_ТЕК_ПРИСВОЕНИЕ; 6
DW ВКОД_ТЕК_РАВНО     ; 7
DW ВКОД_ТЕК_НЕРАВНО   ; 8
DW ВКОД_ТЕК_БОЛЬШЕ    ; 9
DW ВКОД_ТЕК_МЕНЬШЕ    ; 10
DW ВКОД_ТЕК_МЕНРА     ; 11
DW ВКОД_ТЕК_БОЛРА     ; 12
DW ВКОД_ТЕК_ЛОГИ      ; 13
DW ВКОД_ТЕК_ЛОГИЛИ    ; 14
DW ВКОД_ТЕК_ОСКОБ     ; 15
DW ВКОД_ТЕК_ЗСКОБ     ; 16
DW ВКОД_ТЕК_НАЧАЛО    ; 17
DW ВКОД_ТЕК_КОНЕЦ     ; 18

DW ВКОД_ТЕК_ЕСЛИ      ; 19
DW ВКОД_ТЕК_ПОКА      ; 20
DW ВКОД_ТЕК_ВЫВОД     ; 21
DW ВКОД_ТЕК_ВЫВОДСТ   ; 22
DW ВКОД_ТЕК_ЦИКЛ      ; 23
DW ВКОД_ТЕК_ВВОД      ; 24
DW ВКОД_ТЕК_ВВОДСТ    ; 25

DW ВКОД_ТЕК_ЧПОРТ     ; 26
DW ВКОД_ТЕК_ЧПАМЯТЬ   ; 27
DW ВКОД_ТЕК_ЗПОРТ     ; 28
DW ВКОД_ТЕК_ЗПАМЯТЬ   ; 29
DW ВКОД_ТЕК_ЗАПРОСИТЬ ; 30
DW ВКОД_ТЕК_ОСВОБОДИТЬ; 31
DW ВКОД_ТЕК_РОДИТЕЛЬ  ; 32

DW ВКОД_ТЕК_РЕЗЕРВ1   ; 33
DW ВКОД_ТЕК_РЕЗЕРВ2   ; 34
DW ВКОД_ТЕК_РЕЗЕРВ3   ; 35
DW ВКОД_ТЕК_РЕЗЕРВ4   ; 36
DW ВКОД_ТЕК_РЕЗЕРВ5   ; 37
DW ВКОД_ТЕК_РЕЗЕРВ6   ; 38
DW ВКОД_ТЕК_РЕЗЕРВ7   ; 39
DW ВКОД_ТЕК_РАЗРЕШИТЬ ; 40
DW ВКОД_ТЕК_ЗАПРЕТИТЬ ; 41

МАКСВЛО=41;
;==============================================================================}
ВЫПОЛНИТЬ_ВЛ:;{ Выполняет вложеные элемнты элемнета DI
IF  (ПЛАТФОРМА = ДОС)   ;{
            pushad;
            call ЭЛЕ_ВЛО     ;
            jz  .ВЫХОД       ;
.ЦИКЛ:      ;----------------;
            test ax,ax       ;
            jz  .КЦИКЛ       ;
            mov  di,ax       ;
            call ЭЛЕ_ФУН     ;
            jnz .ДАЛЕЕ       ;
            call ВЫПОЛНИТЬ_ЭЛ;
.ДАЛЕЕ:     call ЭЛЕ_СЛЕ     ;
            Jmp .ЦИКЛ        ;
.КЦИКЛ:     ;----------------;
.ВЫХОД:
            popad;
            ret;
            END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
            pushad;
            call ЭЛЕ_ВЛО     ;
            jz  .ВЫХОД       ;
.ЦИКЛ:      ;----------------;
            test ax,ax       ;
            jz  .КЦИКЛ       ;
            mov  di,ax       ;
            call ЭЛЕ_ФУН     ;
            jnz .ДАЛЕЕ       ;
            call ВЫПОЛНИТЬ_ЭЛ;
.ДАЛЕЕ:     call ЭЛЕ_СЛЕ     ;
            Jmp .ЦИКЛ        ;
.КЦИКЛ:     ;----------------;
.ВЫХОД:
            popad;
            ret;
            END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
            pushad;
            call ЭЛЕ_ВЛО     ;
            jz  .ВЫХОД       ;
.ЦИКЛ:      ;----------------;
            test eax,eax     ;
            jz  .КЦИКЛ       ;
            mov  edi,eax     ;
            call ЭЛЕ_ФУН     ;
            jnz .ДАЛЕЕ       ;
            call ВЫПОЛНИТЬ_ЭЛ;
.ДАЛЕЕ:     call ЭЛЕ_СЛЕ     ;
            Jmp .ЦИКЛ        ;
.КЦИКЛ:     ;----------------;
.ВЫХОД:
            popad;
            ret;
            END IF;}
;==============================================================================}
ВЫПОЛНИТЬ_ПР:;{ Запускает ПРОЦЕС с элементом  DI
            pushad;
            call ВЫПОЛНИТЬ_ВЛ; // Вот тут не правельно работает
            call ЭЛЕ_ОСВОБОДИ; // Ладно не важно щас нереально в этом разобраться буду просто оптимизировать код
            popad;
            ret;
;==============================================================================}
ВЫПОЛНИТЬ_ОК:;{ Выполняет программу в окне DI
             ;{ ОПИСАНИЕ
             ;
             ;
             ;
             ;}
IF  (ПЛАТФОРМА = ДОС)   ;{
            pushad;
            ;----------------------------------------------
            call ОКНО_ТЕК;
            call РАЗ_НА_СЛОВА       ; // Разбивка текста окна на слова
            call ДОП_ТИП_СЛОВ       ; // Дополнительные типы
            mov  SI, КОД_КОМ_ОСКОБКА;
            call ВЛО_СКО            ; // Вложене скобок
            mov  cx,КОД_КОМ_ОСКОБКА ;
            Call ВЛО_ПАР            ; // Вложение параметров
            mov  SI,КОД_КОМ_НАЧАЛО
            call ВЛО_СКО            ; // Вложене скобок
            mov  si,.УМНОЖДЕЛЕ      ;
            call ВЛО_МАТ            ; // Вложение математических операций
            mov  si,.ПЛЮСМИНУС      ;
            call ВЛО_МАТ            ; // Вложение математических операций
            mov  si,.ЛОГИЧОПЕР      ;
            call ВЛО_МАТ            ; // Вложение математических операций
            mov  si,.ПРИСВАИВА      ;
            call ВЛО_МАТ            ; // Вложение математических операций
            mov  cx,КОД_КОМ_НАЧАЛО  ; //
            Call ВЛО_ПАР            ; // Вложение параметров
            ;----------------------------------------------
            mov   ax,ВЫПОЛНИТЬ_ПР ;// Сдесь указываем процес
            call  ДОБАВИТЬ_ПРОЦЕС ;// Функцию котрую нужно запустить
            popad;
            ret;
            END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
            pushad;

            ;----------------------------------------------
            call РАЗ_НА_СЛОВА       ; // Разбивка текста окна на слова

            call ДОП_ТИП_СЛОВ       ; // Дополнительные типы
            mov  SI, КОД_КОМ_ОСКОБКА;
            call ВЛО_СКО            ; // Вложене скобок
            mov  SI,КОД_КОМ_НАЧАЛО
            call ВЛО_СКО            ; // Вложене скобок
            mov  si,.УМНОЖДЕЛЕ      ;
            call ВЛО_МАТ            ; // Вложение математических операций
            mov  si,.ПЛЮСМИНУС      ;
            call ВЛО_МАТ            ; // Вложение математических операций
            mov  si,.ЛОГИЧОПЕР      ;
            call ВЛО_МАТ            ; // Вложение математических операций
            mov  si,.ПРИСВАИВА      ;
            call ВЛО_МАТ            ; // Вложение математических операций
            mov  cx,КОД_КОМ_ОСКОБКА ;
            Call ВЛО_ПАР            ; // Вложение параметров
            mov  cx,КОД_КОМ_НАЧАЛО  ; //
            Call ВЛО_ПАР            ; // Вложение параметров
            ;----------------------------------------------

            ;call ВЫПОЛНИТЬ_ВЛ; // Вот тут не правельно работает
            ;call ЭЛЕ_ОСВОБОДИ; // Ладно не важно щас нереально в этом разобраться буду просто оптимизировать код

            mov   ax,ВЫПОЛНИТЬ_ПР ;// Сдесь указываем процес
            call  ДОБАВИТЬ_ПРОЦЕС ;// Функцию котрую нужно запустить
            ;mov   [МОНИТОР_ОБЬЕКТ],DI;
            ;mov    di,[КОР_ЭЛЕМ];
            ;mov   [МОНИТОР_ОБЬЕКТ],DI;


            popad;
            ret;
            END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
            pushad;
            ;----------------------------------------------
            call ОКНО_ТЕК;
            call РАЗ_НА_СЛОВА       ; // Разбивка текста окна на слова
            call ДОП_ТИП_СЛОВ       ; // Дополнительные типы
            mov  ESI, КОД_КОМ_ОСКОБКА;
            call ВЛО_СКО            ; // Вложене скобок
            mov  ecx,КОД_КОМ_ОСКОБКА ;
            Call ВЛО_ПАР            ; // Вложение параметров
            mov  eSI,КОД_КОМ_НАЧАЛО
            call ВЛО_СКО            ; // Вложене скобок
            mov  esi,.УМНОЖДЕЛЕ      ;
            call ВЛО_МАТ            ; // Вложение математических операций
            mov  esi,.ПЛЮСМИНУС      ;
            call ВЛО_МАТ            ; // Вложение математических операций
            mov  esi,.ЛОГИЧОПЕР      ;
            call ВЛО_МАТ            ; // Вложение математических операций
            mov  esi,.ПРИСВАИВА      ;
            call ВЛО_МАТ            ; // Вложение математических операций
            mov  ecx,КОД_КОМ_НАЧАЛО  ; //
            Call ВЛО_ПАР            ; // Вложение параметров
            ;----------------------------------------------
            mov   eax,ВЫПОЛНИТЬ_ПР ;// Сдесь указываем процес
            call  ДОБАВИТЬ_ПРОЦЕС  ;// Функцию котрую нужно запустить
            popad;
            ret;

            END IF;}

.ПЛЮСМИНУС: DW КОД_КОМ_СЛОЖЕНИЕ,КОД_КОМ_ВЫЧИТАНИЕ,0;
.УМНОЖДЕЛЕ: DW КОД_КОМ_УМНОЖЕНИЕ,КОД_КОМ_ДЕЛЕНИЕ,0;
.ЛОГИЧОПЕР: DW КОД_КОМ_БОЛЬШЕ,КОД_КОМ_МЕНЬШЕ,КОД_КОМ_РАВНО,КОД_КОМ_НЕРАВНО,КОД_КОМ_МЕНРА,КОД_КОМ_БОЛРА,0;
.ПРИСВАИВА: DW КОД_КОМ_ПРИСВОЕНИЕ,0;



ЭЛЕ_ПРОСМОТР:;{ Просмотр элемента и его характеристик DI
        pushad                  ;
        ;-----------------------;
        mov cx,DI               ;// Запоминаем адрес просматриваемого элемента       ;
        ;-----------------------;


        ;-----------------------;// Печатаем пробелы равное количесвту элемнтов предков
        mov SI,Di               ;// Печать отступов в количестве предков сколько предков стока и отступов
        ADD SI,ЭЛ_РОД           ;
        mov ax,[si]             ;
.ЦИКЛ:                          ;
        test ax,ax              ;
        jz  .КЦИКЛ              ;
                                ;
        call ЭКРАН_ВЫВОД_ПРОБЕЛА;
        mov si,ax               ;
        add si,ЭЛ_РОД           ;
        mov ax,[si]             ;
        jmp .ЦИКЛ               ;
.КЦИКЛ: ;-----------------------;

        ;-----------------------;
        MOV  DI,.ТЕКСТ_АДР_ЭЛ   ;// Печать надписи (адреса элемента)
        call ЭКРАН_ВЫВОД_СТРОКИ ;
        mov  si,cx              ;
        mov  ax,si              ;
        call ЭКРАН_ВЫВОД_ЧИСЛА  ;// печать адреса расположения элемента
        call ЭКРАН_ВЫВОД_ПРОБЕЛА;// Пробел разделитель что бы не слипалися надпси
        ;-----------------------;

        ;-----------------------;
        MOV  DI,.ТЕКСТ_ТИП_ЭЛ   ;// Печать надпсии (ТИП ЭЛЕМЕНТА)
        Call ЭКРАН_ВЫВОД_СТРОКИ ;
        mov  DI,CX              ;
        Call ЭЛЕ_ТИП            ;
        call ЭКРАН_ВЫВОД_ЧИСЛА  ;// Печать самого типа ввиде числа типы описаны в разделе типы элементов
        call ЭКРАН_ВЫВОД_ПРОБЕЛА;
        ;-----------------------;


        ;-----------------------;
        MOV  DI,.ТЕКСТ_ФУН_ЭЛ   ;// Печать слова (Являеться ли функцией)
        call ЭКРАН_ВЫВОД_СТРОКИ ;
        mov  DI,CX              ;
        Call ЭЛЕ_ФУН            ;
        call ЭКРАН_ВЫВОД_ЧИСЛА  ;// Вывод являеться ли функцией в виде числа если 1 то являеться
        call ЭКРАН_ВЫВОД_ПРОБЕЛА;
        ;-----------------------;


        ;-----------------------;
        MOV  DI,.ТЕКСТ_КОД_ЭЛ   ;// Печать надпсии кода элемента каждому слову сосотвествет код из словаря
        call ЭКРАН_ВЫВОД_СТРОКИ ;// Коды предназначены для быстрого поиска нужных элементов
        mov  DI,CX              ;
        Call ЭЛЕ_КОД            ;
        call ЭКРАН_ВЫВОД_ЧИСЛА  ;
        call ЭКРАН_ВЫВОД_ПРОБЕЛА;
        ;-----------------------;


        ;------------------------;
        ;MOV  DI,.ТЕКСТ_РОД_ЭЛ   ;//  Печать адреса родительского элемента
        ;call ЭКРАН_ВЫВОД_СТРОКИ ;
        ;mov  DI,CX              ;
        ;Call ЭЛЕ_РОД            ;
        ;call ЭКРАН_ВЫВОД_ЧИСЛА  ;
        ;call ЭКРАН_ВЫВОД_ПРОБЕЛА;
        ;------------------------;

        ;------------------------;
        ;MOV  DI,.ТЕКСТ_ПРЕ_ЭЛ   ;// Печать адреса Предудыдущего элемента
        ;call ЭКРАН_ВЫВОД_СТРОКИ ;
        ;mov  DI,CX              ;
        ;Call ЭЛЕ_ПРЕ            ;
        ;call ЭКРАН_ВЫВОД_ЧИСЛА  ;
        ;call ЭКРАН_ВЫВОД_ПРОБЕЛА;
        ;------------------------;

        ;------------------------;
        ;MOV  DI,.ТЕКСТ_СЛЕ_ЭЛ   ;// Печать адреса следующего элемента
        ;call ЭКРАН_ВЫВОД_СТРОКИ ;
        ;mov  DI,CX              ;
        ;Call ЭЛЕ_СЛЕ            ;
        ;call ЭКРАН_ВЫВОД_ЧИСЛА  ;
        ;call ЭКРАН_ВЫВОД_ПРОБЕЛА;
        ;------------------------;


        ;------------------------;
        ;MOV  DI,.ТЕКСТ_ВЛО_ЭЛ   ;// Печать адреса Первго вложеного эелемента
        ;call ЭКРАН_ВЫВОД_СТРОКИ ;
        ;mov  DI,CX              ;
        ;Call ЭЛЕ_ВЛО            ;
        ;call ЭКРАН_ВЫВОД_ЧИСЛА  ;
        ;call ЭКРАН_ВЫВОД_ПРОБЕЛА;
        ;------------------------;



        ;------------------------;
        ;MOV  DI,.ТЕКСТ_ИМЯ_ЭЛ    ;// Печать Имени  элемента
        ;call ЭКРАН_ВЫВОД_СТРОКИ  ;
        ;mov  di,cx               ;
        ;call ЭЛЕ_ИМЯ             ;
        ;mov  di,ax               ;
        ;call ЭКРАН_ВЫВОД_СТРОКИ  ;
        ;call ЭКРАН_ВЫВОД_ПРОБЕЛА ;
        ;------------------------;




        ;------------------------;
        MOV  DI,.ТЕКСТ_ЗНА_ЭЛ    ;// Печать Значеия элемента
        call ЭКРАН_ВЫВОД_СТРОКИ  ;// Вывод значения зависитт от типа элемента

        mov  di,cx               ;
        call ЭЛЕ_ТИП             ;
        cmp  al,ТИП_СТРО         ;// Если тип элемента строка то вывод как строки
        jz  .ВСТРО               ;
        cmp  al,ТИП_ЧИСЛ         ;// Если элемент число то вывод как число .... и атк далее в дальнейшем буду отписаны и другие типы эелемнтов
        jz  .ВЧИСЛ               ;

        ;------------------------;
        mov  di,.ТЕК_НЕИЗВЕСТНО  ;// Если такой тип не известен то выводиться надпист что тип элемента не известен
        call ЭКРАН_ВЫВОД_СТРОКИ  ;
        call ЭКРАН_ВЫВОД_ПРОБЕЛА ;
        jmp .НЕИЗВЕСТНО          ;
        ;------------------------;
.ВЧИСЛ:
        ;------------------------;
        mov  di,cx               ;
        call ЭЛЕ_ЗНА             ;
        call ЭКРАН_ВЫВОД_ЧИСЛА   ;
        call ЭКРАН_ВЫВОД_ПРОБЕЛА ;
        jmp .НЕИЗВЕСТНО          ;
        ;------------------------;
.ВСТРО:
        ;------------------------;
        mov  di,cx               ;
        call ЭЛЕ_ЗНА             ;
        mov  di,ax                ;
        call ЭКРАН_ВЫВОД_СТРОКИ  ;
        call ЭКРАН_ВЫВОД_ПРОБЕЛА ;
        ;------------------------;
        .НЕИЗВЕСТНО:             ;// Тут завершение вывода знчения почему называеться неизвестно не помню ))) поф



        ;-----------------------;
        mov  di,cx              ;// Востанавливаем адрес просматриваемого элемента
        Call ЭЛЕ_ПРОС_ВЛО       ;// ПРосмотр Вложеных Элементов
        ;-----------------------;

.ВЫХОД:
        popad;
        ret;

.ТЕКСТ_АДР_ЭЛ: db  "АДР=",0,0;
.ТЕКСТ_ТИП_ЭЛ: db  "ТИП=",0,0;
.ТЕКСТ_ФУН_ЭЛ: db  "ФУН=",0,0;
.ТЕКСТ_РОД_ЭЛ: db  "РОД=",0,0;
.ТЕКСТ_ПРЕ_ЭЛ: db  "ПРЕ=",0,0;
.ТЕКСТ_СЛЕ_ЭЛ: db  "СЛЕ=",0,0;
.ТЕКСТ_ВЛО_ЭЛ: db  "ВЛО=",0,0;
.ТЕКСТ_ИМЯ_ЭЛ: db  "ИМЯ=",0,0;
.ТЕКСТ_ЗНА_ЭЛ: db  "ЗНА=",0,0;
.ТЕКСТ_КОД_ЭЛ: db  "КОД=",0,0;

.ТЕК_НЕИЗВЕСТНО: db "НЕИЗВЕСТНО",0,0;
;==============================================================================}
ЭЛЕ_ПРОС_ВЛО:;{ ПРосмотр  волженых элементов DI используеться функцией ЭЛЕ_ПРОСМОТР
        pushad;

        call ЭЛЕ_ВЛО;
.ЦИКЛ:  ;-----------------------;
        test ax,ax              ;// ПРоверяем наличае певого вложеного элемента
        JZ  .ВЫХОД              ;
        call ЭКРАН_ВЫВОД_ПЕРСТРО;
        mov  di,ax              ;
        call ЭЛЕ_ПРОСМОТР       ;
        call ЭЛЕ_СЛЕ            ;
        jmp .ЦИКЛ               ;
        ;-----------------------;
.ВЫХОД:
        popad;
        ret;
;==============================================================================}

;==============================================================================}
ВЫПОЛНИТЬ_ФУ:;{ Выполняет ФУНКЦИЮ
IF  (ПЛАТФОРМА = ДОС)   ;{
                    pushad;
                    mov  dx,di            ; // Сохраняем адрес выполняемого элмента
                    call ЭЛЕ_КОД          ; // Читаем его имя
                    mov  cx,ax            ;
                    call ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI        ; // Производим поиск элемнета (функция процедура или параметр )
                    jz  .ВЫХОД;
                    call ЭЛЕ_КОПИЯ_ВС     ; // Создаем экземпляр функции
                    call ЭЛЕ_КОПИЯ_ПА     ; // Копируем параметры
                    mov  bx,DI            ; // Запоминаем адрес выполненгого экземплярпа функции


                    pushad;
                    mov  di,dx;
                    mov  dx,bx;
                    call ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI;
                    popad;

                    call ЭЛЕ_ВЛО;
                    jz  .ДАЛЕЕ;
                    mov  di,ax;
                    call ЭЛЕ_СЛЕ;
                    jz  .ДАЛЕЕ;
                    mov  di,ax;
                    call ВЫПОЛНИТЬ_ЭЛ     ; // Выполняем


.ДАЛЕЕ:
                    call ПРИСВОИТЬ_ЗНА_В_ЭЛЕ_DX_ИЗ_ЭЛЕ_BX;
                    mov  di,bx
                    call ЭЛЕ_ОСВОБОДИ     ;
.ВЫХОД:
                    popad;
                    ret;
                    END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                    pushad;

                    mov  dx,di            ; // Сохраняем адрес выполняемого элмента
                    call ЭЛЕ_КОД          ; // Читаем его имя
                    mov  cx,ax            ;
                    call ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI        ; // Производим поиск элемнета (функция процедура или параметр )
                    jz  .ВЫХОД;
                    call ЭЛЕ_КОПИЯ_ВС     ; // Создаем экземпляр функции
                    call ЭЛЕ_КОПИЯ_ПА     ; // Копируем параметры
                    mov  bx,DI            ; // Запоминаем адрес выполненгого экземплярпа функции


                    pushad;
                    mov  di,dx;
                    mov  dx,bx;
                    call ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI;
                    popad;

                    call ЭЛЕ_ВЛО;
                    jz  .ДАЛЕЕ;
                    mov  di,ax;
                    call ЭЛЕ_СЛЕ;
                    jz  .ДАЛЕЕ;
                    mov  di,ax;
                    call ВЫПОЛНИТЬ_ЭЛ     ; // Выполняем


.ДАЛЕЕ:
                    call ПРИСВОИТЬ_ЗНА_В_ЭЛЕ_DX_ИЗ_ЭЛЕ_BX;
                    mov  di,bx
                    call ЭЛЕ_ОСВОБОДИ     ;
.ВЫХОД:
                    popad;
                    ret;
                    END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                    pushad;

                    mov  edx,edi            ; // Сохраняем адрес выполняемого элмента
                    call ЭЛЕ_КОД          ; // Читаем его имя
                    mov  ecx,eax            ;
                    call ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI        ; // Производим поиск элемнета (функция процедура или параметр )
                    jz  .ВЫХОД;
                    call ЭЛЕ_КОПИЯ_ВС     ; // Создаем экземпляр функции
                    call ЭЛЕ_КОПИЯ_ПА     ; // Копируем параметры
                    mov  ebx,eDI            ; // Запоминаем адрес выполненгого экземплярпа функции


                    pushad;
                    mov  edi,edx;
                    mov  edx,ebx;
                    call ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI;
                    popad;

                    call ЭЛЕ_ВЛО;
                    jz  .ДАЛЕЕ;
                    mov  edi,eax;
                    call ЭЛЕ_СЛЕ;
                    jz  .ДАЛЕЕ;
                    mov  edi,eax;
                    call ВЫПОЛНИТЬ_ЭЛ     ; // Выполняем


.ДАЛЕЕ:
                    call ПРИСВОИТЬ_ЗНА_В_ЭЛЕ_DX_ИЗ_ЭЛЕ_BX;
                    mov  edi,ebx
                    call ЭЛЕ_ОСВОБОДИ     ;
.ВЫХОД:
                    popad;
                    ret;
                    END IF;}

;==============================================================================}

ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI:;{ если он есть
IF  (ПЛАТФОРМА = ДОС)   ;{
                        ;{ ОПИСАНИЕ
                        ; Выполняет первый вложеный элемент в элемнете
                        ; тут кое что не предусмотрено
                        ; если вложеного элемента нет то выход
                        ; Так какие еще утт могут быть загвоздки хмм......
                        ; Кажеться больше никаких
                        ;}
           pushad           ; Записывает в AX адрес первого вложеного элемента
           call ЭЛЕ_ВЛО     ; В конце функции ЭЛЕ_ВЛО test ax,ax прописано !
           JZ  .ВЫХОД       ; Если влженого элемента нет тогда выход
           mov  di,ax       ;
           call ВЫПОЛНИТЬ_ЭЛ;
.ВЫХОД:
           popad            ;
           ret              ;
           END IF;----------}
IF  (ПЛАТФОРМА = T16)   ;{
                        ;{ ОПИСАНИЕ
                        ; Выполняет первый вложеный элемент в элемнете
                        ; тут кое что не предусмотрено
                        ; если вложеного элемента нет то выход
                        ; Так какие еще утт могут быть загвоздки хмм......
                        ; Кажеться больше никаких
                        ;}
           pushad           ; Записывает в AX адрес первого вложеного элемента
           call ЭЛЕ_ВЛО     ; В конце функции ЭЛЕ_ВЛО test ax,ax прописано !
           JZ  .ВЫХОД       ; Если влженого элемента нет тогда выход
           mov  di,ax       ;
           call ВЫПОЛНИТЬ_ЭЛ;
.ВЫХОД:
           popad            ;
           ret              ;
           END IF;----------}
IF  (ПЛАТФОРМА = T32)   ;{
                        ;{ ОПИСАНИЕ
                        ; Выполняет первый вложеный элемент в элемнете
                        ; тут кое что не предусмотрено
                        ; если вложеного элемента нет то выход
                        ; Так какие еще утт могут быть загвоздки хмм......
                        ; Кажеться больше никаких
                        ;}
           pushad           ; Записывает в eAX адрес первого вложеного элемента
           call ЭЛЕ_ВЛО     ; В конце функции ЭЛЕ_ВЛО test eax,eax прописано !
           JZ  .ВЫХОД       ; Если влженого элемента нет тогда выход
           mov  edi,eax     ;
           call ВЫПОЛНИТЬ_ЭЛ;
.ВЫХОД:
           popad            ;
           ret              ;
           END IF;----------}
;==============================================================================}
ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI:;{ если он есть
IF  (ПЛАТФОРМА = ДОС)   ;{
                        ;{ ОПИСАНИЕ
                        ;  Это выполнение второго вложеного элемента DI если он есть
                        ; По хорошему бы тут отмечать сразу места где нада будет
                        ; лофить разные ошибочки и выводить о них сообщения
                        ;}
           pushad;-----------
           call ЭЛЕ_ВЛО     ;
           jz  .ВЫХОД       ; // Вывод сообщения
           mov  di,ax       ;
           call ЭЛЕ_СЛЕ     ;
           Jz  .ВЫХОД       ; // А пкоа просто пропишу выход да и все
           mov  di,ax       ; // Вывод сообщения
           call ВЫПОЛНИТЬ_ЭЛ;
.ВЫХОД:
           popad            ;
           ret              ;
           END IF;----------}
IF  (ПЛАТФОРМА = T16)   ;{
                        ;{ ОПИСАНИЕ
                        ;  Это выполнение второго вложеного элемента DI если он есть
                        ; По хорошему бы тут отмечать сразу места где нада будет
                        ; лофить разные ошибочки и выводить о них сообщения
                        ;}
           pushad;-----------
           call ЭЛЕ_ВЛО     ;
           jz  .ВЫХОД       ; // Вывод сообщения
           mov  di,ax       ;
           call ЭЛЕ_СЛЕ     ;
           Jz  .ВЫХОД       ; // А пкоа просто пропишу выход да и все
           mov  di,ax       ; // Вывод сообщения
           call ВЫПОЛНИТЬ_ЭЛ;
.ВЫХОД:
           popad            ;
           ret              ;
           END IF;----------}
IF  (ПЛАТФОРМА = T32)   ;{
                        ;{ ОПИСАНИЕ
                        ;  Это выполнение второго вложеного элемента DI если он есть
                        ; По хорошему бы тут отмечать сразу места где нада будет
                        ; лофить разные ошибочки и выводить о них сообщения
                        ;}
           pushad;-----------
           call ЭЛЕ_ВЛО     ;
           jz  .ВЫХОД       ; // Вывод сообщения
           mov  edi,eax     ; // А вот тут где нить забудеш так ка нить
           call ЭЛЕ_СЛЕ     ; // Буковку поменять а потом полдня искать ошибку )))))))
           Jz  .ВЫХОД       ; // А пкоа просто пропишу выход да и все
           mov  edi,eax     ; // Вывод сообщения
           call ВЫПОЛНИТЬ_ЭЛ; // ШУЧЮ
.ВЫХОД:
           popad            ;
           ret              ;
           END IF;----------}
;==============================================================================}

ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_AX:;{ Если он Есть
IF  (ПЛАТФОРМА = ДОС)   ;{
           push di     ;
           call ЭЛЕ_ВЛО;
           jz  .ВЫХОД  ;  // Вывод сообщения
           mov  di,ax  ;
           call ЭЛЕ_ЗНА;
.ВЫХОД:
           pop  di     ;
           ret         ;
           END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
           push di     ;
           call ЭЛЕ_ВЛО;
           jz  .ВЫХОД  ;
           mov  di,ax  ;
           call ЭЛЕ_ЗНА;
.ВЫХОД:
           pop  di     ;
           ret         ;
           END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
           push edi     ;
           call ЭЛЕ_ВЛО ;
           jz  .ВЫХОД   ;
           mov  edi,eax ;
           call ЭЛЕ_ЗНА ;
.ВЫХОД:
           pop  edi     ;
           ret          ;
           END IF;}
;==============================================================================}
ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_DX:;{ Записывает в решистр Ax значение  первого вложеного элемента
IF  (ПЛАТФОРМА = ДОС)   ;{
           push ax;
           call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_AX;
           mov  dx,ax;
           pop  ax;
           ret;
           END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
           push ax;
           call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_AX;
           mov  dx,ax;
           pop  ax;
           ret;
           END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
           push eax;
           call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_AX;
           mov  edx,eax;
           pop  eax;
           ret;
           END IF;}
;==============================================================================}
ЗНАЧЕНИЕ_ВТОРОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_AX:;{ Записывает в решистр Ax значение  Второго вложеного элемента
IF  (ПЛАТФОРМА = ДОС)   ;{
           push di;
           call ЭЛЕ_ВЛО;
           Jz  .ВЫХОД  ; // Вывод сообщения
           mov  di,ax  ;
           call ЭЛЕ_СЛЕ; // Спомощю надписи // Вывод сообщения можно будет быстро найти все места где нада буит прописать вывод диогнастических сообенйи
           Jz  .ВЫХОД  ; // Вывод сообщения
           mov  di,ax  ;
           call ЭЛЕ_ЗНА;
.ВЫХОД:
           pop  di;
           ret;
           END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
           push di;
           call ЭЛЕ_ВЛО;
           Jz  .ВЫХОД  ; // Вывод сообщения
           mov  di,ax  ;
           call ЭЛЕ_СЛЕ; // Спомощю надписи // Вывод сообщения можно будет быстро найти все места где нада буит прописать вывод диогнастических сообенйи
           Jz  .ВЫХОД  ; // Вывод сообщения
           mov  di,ax  ;
           call ЭЛЕ_ЗНА;
.ВЫХОД:
           pop  di;
           ret;
           END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
           push edi     ;
           call ЭЛЕ_ВЛО ; // Чтение адреса первого вложеного элемента в элемент DI
           Jz  .ВЫХОД   ; // Вывод сообщения
           mov  edi,eax ; // Ну а тут запись в Di адреса след элемента
           call ЭЛЕ_СЛЕ ; // Ну тут надеюся понятно что это чтение с Элемента DI Адр След ЭЛ
           Jz  .ВЫХОД   ; // Вывод сообщения
           mov  edi,eax ;
           call ЭЛЕ_ЗНА ; // Чтение значение элемента Di
.ВЫХОД:
           pop  edi     ; // Все очень просто следующий предыдущий Значение
           ret;
           END IF;}
;==============================================================================}
ЗНАЧЕНИЕ_ВТОРОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_DX:;{ Записывает в решистр Dx значение  второго вложеного элемента
IF  (ПЛАТФОРМА = ДОС)   ;{
           push eax;
           call ЗНАЧЕНИЕ_ВТОРОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_AX
           mov  edx,eax; Тут просотт перенаправление на пред функцию
           pop  eax;
           ret;
           END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
           push eax;
           call ЗНАЧЕНИЕ_ВТОРОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_AX
           mov  edx,eax;
           pop  eax;
           ret;
           END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
           push eax;
           call ЗНАЧЕНИЕ_ВТОРОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_AX
           mov  edx,eax;
           pop  eax;
           ret;
           END IF;}
;==============================================================================}

ТИП_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА:;{ Записывает в решистр Ax тип вложеного элемента
IF  (ПЛАТФОРМА = ДОС)   ;{
           push di;
           call ЭЛЕ_ВЛО;
           JZ  .ВЫХОД  ; // Вывод сообщения
           mov  di,ax  ;
           call ЭЛЕ_ТИП; // Чтение типа элемента Строка число и тд и тп
.ВЫХОД:
           pop  di;
           ret;
           END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
           push di;
           call ЭЛЕ_ВЛО;
           JZ  .ВЫХОД  ; // Вывод сообщения
           mov  di,ax  ;
           call ЭЛЕ_ТИП; // Чтение типа элемента Строка число и тд и тп
.ВЫХОД:
           pop  di;
           ret;
           END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
           push edi;
           call ЭЛЕ_ВЛО;
           JZ  .ВЫХОД  ; // Вывод сообщения
           mov  edi,eax;
           call ЭЛЕ_ТИП; // Чтение типа элемента Строка число и тд и тп
.ВЫХОД:
           pop  edi;
           ret;
           END IF;}
;==============================================================================}
ТИП_ВТОРОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА:;{ Записывает в решистр Ax тип следующего вложеного элемента
IF  (ПЛАТФОРМА = ДОС)   ;{
           push di      ;
           call ЭЛЕ_ВЛО ;
           JZ  .ВЫХОД   ; // Вывод сообщения
           mov  di,ax   ;
           call ЭЛЕ_СЛЕ ;
           jz  .ВЫХОД   ; // Вывод сообщения
           mov  di,ax   ;
           call ЭЛЕ_ТИП ;
.ВЫХОД:
           pop  di;
           ret;
           END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
           push di      ;
           call ЭЛЕ_ВЛО ;
           JZ  .ВЫХОД   ; // Вывод сообщения
           mov  di,ax   ;
           call ЭЛЕ_СЛЕ ;
           jz  .ВЫХОД   ; // Вывод сообщения
           mov  di,ax   ;
           call ЭЛЕ_ТИП ;
.ВЫХОД:
           pop  di;
           ret;
           END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
           push edi      ;
           call ЭЛЕ_ВЛО ;
           JZ  .ВЫХОД   ; // Вывод сообщения
           mov  edi,eax ;
           call ЭЛЕ_СЛЕ ;
           jz  .ВЫХОД   ; // Вывод сообщения
           mov  edi,eax ;
           call ЭЛЕ_ТИП ;
.ВЫХОД:
           pop  edi;
           ret;
           END IF;}
;==============================================================================}

ЗАПИСАТЬ_ЗНАЧЕНИЕ_AX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
pushad;
mov  dx,ax;
call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО
popad;
ret;
END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
pushad;
mov  dx,ax;
call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО
popad;
ret;
END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
pushad;
mov  edx,eax;
call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО
popad;
ret;
END IF;}
;}
ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО :;{ Записывает значение DX как число в Элемент DI Изменяя тип если нада
IF  (ПЛАТФОРМА = ДОС)   ;{
                        ;{ ОПИСАНИЕ
                        ;  Записывает DX как значение в элемент Di
                        ;  DX обычное число
                        ;  То есть устанавливает тип число у эелемнта
                        ;  Если элемнт был строкой то усвобождает сроку что бы
                        ;  Память не занимала
                        ;}
        pushad;                        ; тут нада передалть
        call ЭЛЕ_ТИП_ЧИСЛО ; // Определяет тип элемента что бы освободить
        JNZ .ЧИСЛО         ; // СТроку если элемнт был строкой ; // Если элемент и был числом то просто запишем значение
        call ЭЛЕ_ТИП_СТРОКА; // Если элемент строка то нада освободить сперва строку
        JNZ .СТРОКА        ; // и поменять тип   элемента
        JMP .ВЫХОД         ; // Если тип элемнта неизвестен то пропускаем ничего не записываем
        ;------------------;
.ЧИСЛО: add  DI,ЭЛ_ЗНА     ; // ПРсто записывем число нвоое
        mov [DI],DX        ;
        JMP .ВЫХОД         ;
        ;------------------;
.СТРОКА:
        Call ЭЛЕ_ЗНА       ; // Читаем адрес значения
        call УДАЛИТЬ_СТРОКУ_AX; // Освобождаю строку
        MOV  SI,DI         ;
        add  SI,ЭЛ_ЗНА     ;
        mov [SI],DX        ; // Запись новго значения
        MOV  SI,DI         ;
        add  SI,ЭЛ_ТИП     ;
        mov Byte [SI],ТИП_ЧИСЛ; // Запись нового  типа элемента
        JMP .ВЫХОД         ;
        ;------------------;
.ВЫХОД:
        popad ;
        ret   ;
        END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                        ;{ ОПИСАНИЕ
                        ;  Записывает DX как значение в элемент Di
                        ;  DX обычное число
                        ;  То есть устанавливает тип число у эелемнта
                        ;  Если элемнт был строкой то усвобождает сроку что бы
                        ;  Память не занимала
                        ;}
        pushad;                        ; тут нада передалть
        call ЭЛЕ_ТИП_ЧИСЛО ; // Определяет тип элемента что бы освободить
        JNZ .ЧИСЛО         ; // СТроку если элемнт был строкой ; // Если элемент и был числом то просто запишем значение
        call ЭЛЕ_ТИП_СТРОКА; // Если элемент строка то нада освободить сперва строку
        JNZ .СТРОКА        ; // и поменять тип   элемента
        JMP .ВЫХОД         ; // Если тип элемнта неизвестен то пропускаем ничего не записываем
        ;------------------;
.ЧИСЛО: add  DI,ЭЛ_ЗНА     ; // ПРсто записывем число нвоое
        mov [DI],DX        ;
        JMP .ВЫХОД         ;
        ;------------------;
.СТРОКА:
        Call ЭЛЕ_ЗНА       ; // Читаем адрес значения
        call УДАЛИТЬ_СТРОКУ_AX; // Освобождаю строку
        MOV  SI,DI         ;
        add  SI,ЭЛ_ЗНА     ;
        mov [SI],DX        ; // Запись новго значения
        MOV  SI,DI         ;
        add  SI,ЭЛ_ТИП     ;
        mov Byte [SI],ТИП_ЧИСЛ; // Запись нового  типа элемента
        JMP .ВЫХОД         ;
        ;------------------;
.ВЫХОД:
        popad ;
        ret   ;
        END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                        ;{ ОПИСАНИЕ
                        ;  Записывает DX как значение в элемент Di
                        ;  DX обычное число
                        ;  То есть устанавливает тип число у эелемнта
                        ;  Если элемнт был строкой то усвобождает сроку что бы
                        ;  Память не занимала
                        ;}
        pushad;                        ; тут нада передалть
        call ЭЛЕ_ТИП_ЧИСЛО ; // Определяет тип элемента что бы освободить
        JNZ .ЧИСЛО         ; // СТроку если элемнт был строкой ; // Если элемент и был числом то просто запишем значение
        call ЭЛЕ_ТИП_СТРОКА; // Если элемент строка то нада освободить сперва строку
        JNZ .СТРОКА        ; // и поменять тип   элемента
        JMP .ВЫХОД         ; // Если тип элемнта неизвестен то пропускаем ничего не записываем
        ;------------------;
.ЧИСЛО: add  EDI,ЭЛ_ЗНА    ; // ПРсто записывем число нвоое
        mov [EDI],EDX      ;
        JMP .ВЫХОД         ;
        ;------------------;
.СТРОКА:
        Call ЭЛЕ_ЗНА       ; // Читаем адрес значения
        call УДАЛИТЬ_СТРОКУ_AX; // Освобождаю строку
        MOV  ESI,EDI       ;
        add  ESI,ЭЛ_ЗНА    ;
        mov [ESI],EDX      ; // Запись новго значения
        MOV  ESI,EDI       ;
        add  ESI,ЭЛ_ТИП    ;
        mov Byte [ESI],ТИП_ЧИСЛ; // Запись нового  типа элемента
        JMP .ВЫХОД         ;
        ;------------------;
.ВЫХОД:
        popad ;
        ret   ;
        END IF;}
;}
ЗАПИСАТЬ_ЗНАЧЕНИЕ_AX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА:;{
IF  (ПЛАТФОРМА = ДОС)   ;{
pushad;
mov  dx,ax;
call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА
popad;
ret;
END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
pushad;
mov  dx,ax;
call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА
popad;
ret;
END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
pushad;
mov  edx,eax;
call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА
popad;
ret;
END IF;}
;}
ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА:;{ Записывает копирует значение DX как строку  в Элемент DI Изменяя тип если нада
IF  (ПЛАТФОРМА = ДОС)   ;{
        pushad;
        Call  ЭЛЕ_ТИП_ЧИСЛО;
        JNZ  .ЧИСЛО;
        Call  ЭЛЕ_ТИП_СТРОКА;  продолжимс
        JNZ  .СТРОКА;
        JMP  .ВЫХОД;
.ЧИСЛО:
        MOV  SI,DI;
        add  SI,ЭЛ_ТИП;
        mov Byte [SI],ТИП_СТРО;

        MOV  SI,DI;
        add  SI,ЭЛ_ЗНА;
        call СОЗДАТЬ_CX_КОПИЮ_СТРОКИ_DX
        mov [SI],CX;

        JMP .ВЫХОД;
.СТРОКА:
        Call ЭЛЕ_ЗНА;
        Mov  cx,ax;
        Call ЗАПИСАТЬ_СТРОКУ_DX_В_СТРОКУ_CX
        JMP .ВЫХОД;
.ВЫХОД:
        popad ;
        ret   ;
        END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
         pushad;
        call ЭЛЕ_ТИП    ;
        cmp  AX,ТИП_ЧИСЛ;
        JZ  .ЧИСЛО;
        cmp  AX,ТИП_СТРО;
        JZ  .СТРОКА;
        JMP .ВЫХОД;
.ЧИСЛО:
        MOV  SI,DI;
        add  SI,ЭЛ_ТИП;
        mov Byte [SI],ТИП_СТРО;

        MOV  SI,DI;
        add  SI,ЭЛ_ЗНА;
        call СОЗДАТЬ_CX_КОПИЮ_СТРОКИ_DX
        mov [SI],CX;

        JMP .ВЫХОД;
.СТРОКА:
        Call ЭЛЕ_ЗНА;
        Mov  cx,ax;
        Call ЗАПИСАТЬ_СТРОКУ_DX_В_СТРОКУ_CX
        JMP .ВЫХОД;
.ВЫХОД:
        popad ;
        ret   ;
        END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
         pushad;
        call ЭЛЕ_ТИП    ;
        cmp  EAX,ТИП_ЧИСЛ;
        JZ  .ЧИСЛО;
        cmp  EAX,ТИП_СТРО;
        JZ  .СТРОКА;
        JMP .ВЫХОД;
.ЧИСЛО:
        MOV  ESI,EDI;
        add  ESI,ЭЛ_ТИП;
        mov Byte [ESI],ТИП_СТРО;

        MOV  ESI,EDI;
        add  ESI,ЭЛ_ЗНА;
        call СОЗДАТЬ_CX_КОПИЮ_СТРОКИ_DX
        mov [ESI],ECX;

        JMP .ВЫХОД;
.СТРОКА:
        Call ЭЛЕ_ЗНА;
        Mov  Ecx,Eax;
        Call ЗАПИСАТЬ_СТРОКУ_DX_В_СТРОКУ_CX
        JMP .ВЫХОД;
.ВЫХОД:
        popad ;
        ret   ;
        END IF;}
;}
ЗАПИСАТЬ_ЗНАЧЕНИЕ_BX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА:;{ Записывает копирует значение DX как строку  в Элемент DI Изменяя тип если нада
IF  (ПЛАТФОРМА = ДОС)   ;{
        push DX;
        mov  DX,BX;
        call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА;
        pop  DX ;
        ret   ;
        END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
        push DX;
        mov  DX,BX;
        call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА;
        pop  DX ;
        ret   ;
        END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
        push EDX;
        mov  EDX,EBX;
        call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА;
        pop  EDX ;
        ret   ;
        END IF;}
;}

ПОЛУЧИТЬ_КОД_AX_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_В_ЭЛЕМЕНТ_DI:;{
IF  (ПЛАТФОРМА = ДОС)   ;{
           push di;
           call ЭЛЕ_ВЛО;
           mov  di,ax;
           call ЭЛЕ_КОД;
           pop  di;
           ret;
           END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
           push di;
           call ЭЛЕ_ВЛО;
           mov  di,ax;
           call ЭЛЕ_КОД;
           pop  di;
           ret;
           END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
           push edi;
           call ЭЛЕ_ВЛО;
           mov  edi,eax;
           call ЭЛЕ_КОД;
           pop  edi;
           ret;
           END IF;}
;==============================================================================}
ПОЛУЧИТЬ_КОД_CX_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА:;{
IF  (ПЛАТФОРМА = ДОС)   ;{
           push AX;
           call ПОЛУЧИТЬ_КОД_AX_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_В_ЭЛЕМЕНТ_DI
           mov  cx,ax;
           pop  AX;
           ret;
           END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
           push AX;
           call ПОЛУЧИТЬ_КОД_AX_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_В_ЭЛЕМЕНТ_DI
           mov  cx,ax;
           pop  AX;
           ret;
           END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
           push EAX;
           call ПОЛУЧИТЬ_КОД_AX_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_В_ЭЛЕМЕНТ_DI
           mov  Ecx,Eax;
           pop  EAX;
           ret;
           END IF;}

;==============================================================================}
СТРОКА_CX_КОНСОЛИ :;{ Находит консоль для вывода начиная с элемента DI
IF  (ПЛАТФОРМА = ДОС)   ;{
                  pushad
                  mov  dx,0;
                  mov  cx,КОД_ОКН_МОНИТОР  ;
                  Call ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI;
                  jz  .ВЫХОД
                  mov  cx,КОД_ПАР_ТЕКС;
                  call ЭЛЕ_ПОИСК_ВН_ПО_КОДУ_CX;
                  jz  .ВЫХОД
                  mov  dx,di;
.ВЫХОД:
                  mov  cx,dx;
                  call ВОЗВРАТИТЬ_CX;
                  test cx,cx;
                  popad;
                  ret;
                  END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                  pushad
                  mov  dx,0;
                  mov  cx,КОД_ОКН_МОНИТОР  ;
                  Call ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI;
                  jz  .ВЫХОД
                  mov  cx,КОД_ПАР_ТЕКС;
                  call ЭЛЕ_ПОИСК_ВН_ПО_КОДУ_CX;
                  jz  .ВЫХОД
                  mov  dx,di;
.ВЫХОД:
                  mov  cx,dx;
                  call ВОЗВРАТИТЬ_CX;
                  test cx,cx;
                  popad;
                  ret;
                  END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                  pushad
                  mov  edx,0;
                  mov  ecx,КОД_ОКН_МОНИТОР  ;
                  Call ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI;
                  jz  .ВЫХОД
                  mov  ecx,КОД_ПАР_ТЕКС;
                  call ЭЛЕ_ПОИСК_ВН_ПО_КОДУ_CX;
                  jz  .ВЫХОД
                  mov  edx,edi;
.ВЫХОД:
                  mov  ecx,edx;
                  call ВОЗВРАТИТЬ_CX;
                  test ecx,ecx;
                  popad;
                  ret;
                  END IF;}

;------------------------------------------------------------------------------}
НАЙТИ_КОНСОЛЬ_В_DI:;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  pushad
                  mov  cx,КОД_ОКН_МОНИТОР  ;
                  Call ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI;
                  call ВОЗВРАТИТЬ_DI;
                  test DI,DI;
                  popad;
                  ret;
                  END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                  pushad
                  mov  cx,КОД_ОКН_МОНИТОР  ;
                  Call ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI;
                  call ВОЗВРАТИТЬ_DI;
                  test DI,DI;
                  popad;
                  ret;
                  END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                  pushad
                  mov  ecx,КОД_ОКН_МОНИТОР  ;
                  Call ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI;
                  call ВОЗВРАТИТЬ_DI;
                  test EDI,EDI;
                  popad;
                  ret;
                  END IF;}
;------------------------------------------------------------------------------}
НАЙТИ_БУФЕР_В_AX  :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
pushad;
mov eax,0;
call НАЙТИ_КОНСОЛЬ_В_DI;
jz .ВЫХОД;
call ОКНО_БУФ;
.ВЫХОД:
call ВОЗВРАТИТЬ_AX;
test eax,eax;
popad;
ret;
END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
pushad;
mov eax,0;
call НАЙТИ_КОНСОЛЬ_В_DI;
jz .ВЫХОД;
call ОКНО_БУФ;
.ВЫХОД:
call ВОЗВРАТИТЬ_AX;
test eax,eax;
popad;
ret;
END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
pushad;
mov eax,0;
call НАЙТИ_КОНСОЛЬ_В_DI;
jz .ВЫХОД;
call ОКНО_БУФ;
.ВЫХОД:
call ВОЗВРАТИТЬ_AX;
test eax,eax;
popad;
ret;
END IF;}

;}
ВЫВОД_В_КОНСОЛЬ_СТРОКИ_SI:;{
IF  (ПЛАТФОРМА = ДОС)   ;{
        pushad;
        call НАЙТИ_КОНСОЛЬ_В_DI;
        jz  .ВЫХОД;
        mov ax,0;
.ПОВТОР:
        mov  al,[si];
        test ax,ax;
        jz  .ВЫХОД;
        call ОКНО_DI_КН_AX;
        inc  si;
        jmp .ПОВТОР;
.ВЫХОД:


        popad;
        ret;
        END IF ;}
IF  (ПЛАТФОРМА = T16)   ;{
        pushad;
        call НАЙТИ_КОНСОЛЬ_В_DI;
        jz  .ВЫХОД;
        mov ax,0;

.ПОВТОР:
        mov  al,[si];
        test ax,ax;
        jz  .ВЫХОД;
        call ОКНО_DI_КН_AX;
        inc  si;
        jmp .ПОВТОР;
.ВЫХОД:


        popad;
        ret;
        END IF ;}
IF  (ПЛАТФОРМА = T32)   ;{
        pushad;
        call НАЙТИ_КОНСОЛЬ_В_DI;
        jz  .ВЫХОД;
        mov eax,0;

.ПОВТОР:
        mov  al,[esi];
        test eax,eax;
        jz  .ВЫХОД;
        call ОКНО_DI_КН_AX;
        inc  esi;
        jmp .ПОВТОР;
.ВЫХОД:


        popad;
        ret;
        END IF ;}
;}


ТИП_ОПЕРАЦИИ          :;{ ОПРЕДЕЛЯЕТ Тип ОПерации для Элемента DI рез в AX
IF  (ПЛАТФОРМА = ДОС)   ;{
              pushad
              mov  edx,0
              call ЭЛЕ_ВЛО          ; // Определяем тип результата
              JZ  .ВЫХОД            ; // Если нет вложеных элментов то выход
              ;---------------------;
              mov  edi,eax            ; // Переходим в первый вложеный эллемент
              call ЭЛЕ_ТИП          ; // Читаем ТИп
              mov  cl,10            ;
              mul  cl               ;
              add  edx,eax            ;
              ;---------------------;
              call ЭЛЕ_СЛЕ          ;
              jz  .ВЫХОД            ; // Если нет следующего Элемента выходим
              ;---------------------;
              mov  edi,eax            ;
              call ЭЛЕ_ТИП          ;
              add  edx,eax            ;
              ;---------------------;
.ВЫХОД:
              mov  eax,edx            ;
              call ВОЗВРАТИТЬ_AX    ;
              popad                 ;
              ret                   ;
              END IF                ;}
IF  (ПЛАТФОРМА = T16)   ;{
              pushad
              mov  edx,0
              call ЭЛЕ_ВЛО          ; // Определяем тип результата
              JZ  .ВЫХОД            ; // Если нет вложеных элментов то выход
              ;---------------------;
              mov  edi,eax            ; // Переходим в первый вложеный эллемент
              call ЭЛЕ_ТИП          ; // Читаем ТИп
              mov  cl,10            ;
              mul  cl               ;
              add  edx,eax            ;
              ;---------------------;
              call ЭЛЕ_СЛЕ          ;
              jz  .ВЫХОД            ; // Если нет следующего Элемента выходим
              ;---------------------;
              mov  edi,eax            ;
              call ЭЛЕ_ТИП          ;
              add  edx,eax            ;
              ;---------------------;
.ВЫХОД:
              mov  eax,edx            ;
              call ВОЗВРАТИТЬ_AX    ;
              popad                 ;
              ret                   ;
              END IF                ;}
IF  (ПЛАТФОРМА = T32)   ;{
              pushad
              mov  edx,0
              call ЭЛЕ_ВЛО          ; // Определяем тип результата
              JZ  .ВЫХОД            ; // Если нет вложеных элментов то выход
              ;---------------------;
              mov  edi,eax            ; // Переходим в первый вложеный эллемент
              call ЭЛЕ_ТИП          ; // Читаем ТИп
              mov  cl,10            ;
              mul  cl               ;
              add  edx,eax            ;
              ;---------------------;
              call ЭЛЕ_СЛЕ          ;
              jz  .ВЫХОД            ; // Если нет следующего Элемента выходим
              ;---------------------;
              mov  edi,eax            ;
              call ЭЛЕ_ТИП          ;
              add  edx,eax            ;
              ;---------------------;
.ВЫХОД:
              mov  eax,edx            ;
              call ВОЗВРАТИТЬ_AX    ;
              popad                 ;
              ret                   ;
              END IF                ;}
;==============================================================================}
ТИП_ОПЕРАЦИИ_DI_BX    :;{ ОПРЕДЕЛЯЕТ Тип ОПерации для Эл DI и Эл BX
IF  (ПЛАТФОРМА = ДОС)   ;{
              push di;
              push dx;
              mov  dx,0
              call ЭЛЕ_ТИП          ; // Определяем тип результата
              mov  cl,10            ;
              mul  cl               ;
              add  dx,ax            ;

              mov  di,bx            ;
              call ЭЛЕ_ТИП          ; // Определяем тип результата
              add  dx,ax            ;

              mov  ax,dx            ;
              pop  dx               ;
              pop  di               ;
              ret;
              END IF                ;}
IF  (ПЛАТФОРМА = T16)   ;{
              push di;
              push dx;
              mov  dx,0
              call ЭЛЕ_ТИП          ; // Определяем тип результата
              mov  cl,10            ;
              mul  cl               ;
              add  dx,ax            ;

              mov  di,bx            ;
              call ЭЛЕ_ТИП          ; // Определяем тип результата
              add  dx,ax            ;

              mov  ax,dx            ;
              pop  dx               ;
              pop  di               ;
              ret;
              END IF                ;}
IF  (ПЛАТФОРМА = T32)   ;{
              push edi;
              push edx;
              mov  edx,0
              call ЭЛЕ_ТИП          ; // Определяем тип результата
              mov  cl,10            ;
              mul  cl               ;
              add  edx,eax            ;

              mov  edi,ebx            ;
              call ЭЛЕ_ТИП          ; // Определяем тип результата
              add  edx,eax            ;

              mov  eax,edx            ;
              pop  edx               ;
              pop  edi               ;
              ret;
              END IF                ;}
;==============================================================================}
ПРИСВОИТЬ_ЗНА_В_ЭЛЕ_DI_ИЗ_ЭЛЕ_BX :;{ ПРисвоить значение элемента в DI из элемнета BX
IF  (ПЛАТФОРМА = ДОС)   ;{
          pushad;
          call ТИП_ОПЕРАЦИИ_DI_BX;
          cmp  ax,ЧИС_ЧИС;
          jz  .ЧЧ;
          cmp  ax,СТР_СТР;
          jz  .CC;
          cmp  ax,ЧИС_СТР;
          jz  .ЧС;
          cmp  ax,СТР_ЧИС;
          jz  .СЧ;
          jmp .ВЫХОД;
.ЧЧ:     ;{ЧИСЛО<ЧИСЛО      ;
          mov  si,bx        ;
          add  di,ЭЛ_ЗНА    ;
          add  si,ЭЛ_ЗНА    ;
          mov  ax,[si]      ;
          mov [di],ax       ;
          jmp .ВЫХОД        ;
         ;-----------------}
.CC:     ;{СТРОКА<СТРОКА    ;
          call ЭЛЕ_ЗНА      ;
          mov  dx,ax        ;
          mov  di,bx        ;
          call ЭЛЕ_ЗНА      ;
          mov  cx,ax        ;
          call ЗАПИСАТЬ_СТРОКУ_CX_В_СТРОКУ_DX;
          jmp .ВЫХОД       ;
         ;-----------------}
.ЧС:     ;{ЧИСЛО<СТРОКА     ;
          mov  si,bx        ;
          add  si,ЭЛ_ЗНА    ;
          mov  dx,[SI]      ;
          call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА
          jmp .ВЫХОД        ;
         ;------------------}
.СЧ:     ;{СТРОКА<ЧИСЛО     ;
          mov  si,bx        ;
          add  si,ЭЛ_ЗНА    ;
          mov  dx,[SI]      ;
          call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО
          jmp .ВЫХОД        ;
          ;-----------------}
.ВЫХОД:
          popad;
          ret;
          END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
          pushad;
          call ТИП_ОПЕРАЦИИ_DI_BX;
          cmp  ax,ЧИС_ЧИС;
          jz  .ЧЧ;
          cmp  ax,СТР_СТР;
          jz  .CC;
          cmp  ax,ЧИС_СТР;
          jz  .ЧС;
          cmp  ax,СТР_ЧИС;
          jz  .СЧ;
          jmp .ВЫХОД;
.ЧЧ:     ;{ЧИСЛО<ЧИСЛО      ;
          mov  si,bx        ;
          add  di,ЭЛ_ЗНА    ;
          add  si,ЭЛ_ЗНА    ;
          mov  ax,[si]      ;
          mov [di],ax       ;
          jmp .ВЫХОД        ;
         ;-----------------}
.CC:     ;{СТРОКА<СТРОКА    ;
          call ЭЛЕ_ЗНА      ;
          mov  dx,ax        ;
          mov  di,bx        ;
          call ЭЛЕ_ЗНА      ;
          mov  cx,ax        ;
          call ЗАПИСАТЬ_СТРОКУ_CX_В_СТРОКУ_DX;
          jmp .ВЫХОД       ;
         ;-----------------}
.ЧС:     ;{ЧИСЛО<СТРОКА     ;
          mov  si,bx        ;
          add  si,ЭЛ_ЗНА    ;
          mov  dx,[SI]      ;
          call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА
          jmp .ВЫХОД        ;
         ;------------------}
.СЧ:     ;{СТРОКА<ЧИСЛО     ;
          mov  si,bx        ;
          add  si,ЭЛ_ЗНА    ;
          mov  dx,[SI]      ;
          call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО
          jmp .ВЫХОД        ;
          ;-----------------}
.ВЫХОД:
          popad;
          ret;
          END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
          pushad;
          call ТИП_ОПЕРАЦИИ_DI_BX;
          cmp  ax,ЧИС_ЧИС;
          jz  .ЧЧ;
          cmp  ax,СТР_СТР;
          jz  .CC;
          cmp  ax,ЧИС_СТР;
          jz  .ЧС;
          cmp  ax,СТР_ЧИС;
          jz  .СЧ;
          jmp .ВЫХОД;
.ЧЧ:     ;{ЧИСЛО<ЧИСЛО      ;
          mov  esi,ebx        ;
          add  edi,ЭЛ_ЗНА    ;
          add  esi,ЭЛ_ЗНА    ;
          mov  eax,[esi]      ;
          mov [edi],eax       ;
          jmp .ВЫХОД        ;
         ;-----------------}
.CC:     ;{СТРОКА<СТРОКА    ;
          call ЭЛЕ_ЗНА      ;
          mov  edx,eax        ;
          mov  edi,ebx        ;
          call ЭЛЕ_ЗНА      ;
          mov  ecx,eax        ;
          call ЗАПИСАТЬ_СТРОКУ_CX_В_СТРОКУ_DX;
          jmp .ВЫХОД       ;
         ;-----------------}
.ЧС:     ;{ЧИСЛО<СТРОКА     ;
          mov  esi,ebx        ;
          add  esi,ЭЛ_ЗНА    ;
          mov  edx,[eSI]      ;
          call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА
          jmp .ВЫХОД        ;
         ;------------------}
.СЧ:     ;{СТРОКА<ЧИСЛО     ;
          mov  esi,ebx        ;
          add  esi,ЭЛ_ЗНА    ;
          mov  edx,[eSI]      ;
          call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО
          jmp .ВЫХОД        ;
          ;-----------------}
.ВЫХОД:
          popad;
          ret;
          END IF;}
;==============================================================================}
ПРИСВОИТЬ_ЗНА_В_ЭЛЕ_DX_ИЗ_ЭЛЕ_BX :;{ ПРисвоить значение элемента в DX из элемнета BX
IF  (ПЛАТФОРМА = ДОС)   ;{
          pushad;
          mov  di,dx;
          call ПРИСВОИТЬ_ЗНА_В_ЭЛЕ_DI_ИЗ_ЭЛЕ_BX;
          popad;
          ret;
          END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
          pushad;
          mov  di,dx;
          call ПРИСВОИТЬ_ЗНА_В_ЭЛЕ_DI_ИЗ_ЭЛЕ_BX;
          popad;
          ret;
          END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
          pushad;
          mov  edi,edx;
          call ПРИСВОИТЬ_ЗНА_В_ЭЛЕ_DI_ИЗ_ЭЛЕ_BX;
          popad;
          ret;
          END IF;}
;------------------------------------------------------------------------------}

ВКОД_ТЕК_ПУСТО     :;{
ret;}
ВКОД_ТЕК_СЛОЖЕНИЕ  :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       ;{ ВЫБОР  ТИПА ОПЕРАЦИИ --------------------------;
       cmp  ax,ЧИС_ЧИС;
       jz  .ЧЧ        ;
       cmp  ax,ЧИС_СТР;
       jz  .ЧС        ;
       cmp  ax,СТР_ЧИС;
       jz  .СЧ        ;
       cmp  ax,СТР_СТР;
       jz  .СС        ;
       jmp .ВЫХОД     ;
       ;--------------}
.ЧЧ:   ;{ ЧИСЛО  ЧИСЛО
       add  Dx,Cx;
       call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
       jmp .ВЫХОД     ;
       ;--------------}
.ЧС:   ;{ ЧИСЛО  СТРОКА
       call СОЗДАТЬ_СТРОКУ_BX_ДЛИНОЙ_16_БАЙТ;
       call ДОБАВИТЬ_ЧИСЛО_CX_В_КОНЕЦ_СТРОКИ_BX;
       call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_BX_СТРОКУ_DX;
       call ЗАПИСАТЬ_ЗНАЧЕНИЕ_BX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА;
       call УДАЛИТЬ_СТРОКУ_BX;
       jmp .ВЫХОД     ;
       ;--------------}
.СЧ:   ;{ СТРОКА ЧИСЛО
       call СОЗДАТЬ_СТРОКУ_BX_ДЛИНОЙ_16_БАЙТ;
       call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_BX_СТРОКУ_CX;
       call ДОБАВИТЬ_ЧИСЛО_DX_В_КОНЕЦ_СТРОКИ_BX;
       call ЗАПИСАТЬ_ЗНАЧЕНИЕ_BX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА;
       call УДАЛИТЬ_СТРОКУ_BX;
       jmp .ВЫХОД     ;
       ;--------------}
.СС:   ;{ СТРОКА СТРОКА
       call СОЗДАТЬ_СТРОКУ_BX_ДЛИНОЙ_16_БАЙТ;
       call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_BX_СТРОКУ_CX;
       call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_BX_СТРОКУ_DX;
       call ЗАПИСАТЬ_ЗНАЧЕНИЕ_BX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА;
       call УДАЛИТЬ_СТРОКУ_BX;
       jmp .ВЫХОД     ;
       ;--------------}
.ВЫХОД:
       popad;
       ret;
       END IF; }
IF  (ПЛАТФОРМА = T16)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       ;{ ВЫБОР  ТИПА ОПЕРАЦИИ --------------------------;
       cmp  ax,ЧИС_ЧИС;
       jz  .ЧЧ        ;
       cmp  ax,ЧИС_СТР;
       jz  .ЧС        ;
       cmp  ax,СТР_ЧИС;
       jz  .СЧ        ;
       cmp  ax,СТР_СТР;
       jz  .СС        ;
       jmp .ВЫХОД     ;
       ;--------------}
.ЧЧ:   ;{ ЧИСЛО  ЧИСЛО
       add  Dx,Cx;
       call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
       jmp .ВЫХОД     ;
       ;--------------}
.ЧС:   ;{ ЧИСЛО  СТРОКА
       call СОЗДАТЬ_СТРОКУ_BX_ДЛИНОЙ_16_БАЙТ;
       call ДОБАВИТЬ_ЧИСЛО_CX_В_КОНЕЦ_СТРОКИ_BX;
       call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_BX_СТРОКУ_DX;
       call ЗАПИСАТЬ_ЗНАЧЕНИЕ_BX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА;
       call УДАЛИТЬ_СТРОКУ_BX;
       jmp .ВЫХОД     ;
       ;--------------}
.СЧ:   ;{ СТРОКА ЧИСЛО
       call СОЗДАТЬ_СТРОКУ_BX_ДЛИНОЙ_16_БАЙТ;
       call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_BX_СТРОКУ_CX;
       call ДОБАВИТЬ_ЧИСЛО_DX_В_КОНЕЦ_СТРОКИ_BX;
       call ЗАПИСАТЬ_ЗНАЧЕНИЕ_BX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА;
       call УДАЛИТЬ_СТРОКУ_BX;
       jmp .ВЫХОД     ;
       ;--------------}
.СС:   ;{ СТРОКА СТРОКА
       call СОЗДАТЬ_СТРОКУ_BX_ДЛИНОЙ_16_БАЙТ;
       call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_BX_СТРОКУ_CX;
       call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_BX_СТРОКУ_DX;
       call ЗАПИСАТЬ_ЗНАЧЕНИЕ_BX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА;
       call УДАЛИТЬ_СТРОКУ_BX;
       jmp .ВЫХОД     ;
       ;--------------}
.ВЫХОД:
       popad;
       ret;
       END IF; }
IF  (ПЛАТФОРМА = T32)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       ;{ ВЫБОР  ТИПА ОПЕРАЦИИ --------------------------;
       cmp  ax,ЧИС_ЧИС;
       jz  .ЧЧ        ;
       cmp  ax,ЧИС_СТР;
       jz  .ЧС        ;
       cmp  ax,СТР_ЧИС;
       jz  .СЧ        ;
       cmp  ax,СТР_СТР;
       jz  .СС        ;
       jmp .ВЫХОД     ;
       ;--------------}
.ЧЧ:   ;{ ЧИСЛО  ЧИСЛО
       add  eDx,eCx;
       call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
       jmp .ВЫХОД     ;
       ;--------------}
.ЧС:   ;{ ЧИСЛО  СТРОКА
       call СОЗДАТЬ_СТРОКУ_BX_ДЛИНОЙ_16_БАЙТ;
       call ДОБАВИТЬ_ЧИСЛО_CX_В_КОНЕЦ_СТРОКИ_BX;
       call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_BX_СТРОКУ_DX;
       call ЗАПИСАТЬ_ЗНАЧЕНИЕ_BX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА;
       call УДАЛИТЬ_СТРОКУ_BX;
       jmp .ВЫХОД     ;
       ;--------------}
.СЧ:   ;{ СТРОКА ЧИСЛО
       call СОЗДАТЬ_СТРОКУ_BX_ДЛИНОЙ_16_БАЙТ;
       call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_BX_СТРОКУ_CX;
       call ДОБАВИТЬ_ЧИСЛО_DX_В_КОНЕЦ_СТРОКИ_BX;
       call ЗАПИСАТЬ_ЗНАЧЕНИЕ_BX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА;
       call УДАЛИТЬ_СТРОКУ_BX;
       jmp .ВЫХОД     ;
       ;--------------}
.СС:   ;{ СТРОКА СТРОКА
       call СОЗДАТЬ_СТРОКУ_BX_ДЛИНОЙ_16_БАЙТ;
       call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_BX_СТРОКУ_CX;
       call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_BX_СТРОКУ_DX;
       call ЗАПИСАТЬ_ЗНАЧЕНИЕ_BX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА;
       call УДАЛИТЬ_СТРОКУ_BX;
       jmp .ВЫХОД     ;
       ;--------------}
.ВЫХОД:
       popad;
       ret;
       END IF; }

;------------------------------------------------------------------------------}
ВКОД_ТЕК_ВЫЧИТАНИЕ :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       cmp  ax,ЧИС_ЧИС                                   ;
       jnz .ВЫХОД                                        ;
       Sub  cx,dx                                        ;
       mov  dx,cx                                        ;
       call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО  ;
.ВЫХОД:
       popad;
       ret;
       END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       cmp  ax,ЧИС_ЧИС                                   ;
       jnz .ВЫХОД                                        ;
       Sub  cx,dx                                        ;
       mov  dx,cx                                        ;
       call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО  ;
.ВЫХОД:
       popad;
       ret;
       END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       cmp  eax,ЧИС_ЧИС                                  ;
       jnz .ВЫХОД                                        ;
       Sub  ecx,edx                                      ;
       mov  edx,ecx                                      ;
       call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО  ;
.ВЫХОД:
       popad;
       ret;
       END IF;}
;------------------------------------------------------------------------------}
ВКОД_ТЕК_УМНОЖЕНИЕ :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       cmp  eax,ЧИС_ЧИС                                  ;
       jnz .ВЫХОД                                        ;
       ;---------;
       mov  ax,cx;
       mul  dl   ;
       mov  dx,ax;
       ;---------;
       call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО  ;
.ВЫХОД:
       popad;
       ret;
       END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       cmp  eax,ЧИС_ЧИС                                  ;
       jnz .ВЫХОД                                        ;
       ;---------;
       mov  ax,cx;
       mul  dl   ;
       mov  dx,ax;
       ;---------;
       call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО  ;
.ВЫХОД:
       popad;
       ret;
       END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       cmp  eax,ЧИС_ЧИС                                  ;
       jnz .ВЫХОД                                        ;
       ;---------;
       mov  eax,ecx;
       mul  dx   ;
       mov  edx,eax;
       ;---------;
       call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО  ;
.ВЫХОД:
       popad;
       ret;
       END IF;}
;------------------------------------------------------------------------------}
ВКОД_ТЕК_ДЕЛЕНИЕ   :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       cmp  ax,ЧИС_ЧИС                                   ;
       jnz .ВЫХОД                                        ;
       ;---------;
       mov  ax,cx;
       div  dl   ;
       mov  dh,0 ;
       mov  dl,al;
       ;---------;
       call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО  ;
.ВЫХОД:
       popad;
       ret;
       END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       cmp  ax,ЧИС_ЧИС                                   ;
       jnz .ВЫХОД                                        ;
       ;---------;
       mov  ax,cx;
       div  dl   ;
       mov  dh,0 ;
       mov  dl,al;
       ;---------;
       call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО  ;
.ВЫХОД:
       popad;
       ret;
       END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       cmp  ax,ЧИС_ЧИС                                   ;
       jnz .ВЫХОД                                        ;
       ;---------;
       mov  eax,ecx;
       div  dx   ;
       mov  dx,ax;
       ;---------;
       call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО  ;
.ВЫХОД:
       popad;
       ret;
       END IF;}
;------------------------------------------------------------------------------}
ВКОД_ТЕК_ОСТАТОК   :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       cmp  ax,ЧИС_ЧИС                                   ;
       jnz .ВЫХОД                                        ;
       ;---------;
       mov  ax,cx;
       div  dl   ;
       mov  dh,0 ;
       mov  dl,ah;
       ;---------;
       call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО  ;
.ВЫХОД:
       popad;
       ret;
       END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       cmp  ax,ЧИС_ЧИС                                   ;
       jnz .ВЫХОД                                        ;
       ;---------;
       mov  ax,cx;
       div  dl   ;
       mov  dh,0 ;
       mov  dl,ah;
       ;---------;
       call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО  ;
.ВЫХОД:
       popad;
       ret;
       END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       cmp  ax,ЧИС_ЧИС                                   ;
       jnz .ВЫХОД                                        ;
       ;---------;
       mov  eax,ecx;
       div  dl   ;
       mov  dh,0 ;
       mov  dl,ah;
       ;---------;
       call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО  ;
.ВЫХОД:
       popad;
       ret;
       END IF;}

;------------------------------------------------------------------------------}
ВКОД_ТЕК_ПРИСВОЕНИЕ:;{
IF  (ПЛАТФОРМА = ДОС)   ;{
       pushad;
         call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
         call ТИП_ВТОРОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА;
         call ЗНАЧЕНИЕ_ВТОРОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_DX
         ;----------------------------------------------;
         call ПОЛУЧИТЬ_КОД_CX_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА;
         call ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI   ;
         jz  .ВЫХОД;   значение DX уже запомнили
         ;----------------------------------------------;
         cmp  ax,ТИП_ЧИСЛ;
         jz  .ЧИСЛО;
         cmp  ax,ТИП_СТРО;
         jz  .СТРОКА;
         jmp .ВЫХОД;
         ;----------------------------------------------;
.ЧИСЛО:  Call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
         jmp .ВЫХОД;
         ;----------------------------------------------;
.СТРОКА: Call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА;
         jmp .ВЫХОД;
         ;----------------------------------------------;
.ВЫХОД:
         popad;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
       pushad;
         call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
         call ТИП_ВТОРОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА;
         call ЗНАЧЕНИЕ_ВТОРОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_DX
         ;----------------------------------------------;
         call ПОЛУЧИТЬ_КОД_CX_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА;
         call ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI   ;
         jz  .ВЫХОД;   значение DX уже запомнили
         ;----------------------------------------------;
         cmp  ax,ТИП_ЧИСЛ;
         jz  .ЧИСЛО;
         cmp  ax,ТИП_СТРО;
         jz  .СТРОКА;
         jmp .ВЫХОД;
         ;----------------------------------------------;
.ЧИСЛО:  Call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
         jmp .ВЫХОД;
         ;----------------------------------------------;
.СТРОКА: Call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА;
         jmp .ВЫХОД;
         ;----------------------------------------------;
.ВЫХОД:
         popad;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
       pushad;
         call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
         call ТИП_ВТОРОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА;
         call ЗНАЧЕНИЕ_ВТОРОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_DX
         ;----------------------------------------------;
         call ПОЛУЧИТЬ_КОД_CX_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА;
         call ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI   ;
         jz  .ВЫХОД;   значение DX уже запомнили
         ;----------------------------------------------;
         cmp  ax,ТИП_ЧИСЛ;
         jz  .ЧИСЛО;
         cmp  ax,ТИП_СТРО;
         jz  .СТРОКА;
         jmp .ВЫХОД;
         ;----------------------------------------------;
.ЧИСЛО:  Call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
         jmp .ВЫХОД;
         ;----------------------------------------------;
.СТРОКА: Call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА;
         jmp .ВЫХОД;
         ;----------------------------------------------;
.ВЫХОД:
         popad;
         ret;
         END IF;}

;==============================================================================}
ВКОД_ТЕК_РАВНО     :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       ;{ ВЫБОР  ТИПА ОПЕРАЦИИ --------------------------;
       cmp  ax,ЧИС_ЧИС;
       jz  .ЧЧ        ;
       cmp  ax,ЧИС_СТР;
       jz  .ЧС        ;
       cmp  ax,СТР_ЧИС;
       jz  .СЧ        ;
       cmp  ax,СТР_СТР;
       jz  .СС        ;
       jmp .ВЫХОД     ;
       ;--------------}
.ЧЧ:   ;{ ЧИСЛО  ЧИСЛО .
       cmp  Dx,Cx;
       jz  .РАВНО;
       jmp .НЕРАВ;
       ;--------------}
.ЧС:   ;{ ЧИСЛО  СТРОКА.
       call ЧИСЛО_CX_РАВНО_СТРОКИ_DX_ФЛАГ_Z_1
       jnz .РАВНО     ;
       jmp .НЕРАВ     ;
       ;--------------}
.СЧ:   ;{ СТРОКА ЧИСЛО .
       call СТРОКА_CX_РАВНА_ЧИСЛУ_DX_ФЛАГ_Z_1;
       jnz .РАВНО     ;
       jmp .НЕРАВ     ;
       ;--------------}
.СС:   ;{ СТРОКА СТРОКА.
       call СТРОКА_CX_РАВНА_СТРОКИ_DX_ФЛАГ_Z_1;
       jnz .РАВНО     ;
       jmp .НЕРАВ     ;
       ;--------------}
.РАВНО:;{ РАВНО        .
       mov  dx,1 ;
       jmp .ВЫХОД;
       ;---------}
.НЕРАВ:;{ НЕ РАВНО     .
        mov  dx,0;}
.ВЫХОД:call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
       popad;
       ret;
       END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       ;{ ВЫБОР  ТИПА ОПЕРАЦИИ --------------------------;
       cmp  ax,ЧИС_ЧИС;
       jz  .ЧЧ        ;
       cmp  ax,ЧИС_СТР;
       jz  .ЧС        ;
       cmp  ax,СТР_ЧИС;
       jz  .СЧ        ;
       cmp  ax,СТР_СТР;
       jz  .СС        ;
       jmp .ВЫХОД     ;
       ;--------------}
.ЧЧ:   ;{ ЧИСЛО  ЧИСЛО .
       cmp  Dx,Cx;
       jz  .РАВНО;
       jmp .НЕРАВ;
       ;--------------}
.ЧС:   ;{ ЧИСЛО  СТРОКА.
       call ЧИСЛО_CX_РАВНО_СТРОКИ_DX_ФЛАГ_Z_1
       jnz .РАВНО     ;
       jmp .НЕРАВ     ;
       ;--------------}
.СЧ:   ;{ СТРОКА ЧИСЛО .
       call СТРОКА_CX_РАВНА_ЧИСЛУ_DX_ФЛАГ_Z_1;
       jnz .РАВНО     ;
       jmp .НЕРАВ     ;
       ;--------------}
.СС:   ;{ СТРОКА СТРОКА.
       call СТРОКА_CX_РАВНА_СТРОКИ_DX_ФЛАГ_Z_1;
       jnz .РАВНО     ;
       jmp .НЕРАВ     ;
       ;--------------}
.РАВНО:;{ РАВНО        .
       mov  dx,1 ;
       jmp .ВЫХОД;
       ;---------}
.НЕРАВ:;{ НЕ РАВНО     .
        mov  dx,0;}
.ВЫХОД:call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
       popad;
       ret;
       END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       ;{ ВЫБОР  ТИПА ОПЕРАЦИИ --------------------------;
       cmp  ax,ЧИС_ЧИС;
       jz  .ЧЧ        ;
       cmp  ax,ЧИС_СТР;
       jz  .ЧС        ;
       cmp  ax,СТР_ЧИС;
       jz  .СЧ        ;
       cmp  ax,СТР_СТР;
       jz  .СС        ;
       jmp .ВЫХОД     ;
       ;--------------}
.ЧЧ:   ;{ ЧИСЛО  ЧИСЛО .
       cmp  eDx,eCx;
       jz  .РАВНО;
       jmp .НЕРАВ;
       ;--------------}
.ЧС:   ;{ ЧИСЛО  СТРОКА.
       call ЧИСЛО_CX_РАВНО_СТРОКИ_DX_ФЛАГ_Z_1
       jnz .РАВНО     ;
       jmp .НЕРАВ     ;
       ;--------------}
.СЧ:   ;{ СТРОКА ЧИСЛО .
       call СТРОКА_CX_РАВНА_ЧИСЛУ_DX_ФЛАГ_Z_1;
       jnz .РАВНО     ;
       jmp .НЕРАВ     ;
       ;--------------}
.СС:   ;{ СТРОКА СТРОКА.
       call СТРОКА_CX_РАВНА_СТРОКИ_DX_ФЛАГ_Z_1;
       jnz .РАВНО     ;
       jmp .НЕРАВ     ;
       ;--------------}
.РАВНО:;{ РАВНО        .
       mov  edx,1 ;
       jmp .ВЫХОД;
       ;---------}
.НЕРАВ:;{ НЕ РАВНО     .
        mov  edx,0;}
.ВЫХОД:call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
       popad;
       ret;
       END IF;}

;--------------------------------------------------------}
ВКОД_ТЕК_НЕРАВНО   :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       ;{ ВЫБОР  ТИПА ОПЕРАЦИИ --------------------------;
       cmp  ax,ЧИС_ЧИС;
       jz  .ЧЧ        ;
       cmp  ax,ЧИС_СТР;
       jz  .ЧС        ;
       cmp  ax,СТР_ЧИС;
       jz  .СЧ        ;
       cmp  ax,СТР_СТР;
       jz  .СС        ;
       jmp .ВЫХОД     ;
       ;--------------}
.ЧЧ:   ;{ ЧИСЛО  ЧИСЛО .
       cmp  Dx,Cx;
       jz  .РАВНО;
       jmp .НЕРАВ;
       ;--------------}
.ЧС:   ;{ ЧИСЛО  СТРОКА.
       call ЧИСЛО_CX_РАВНО_СТРОКИ_DX_ФЛАГ_Z_1
       jnz .РАВНО     ;
       jmp .НЕРАВ     ;
       ;--------------}
.СЧ:   ;{ СТРОКА ЧИСЛО .
       call СТРОКА_CX_РАВНА_ЧИСЛУ_DX_ФЛАГ_Z_1;
       jnz .РАВНО     ;
       jmp .НЕРАВ     ;
       ;--------------}
.СС:   ;{ СТРОКА СТРОКА.
       call СТРОКА_CX_РАВНА_СТРОКИ_DX_ФЛАГ_Z_1;
       jnz .РАВНО     ;
       jmp .НЕРАВ     ;
       ;--------------}
.РАВНО:;{ РАВНО        .
       mov  dx,0 ;
       jmp .ВЫХОД;
       ;---------}
.НЕРАВ:;{ НЕ РАВНО     .
        mov  dx,1;}
.ВЫХОД:call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
       popad;
       ret;
       END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       ;{ ВЫБОР  ТИПА ОПЕРАЦИИ --------------------------;
       cmp  ax,ЧИС_ЧИС;
       jz  .ЧЧ        ;
       cmp  ax,ЧИС_СТР;
       jz  .ЧС        ;
       cmp  ax,СТР_ЧИС;
       jz  .СЧ        ;
       cmp  ax,СТР_СТР;
       jz  .СС        ;
       jmp .ВЫХОД     ;
       ;--------------}
.ЧЧ:   ;{ ЧИСЛО  ЧИСЛО .
       cmp  Dx,Cx;
       jz  .РАВНО;
       jmp .НЕРАВ;
       ;--------------}
.ЧС:   ;{ ЧИСЛО  СТРОКА.
       call ЧИСЛО_CX_РАВНО_СТРОКИ_DX_ФЛАГ_Z_1
       jnz .РАВНО     ;
       jmp .НЕРАВ     ;
       ;--------------}
.СЧ:   ;{ СТРОКА ЧИСЛО .
       call СТРОКА_CX_РАВНА_ЧИСЛУ_DX_ФЛАГ_Z_1;
       jnz .РАВНО     ;
       jmp .НЕРАВ     ;
       ;--------------}
.СС:   ;{ СТРОКА СТРОКА.
       call СТРОКА_CX_РАВНА_СТРОКИ_DX_ФЛАГ_Z_1;
       jnz .РАВНО     ;
       jmp .НЕРАВ     ;
       ;--------------}
.РАВНО:;{ РАВНО        .
       mov  dx,0 ;
       jmp .ВЫХОД;
       ;---------}
.НЕРАВ:;{ НЕ РАВНО     .
        mov  dx,1;}
.ВЫХОД:call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
       popad;
       ret;
       END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       ;{ ВЫБОР  ТИПА ОПЕРАЦИИ --------------------------;
       cmp  ax,ЧИС_ЧИС;
       jz  .ЧЧ        ;
       cmp  ax,ЧИС_СТР;
       jz  .ЧС        ;
       cmp  ax,СТР_ЧИС;
       jz  .СЧ        ;
       cmp  ax,СТР_СТР;
       jz  .СС        ;
       jmp .ВЫХОД     ;
       ;--------------}
.ЧЧ:   ;{ ЧИСЛО  ЧИСЛО .
       cmp  Dx,Cx;
       jz  .РАВНО;
       jmp .НЕРАВ;
       ;--------------}
.ЧС:   ;{ ЧИСЛО  СТРОКА.
       call ЧИСЛО_CX_РАВНО_СТРОКИ_DX_ФЛАГ_Z_1
       jnz .РАВНО     ;
       jmp .НЕРАВ     ;
       ;--------------}
.СЧ:   ;{ СТРОКА ЧИСЛО .
       call СТРОКА_CX_РАВНА_ЧИСЛУ_DX_ФЛАГ_Z_1;
       jnz .РАВНО     ;
       jmp .НЕРАВ     ;
       ;--------------}
.СС:   ;{ СТРОКА СТРОКА.
       call СТРОКА_CX_РАВНА_СТРОКИ_DX_ФЛАГ_Z_1;
       jnz .РАВНО     ;
       jmp .НЕРАВ     ;
       ;--------------}
.РАВНО:;{ РАВНО        .
       mov  dx,0 ;
       jmp .ВЫХОД;
       ;---------}
.НЕРАВ:;{ НЕ РАВНО     .
        mov  dx,1;}
.ВЫХОД:call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
       popad;
       ret;
       END IF;}
;--------------------------------------------------------}
ВКОД_ТЕК_БОЛЬШЕ    :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       ;{ ВЫБОР  ТИПА ОПЕРАЦИИ --------------------------;
       cmp  ax,ЧИС_ЧИС;
       jz  .ЧЧ        ;
       cmp  ax,ЧИС_СТР;
       jz  .ЧС        ;
       cmp  ax,СТР_ЧИС;
       jz  .СЧ        ;
       cmp  ax,СТР_СТР;
       jz  .СС        ;
       jmp .ВЫХОД     ;
       ;--------------}
.ЧЧ:   ;{ ЧИСЛО  ЧИСЛО .
       cmp  cx,dx;
       ja  .БОЛЬШЕ;
       jmp .НЕБОЛЬ;
       ;--------------}
.ЧС:   ;{ ЧИСЛО  СТРОКА.
       call ЧИСЛО_CX_БОЛЬШЕ_СТРОКИ_DX_ФЛАГ_Z_1
       jnz .БОЛЬШЕ    ;
       jmp .НЕБОЛЬ    ;
       ;--------------}
.СЧ:   ;{ СТРОКА ЧИСЛО .
       call СТРОКА_CX_БОЛЬШЕ_ЧИСЛА_DX_ФЛАГ_Z_1;
       jnz .БОЛЬШЕ    ;
       jmp .НЕБОЛЬ    ;
       ;--------------}
.СС:   ;{ СТРОКА СТРОКА.
       call СТРОКА_CX_БОЛЬШЕ_СТРОКИ_DX_ФЛАГ_Z_1;
       jnz .БОЛЬШЕ    ;
       jmp .НЕБОЛЬ    ;
       ;--------------}
.БОЛЬШЕ:;{ БОЛЬШЕ      .
       mov  dx,1 ;
       jmp .ВЫХОД;
       ;---------}
.НЕБОЛЬ:;{ НЕ БОЛЬШЕ   .
        mov  dx,0;}
.ВЫХОД:call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
       popad;
       ret;
       END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       ;{ ВЫБОР  ТИПА ОПЕРАЦИИ --------------------------;
       cmp  ax,ЧИС_ЧИС;
       jz  .ЧЧ        ;
       cmp  ax,ЧИС_СТР;
       jz  .ЧС        ;
       cmp  ax,СТР_ЧИС;
       jz  .СЧ        ;
       cmp  ax,СТР_СТР;
       jz  .СС        ;
       jmp .ВЫХОД     ;
       ;--------------}
.ЧЧ:   ;{ ЧИСЛО  ЧИСЛО .
       cmp  cx,dx;
       ja  .БОЛЬШЕ;
       jmp .НЕБОЛЬ;
       ;--------------}
.ЧС:   ;{ ЧИСЛО  СТРОКА.
       call ЧИСЛО_CX_БОЛЬШЕ_СТРОКИ_DX_ФЛАГ_Z_1
       jnz .БОЛЬШЕ    ;
       jmp .НЕБОЛЬ    ;
       ;--------------}
.СЧ:   ;{ СТРОКА ЧИСЛО .
       call СТРОКА_CX_БОЛЬШЕ_ЧИСЛА_DX_ФЛАГ_Z_1;
       jnz .БОЛЬШЕ    ;
       jmp .НЕБОЛЬ    ;
       ;--------------}
.СС:   ;{ СТРОКА СТРОКА.
       call СТРОКА_CX_БОЛЬШЕ_СТРОКИ_DX_ФЛАГ_Z_1;
       jnz .БОЛЬШЕ    ;
       jmp .НЕБОЛЬ    ;
       ;--------------}
.БОЛЬШЕ:;{ БОЛЬШЕ      .
       mov  dx,1 ;
       jmp .ВЫХОД;
       ;---------}
.НЕБОЛЬ:;{ НЕ БОЛЬШЕ   .
        mov  dx,0;}
.ВЫХОД:call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
       popad;
       ret;
       END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       ;{ ВЫБОР  ТИПА ОПЕРАЦИИ --------------------------;
       cmp  ax,ЧИС_ЧИС;
       jz  .ЧЧ        ;
       cmp  ax,ЧИС_СТР;
       jz  .ЧС        ;
       cmp  ax,СТР_ЧИС;
       jz  .СЧ        ;
       cmp  ax,СТР_СТР;
       jz  .СС        ;
       jmp .ВЫХОД     ;
       ;--------------}
.ЧЧ:   ;{ ЧИСЛО  ЧИСЛО .
       cmp  cx,dx;
       ja  .БОЛЬШЕ;
       jmp .НЕБОЛЬ;
       ;--------------}
.ЧС:   ;{ ЧИСЛО  СТРОКА.
       call ЧИСЛО_CX_БОЛЬШЕ_СТРОКИ_DX_ФЛАГ_Z_1
       jnz .БОЛЬШЕ    ;
       jmp .НЕБОЛЬ    ;
       ;--------------}
.СЧ:   ;{ СТРОКА ЧИСЛО .
       call СТРОКА_CX_БОЛЬШЕ_ЧИСЛА_DX_ФЛАГ_Z_1;
       jnz .БОЛЬШЕ    ;
       jmp .НЕБОЛЬ    ;
       ;--------------}
.СС:   ;{ СТРОКА СТРОКА.
       call СТРОКА_CX_БОЛЬШЕ_СТРОКИ_DX_ФЛАГ_Z_1;
       jnz .БОЛЬШЕ    ;
       jmp .НЕБОЛЬ    ;
       ;--------------}
.БОЛЬШЕ:;{ БОЛЬШЕ      .
       mov  dx,1 ;
       jmp .ВЫХОД;
       ;---------}
.НЕБОЛЬ:;{ НЕ БОЛЬШЕ   .
        mov  dx,0;}
.ВЫХОД:call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
       popad;
       ret;
       END IF;}
;--------------------------------------------------------}
ВКОД_ТЕК_МЕНЬШЕ    :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       ;{ ВЫБОР  ТИПА ОПЕРАЦИИ --------------------------;
       cmp  ax,ЧИС_ЧИС;
       jz  .ЧЧ        ;
       cmp  ax,ЧИС_СТР;
       jz  .ЧС        ;
       cmp  ax,СТР_ЧИС;
       jz  .СЧ        ;
       cmp  ax,СТР_СТР;
       jz  .СС        ;
       jmp .ВЫХОД     ;
       ;--------------}
.ЧЧ:   ;{ ЧИСЛО  ЧИСЛО .
       cmp  cx,dx;
       jb  .МЕНЬШЕ;
       jmp .НЕМЕНШ;
       ;--------------}
.ЧС:   ;{ ЧИСЛО  СТРОКА.
       call ЧИСЛО_CX_МЕНЬШЕ_СТРОКИ_DX_ФЛАГ_Z_1
       jnz .МЕНЬШЕ    ;
       jmp .НЕМЕНШ    ;
       ;--------------}
.СЧ:   ;{ СТРОКА ЧИСЛО .
       call СТРОКА_CX_МЕНЬШЕ_ЧИСЛА_DX_ФЛАГ_Z_1;
       jnz .МЕНЬШЕ    ;
       jmp .НЕМЕНШ    ;
       ;--------------}
.СС:   ;{ СТРОКА СТРОКА.
       call СТРОКА_CX_МЕНЬШЕ_СТРОКИ_DX_ФЛАГ_Z_1;
       jnz .МЕНЬШЕ    ;
       jmp .НЕМЕНШ    ;
       ;--------------}
.МЕНЬШЕ:;{ МЕНЬШЕ      .
       mov  dx,1 ;
       jmp .ВЫХОД;
       ;---------}
.НЕМЕНШ:;{ НЕ МЕНЬШЕ   .
        mov  dx,0;}
.ВЫХОД:call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
       popad;
       ret;
       END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       ;{ ВЫБОР  ТИПА ОПЕРАЦИИ --------------------------;
       cmp  ax,ЧИС_ЧИС;
       jz  .ЧЧ        ;
       cmp  ax,ЧИС_СТР;
       jz  .ЧС        ;
       cmp  ax,СТР_ЧИС;
       jz  .СЧ        ;
       cmp  ax,СТР_СТР;
       jz  .СС        ;
       jmp .ВЫХОД     ;
       ;--------------}
.ЧЧ:   ;{ ЧИСЛО  ЧИСЛО .
       cmp  cx,dx;
       jb  .МЕНЬШЕ;
       jmp .НЕМЕНШ;
       ;--------------}
.ЧС:   ;{ ЧИСЛО  СТРОКА.
       call ЧИСЛО_CX_МЕНЬШЕ_СТРОКИ_DX_ФЛАГ_Z_1
       jnz .МЕНЬШЕ    ;
       jmp .НЕМЕНШ    ;
       ;--------------}
.СЧ:   ;{ СТРОКА ЧИСЛО .
       call СТРОКА_CX_МЕНЬШЕ_ЧИСЛА_DX_ФЛАГ_Z_1;
       jnz .МЕНЬШЕ    ;
       jmp .НЕМЕНШ    ;
       ;--------------}
.СС:   ;{ СТРОКА СТРОКА.
       call СТРОКА_CX_МЕНЬШЕ_СТРОКИ_DX_ФЛАГ_Z_1;
       jnz .МЕНЬШЕ    ;
       jmp .НЕМЕНШ    ;
       ;--------------}
.МЕНЬШЕ:;{ МЕНЬШЕ      .
       mov  dx,1 ;
       jmp .ВЫХОД;
       ;---------}
.НЕМЕНШ:;{ НЕ МЕНЬШЕ   .
        mov  dx,0;}
.ВЫХОД:call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
       popad;
       ret;
       END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       ;{ ВЫБОР  ТИПА ОПЕРАЦИИ --------------------------;
       cmp  ax,ЧИС_ЧИС;
       jz  .ЧЧ        ;
       cmp  ax,ЧИС_СТР;
       jz  .ЧС        ;
       cmp  ax,СТР_ЧИС;
       jz  .СЧ        ;
       cmp  ax,СТР_СТР;
       jz  .СС        ;
       jmp .ВЫХОД     ;
       ;--------------}
.ЧЧ:   ;{ ЧИСЛО  ЧИСЛО .
       cmp  cx,dx;
       jb  .МЕНЬШЕ;
       jmp .НЕМЕНШ;
       ;--------------}
.ЧС:   ;{ ЧИСЛО  СТРОКА.
       call ЧИСЛО_CX_МЕНЬШЕ_СТРОКИ_DX_ФЛАГ_Z_1
       jnz .МЕНЬШЕ    ;
       jmp .НЕМЕНШ    ;
       ;--------------}
.СЧ:   ;{ СТРОКА ЧИСЛО .
       call СТРОКА_CX_МЕНЬШЕ_ЧИСЛА_DX_ФЛАГ_Z_1;
       jnz .МЕНЬШЕ    ;
       jmp .НЕМЕНШ    ;
       ;--------------}
.СС:   ;{ СТРОКА СТРОКА.
       call СТРОКА_CX_МЕНЬШЕ_СТРОКИ_DX_ФЛАГ_Z_1;
       jnz .МЕНЬШЕ    ;
       jmp .НЕМЕНШ    ;
       ;--------------}
.МЕНЬШЕ:;{ МЕНЬШЕ      .
       mov  dx,1 ;
       jmp .ВЫХОД;
       ;---------}
.НЕМЕНШ:;{ НЕ МЕНЬШЕ   .
        mov  dx,0;}
.ВЫХОД:call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
       popad;
       ret;
       END IF;}
;--------------------------------------------------------}
ВКОД_ТЕК_МЕНРА     :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       ;{ ВЫБОР  ТИПА ОПЕРАЦИИ --------------------------;
       cmp  ax,ЧИС_ЧИС;
       jz  .ЧЧ        ;
       cmp  ax,ЧИС_СТР;
       jz  .ЧС        ;
       cmp  ax,СТР_ЧИС;
       jz  .СЧ        ;
       cmp  ax,СТР_СТР;
       jz  .СС        ;
       jmp .ВЫХОД     ;
       ;--------------}
.ЧЧ:   ;{ ЧИСЛО  ЧИСЛО .
       cmp  cx,dx;
       jbe  .МЕНЬШЕ;
       jmp .НЕМЕНШ;
       ;--------------}
.ЧС:   ;{ ЧИСЛО  СТРОКА.
       call ЧИСЛО_CX_МЕНЬШЕР_СТРОКИ_DX_ФЛАГ_Z_1
       jnz .МЕНЬШЕ    ;
       jmp .НЕМЕНШ    ;
       ;--------------}
.СЧ:   ;{ СТРОКА ЧИСЛО .
       call СТРОКА_CX_МЕНЬШЕР_ЧИСЛА_DX_ФЛАГ_Z_1;
       jnz .МЕНЬШЕ    ;
       jmp .НЕМЕНШ    ;
       ;--------------}
.СС:   ;{ СТРОКА СТРОКА.
       call СТРОКА_CX_МЕНЬШЕР_СТРОКИ_DX_ФЛАГ_Z_1;
       jnz .МЕНЬШЕ    ;
       jmp .НЕМЕНШ    ;
       ;--------------}
.МЕНЬШЕ:;{ МЕНЬШЕ      .
       mov  dx,1 ;
       jmp .ВЫХОД;
       ;---------}
.НЕМЕНШ:;{ НЕ МЕНЬШЕ   .
        mov  dx,0;}
.ВЫХОД:call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
       popad;
       ret;
       END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       ;{ ВЫБОР  ТИПА ОПЕРАЦИИ --------------------------;
       cmp  ax,ЧИС_ЧИС;
       jz  .ЧЧ        ;
       cmp  ax,ЧИС_СТР;
       jz  .ЧС        ;
       cmp  ax,СТР_ЧИС;
       jz  .СЧ        ;
       cmp  ax,СТР_СТР;
       jz  .СС        ;
       jmp .ВЫХОД     ;
       ;--------------}
.ЧЧ:   ;{ ЧИСЛО  ЧИСЛО .
       cmp  cx,dx;
       jbe  .МЕНЬШЕ;
       jmp .НЕМЕНШ;
       ;--------------}
.ЧС:   ;{ ЧИСЛО  СТРОКА.
       call ЧИСЛО_CX_МЕНЬШЕР_СТРОКИ_DX_ФЛАГ_Z_1
       jnz .МЕНЬШЕ    ;
       jmp .НЕМЕНШ    ;
       ;--------------}
.СЧ:   ;{ СТРОКА ЧИСЛО .
       call СТРОКА_CX_МЕНЬШЕР_ЧИСЛА_DX_ФЛАГ_Z_1;
       jnz .МЕНЬШЕ    ;
       jmp .НЕМЕНШ    ;
       ;--------------}
.СС:   ;{ СТРОКА СТРОКА.
       call СТРОКА_CX_МЕНЬШЕР_СТРОКИ_DX_ФЛАГ_Z_1;
       jnz .МЕНЬШЕ    ;
       jmp .НЕМЕНШ    ;
       ;--------------}
.МЕНЬШЕ:;{ МЕНЬШЕ      .
       mov  dx,1 ;
       jmp .ВЫХОД;
       ;---------}
.НЕМЕНШ:;{ НЕ МЕНЬШЕ   .
        mov  dx,0;}
.ВЫХОД:call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
       popad;
       ret;
       END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       ;{ ВЫБОР  ТИПА ОПЕРАЦИИ --------------------------;
       cmp  ax,ЧИС_ЧИС;
       jz  .ЧЧ        ;
       cmp  ax,ЧИС_СТР;
       jz  .ЧС        ;
       cmp  ax,СТР_ЧИС;
       jz  .СЧ        ;
       cmp  ax,СТР_СТР;
       jz  .СС        ;
       jmp .ВЫХОД     ;
       ;--------------}
.ЧЧ:   ;{ ЧИСЛО  ЧИСЛО .
       cmp  cx,dx;
       jbe  .МЕНЬШЕ;
       jmp .НЕМЕНШ;
       ;--------------}
.ЧС:   ;{ ЧИСЛО  СТРОКА.
       call ЧИСЛО_CX_МЕНЬШЕР_СТРОКИ_DX_ФЛАГ_Z_1
       jnz .МЕНЬШЕ    ;
       jmp .НЕМЕНШ    ;
       ;--------------}
.СЧ:   ;{ СТРОКА ЧИСЛО .
       call СТРОКА_CX_МЕНЬШЕР_ЧИСЛА_DX_ФЛАГ_Z_1;
       jnz .МЕНЬШЕ    ;
       jmp .НЕМЕНШ    ;
       ;--------------}
.СС:   ;{ СТРОКА СТРОКА.
       call СТРОКА_CX_МЕНЬШЕР_СТРОКИ_DX_ФЛАГ_Z_1;
       jnz .МЕНЬШЕ    ;
       jmp .НЕМЕНШ    ;
       ;--------------}
.МЕНЬШЕ:;{ МЕНЬШЕ      .
       mov  dx,1 ;
       jmp .ВЫХОД;
       ;---------}
.НЕМЕНШ:;{ НЕ МЕНЬШЕ   .
        mov  dx,0;}
.ВЫХОД:call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
       popad;
       ret;
       END IF;}
;--------------------------------------------------------}
ВКОД_ТЕК_БОЛРА     :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       ;{ ВЫБОР  ТИПА ОПЕРАЦИИ --------------------------;
       cmp  ax,ЧИС_ЧИС;
       jz  .ЧЧ        ;
       cmp  ax,ЧИС_СТР;
       jz  .ЧС        ;
       cmp  ax,СТР_ЧИС;
       jz  .СЧ        ;
       cmp  ax,СТР_СТР;
       jz  .СС        ;
       jmp .ВЫХОД     ;
       ;--------------}
.ЧЧ:   ;{ ЧИСЛО  ЧИСЛО .
       cmp  cx,dx;
       jae  .БОЛЬШЕ;
       jmp .НЕБОЛЬ;
       ;--------------}
.ЧС:   ;{ ЧИСЛО  СТРОКА.
       call ЧИСЛО_CX_БОЛЬШЕР_СТРОКИ_DX_ФЛАГ_Z_1
       jnz .БОЛЬШЕ    ;
       jmp .НЕБОЛЬ    ;
       ;--------------}
.СЧ:   ;{ СТРОКА ЧИСЛО .
       call СТРОКА_CX_БОЛЬШЕР_ЧИСЛА_DX_ФЛАГ_Z_1;
       jnz .БОЛЬШЕ    ;
       jmp .НЕБОЛЬ    ;
       ;--------------}
.СС:   ;{ СТРОКА СТРОКА.
       call СТРОКА_CX_БОЛЬШЕР_СТРОКИ_DX_ФЛАГ_Z_1;
       jnz .БОЛЬШЕ    ;
       jmp .НЕБОЛЬ    ;
       ;--------------}
.БОЛЬШЕ:;{ БОЛЬШЕ      .
       mov  dx,1 ;
       jmp .ВЫХОД;
       ;---------}
.НЕБОЛЬ:;{ НЕ БОЛЬШЕ   .
        mov  dx,0;}
.ВЫХОД:call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
       popad;
       ret;
       END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       ;{ ВЫБОР  ТИПА ОПЕРАЦИИ --------------------------;
       cmp  ax,ЧИС_ЧИС;
       jz  .ЧЧ        ;
       cmp  ax,ЧИС_СТР;
       jz  .ЧС        ;
       cmp  ax,СТР_ЧИС;
       jz  .СЧ        ;
       cmp  ax,СТР_СТР;
       jz  .СС        ;
       jmp .ВЫХОД     ;
       ;--------------}
.ЧЧ:   ;{ ЧИСЛО  ЧИСЛО .
       cmp  cx,dx;
       jae  .БОЛЬШЕ;
       jmp .НЕБОЛЬ;
       ;--------------}
.ЧС:   ;{ ЧИСЛО  СТРОКА.
       call ЧИСЛО_CX_БОЛЬШЕР_СТРОКИ_DX_ФЛАГ_Z_1
       jnz .БОЛЬШЕ    ;
       jmp .НЕБОЛЬ    ;
       ;--------------}
.СЧ:   ;{ СТРОКА ЧИСЛО .
       call СТРОКА_CX_БОЛЬШЕР_ЧИСЛА_DX_ФЛАГ_Z_1;
       jnz .БОЛЬШЕ    ;
       jmp .НЕБОЛЬ    ;
       ;--------------}
.СС:   ;{ СТРОКА СТРОКА.
       call СТРОКА_CX_БОЛЬШЕР_СТРОКИ_DX_ФЛАГ_Z_1;
       jnz .БОЛЬШЕ    ;
       jmp .НЕБОЛЬ    ;
       ;--------------}
.БОЛЬШЕ:;{ БОЛЬШЕ      .
       mov  dx,1 ;
       jmp .ВЫХОД;
       ;---------}
.НЕБОЛЬ:;{ НЕ БОЛЬШЕ   .
        mov  dx,0;}
.ВЫХОД:call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
       popad;
       ret;
       END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
       pushad                                            ;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
       call ТИП_ОПЕРАЦИИ                                 ;
       ;{ ВЫБОР  ТИПА ОПЕРАЦИИ --------------------------;
       cmp  ax,ЧИС_ЧИС;
       jz  .ЧЧ        ;
       cmp  ax,ЧИС_СТР;
       jz  .ЧС        ;
       cmp  ax,СТР_ЧИС;
       jz  .СЧ        ;
       cmp  ax,СТР_СТР;
       jz  .СС        ;
       jmp .ВЫХОД     ;
       ;--------------}
.ЧЧ:   ;{ ЧИСЛО  ЧИСЛО .
       cmp  cx,dx;
       jae  .БОЛЬШЕ;
       jmp .НЕБОЛЬ;
       ;--------------}
.ЧС:   ;{ ЧИСЛО  СТРОКА.
       call ЧИСЛО_CX_БОЛЬШЕР_СТРОКИ_DX_ФЛАГ_Z_1
       jnz .БОЛЬШЕ    ;
       jmp .НЕБОЛЬ    ;
       ;--------------}
.СЧ:   ;{ СТРОКА ЧИСЛО .
       call СТРОКА_CX_БОЛЬШЕР_ЧИСЛА_DX_ФЛАГ_Z_1;
       jnz .БОЛЬШЕ    ;
       jmp .НЕБОЛЬ    ;
       ;--------------}
.СС:   ;{ СТРОКА СТРОКА.
       call СТРОКА_CX_БОЛЬШЕР_СТРОКИ_DX_ФЛАГ_Z_1;
       jnz .БОЛЬШЕ    ;
       jmp .НЕБОЛЬ    ;
       ;--------------}
.БОЛЬШЕ:;{ БОЛЬШЕ      .
       mov  dx,1 ;
       jmp .ВЫХОД;
       ;---------}
.НЕБОЛЬ:;{ НЕ БОЛЬШЕ   .
        mov  dx,0;}
.ВЫХОД:call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
       popad;
       ret;
       END IF;}
;--------------------------------------------------------}
ВКОД_ТЕК_ЛОГИ      :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
        pushad                                            ;
        call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
        call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
        call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
        call ТИП_ОПЕРАЦИИ                                 ;
        cmp  ax,ЧИС_ЧИС                                   ;
        jnz .ВЫХОД                                        ;
        cmp  cx,0                                         ;
        jnz .НЕПРАВ                                       ;
        cmp  dx,0                                         ;
        jnz .НЕПРАВ                                       ;
        jmp .ПРАВДА                                       ;
.НЕПРАВ:mov  dx,0                                         ;
        call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО  ;
        jmp .ВЫХОД                                        ;
.ПРАВДА:mov  dx,1                                         ;
        call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО  ;
        jmp .ВЫХОД                                        ;
.ВЫХОД:
        popad;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
        pushad                                            ;
        call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
        call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
        call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
        call ТИП_ОПЕРАЦИИ                                 ;
        cmp  ax,ЧИС_ЧИС                                   ;
        jnz .ВЫХОД                                        ;
        cmp  cx,0                                         ;
        jnz .НЕПРАВ                                       ;
        cmp  dx,0                                         ;
        jnz .НЕПРАВ                                       ;
        jmp .ПРАВДА                                       ;
.НЕПРАВ:mov  dx,0                                         ;
        call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО  ;
        jmp .ВЫХОД                                        ;
.ПРАВДА:mov  dx,1                                         ;
        call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО  ;
        jmp .ВЫХОД                                        ;
.ВЫХОД:
        popad;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
        pushad                                            ;
        call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
        call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
        call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
        call ТИП_ОПЕРАЦИИ                                 ;
        cmp  ax,ЧИС_ЧИС                                   ;
        jnz .ВЫХОД                                        ;
        cmp  cx,0                                         ;
        jnz .НЕПРАВ                                       ;
        cmp  dx,0                                         ;
        jnz .НЕПРАВ                                       ;
        jmp .ПРАВДА                                       ;
.НЕПРАВ:mov  dx,0                                         ;
        call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО  ;
        jmp .ВЫХОД                                        ;
.ПРАВДА:mov  dx,1                                         ;
        call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО  ;
        jmp .ВЫХОД                                        ;
.ВЫХОД:
        popad;
        ret;
        END IF;}

;------------------------------------------------------------------------------}
ВКОД_ТЕК_ЛОГИЛИ    :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
        pushad                                            ;
        call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
        call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
        call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
        call ТИП_ОПЕРАЦИИ                                 ;
        cmp  ax,ЧИС_ЧИС                                   ;
        jnz .ВЫХОД                                        ;
        cmp  cx,1                                         ;
        jnz .ПРАВДА                                       ;
        cmp  dx,1                                         ;
        jnz .ПРАВДА                                       ;
.НЕПРАВ:mov  dx,0                                         ;
        call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО  ;
        jmp .ВЫХОД                                        ;
.ПРАВДА:mov  dx,1                                         ;
        call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО  ;
        jmp .ВЫХОД                                        ;
.ВЫХОД:
        popad;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
        pushad                                            ;
        call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
        call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
        call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
        call ТИП_ОПЕРАЦИИ                                 ;
        cmp  ax,ЧИС_ЧИС                                   ;
        jnz .ВЫХОД                                        ;
        cmp  cx,1                                         ;
        jnz .ПРАВДА                                       ;
        cmp  dx,1                                         ;
        jnz .ПРАВДА                                       ;
.НЕПРАВ:mov  dx,0                                         ;
        call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО  ;
        jmp .ВЫХОД                                        ;
.ПРАВДА:mov  dx,1                                         ;
        call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО  ;
        jmp .ВЫХОД                                        ;
.ВЫХОД:
        popad;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
        pushad                                            ;
        call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
        call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
        call ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX             ;
        call ТИП_ОПЕРАЦИИ                                 ;
        cmp  ax,ЧИС_ЧИС                                   ;
        jnz .ВЫХОД                                        ;
        cmp  cx,1                                         ;
        jnz .ПРАВДА                                       ;
        cmp  dx,1                                         ;
        jnz .ПРАВДА                                       ;
.НЕПРАВ:mov  dx,0                                         ;
        call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО  ;
        jmp .ВЫХОД                                        ;
.ПРАВДА:mov  dx,1                                         ;
        call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО  ;
        jmp .ВЫХОД                                        ;
.ВЫХОД:
        popad;
        ret;
        END IF;}
;------------------------------------------------------------------------------}
ВКОД_ТЕК_ОСКОБ     :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
        pushad           ;
        ;----------------;
        push di          ; // Если это Функция то
        call ЭЛЕ_РОДИТЕЛЬ; // Выполнять скобку ненада
        call ЭЛЕ_ФУН     ;
        pop  di          ;
        jnz .ВЫХОД       ;
        ;----------------;
        call ВЫПОЛНИТЬ_ВЛ; // Выполняем содержимое скобки
        ;----------------;
        call ЭЛЕ_ОДИН    ; // Если в элементе тока 1 влож элемент
        jz  .ДАЛЕЕ       ;
        ;----------------;
        call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_DX
        call ТИП_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА;
        cmp  ax,ТИП_ЧИСЛ ;
        jnz .ДАЛЕЕ       ;
        Call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
        jmp .ВЫХОД       ;
        ;----------------;
.ДАЛЕЕ:
        call СОЗДАТЬ_СТРОКУ_DX_ДЛИНОЙ_16_БАЙТ; Длин Стро не важна назнач ниже
        Call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА;
        call УДАЛИТЬ_СТРОКУ_DX;
        call ЭЛЕ_ВЛО     ; // Складываем все вложеные значения
        mov  cx,di       ;
.ЦИКЛ:
        test ax,ax       ; // И помесчаем в значение скобки
        jz  .ВЫХОД       ;
        mov  di,ax       ;
        mov  dx,ax       ;
        call ДОБ_ЗНА_В_ЭЛЕ_CX_ИЗ_ЭЛЕ_DX;
        call ЭЛЕ_СЛЕ     ;
        jmp .ЦИКЛ        ;
        ;----------------;
.КЦИКЛ:
.ВЫХОД:
        popad            ;
        ret              ;
        END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
        pushad           ;
        ;----------------;
        push di          ; // Если это Функция то
        call ЭЛЕ_РОДИТЕЛЬ; // Выполнять скобку ненада
        call ЭЛЕ_ФУН     ;
        pop  di          ;
        jnz .ВЫХОД       ;
        ;----------------;
        call ВЫПОЛНИТЬ_ВЛ; // Выполняем содержимое скобки
        ;----------------;
        call ЭЛЕ_ОДИН    ; // Если в элементе тока 1 влож элемент
        jz  .ДАЛЕЕ       ;
        ;----------------;
        call ТИП_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА;
        call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_DX
        cmp  ax,ТИП_ЧИСЛ ;
        jnz .ДАЛЕЕ       ;
        Call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
        jmp .ВЫХОД       ;
        ;----------------;
.ДАЛЕЕ:
        call СОЗДАТЬ_СТРОКУ_DX_ДЛИНОЙ_16_БАЙТ; Длин Стро не важна назнач ниже
        Call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА;
        call УДАЛИТЬ_СТРОКУ_DX;
        call ЭЛЕ_ВЛО     ; // Складываем все вложеные значения
        mov  cx,di       ;
.ЦИКЛ:
        test ax,ax       ; // И помесчаем в значение скобки
        jz  .ВЫХОД       ;
        mov  di,ax       ;
        mov  dx,ax       ;
        call ДОБ_ЗНА_В_ЭЛЕ_CX_ИЗ_ЭЛЕ_DX;
        call ЭЛЕ_СЛЕ     ;
        jmp .ЦИКЛ        ;
        ;----------------;
.КЦИКЛ:
.ВЫХОД:
        popad            ;
        ret              ;
        END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
        pushad           ;
        ;----------------;
        push di          ; // Если это Функция то
        call ЭЛЕ_РОДИТЕЛЬ; // Выполнять скобку ненада
        call ЭЛЕ_ФУН     ;
        pop  di          ;
        jnz .ВЫХОД       ;
        ;----------------;
        call ВЫПОЛНИТЬ_ВЛ; // Выполняем содержимое скобки
        ;----------------;
        call ЭЛЕ_ОДИН    ; // Если в элементе тока 1 влож элемент
        jz  .ДАЛЕЕ       ;
        ;----------------;
        call ТИП_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА;
        call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_DX
        cmp  ax,ТИП_ЧИСЛ ;
        jnz .ДАЛЕЕ       ;
        Call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
        jmp .ВЫХОД       ;
        ;----------------;
.ДАЛЕЕ:
        call СОЗДАТЬ_СТРОКУ_DX_ДЛИНОЙ_16_БАЙТ; Длин Стро не важна назнач ниже
        Call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_СТРОКА;
        call УДАЛИТЬ_СТРОКУ_DX;
        call ЭЛЕ_ВЛО     ; // Складываем все вложеные значения
        mov  cx,di       ;
.ЦИКЛ:
        test ax,ax       ; // И помесчаем в значение скобки
        jz  .ВЫХОД       ;
        mov  di,ax       ;
        mov  dx,ax       ;
        call ДОБ_ЗНА_В_ЭЛЕ_CX_ИЗ_ЭЛЕ_DX;
        call ЭЛЕ_СЛЕ     ;
        jmp .ЦИКЛ        ;
        ;----------------;
.КЦИКЛ:
.ВЫХОД:
        popad            ;
        ret              ;
        END IF;}
;------------------------------------------------------------------------------}
ВКОД_ТЕК_ЗСКОБ     :;{
ret;}
ВКОД_ТЕК_НАЧАЛО    :;{

     call ВЫПОЛНИТЬ_ВЛ;
     ret;
;---------------------------}
ВКОД_ТЕК_КОНЕЦ     :;{
ret;}

ВКОД_ТЕК_ЕСЛИ      :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
       pushad;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ТИП_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА;
       cmp  ax,ТИП_ЧИСЛ                                  ;
       jnz .ВЫХОД                                        ;
       call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_AX  ;
       test ax,ax                                        ;
       jz  .ВЫХОД                                        ;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
.ВЫХОД:
       popad                                             ;
       ret                                               ;
END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
       pushad;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ТИП_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА;
       cmp  ax,ТИП_ЧИСЛ                                  ;
       jnz .ВЫХОД                                        ;
       call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_AX  ;
       test ax,ax                                        ;
       jz  .ВЫХОД                                        ;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
.ВЫХОД:
       popad                                             ;
       ret                                               ;
END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
       pushad;
       call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
       call ТИП_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА;
       cmp  ax,ТИП_ЧИСЛ                                  ;
       jnz .ВЫХОД                                        ;
       call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_AX  ;
       test ax,ax                                        ;
       jz  .ВЫХОД                                        ;
       call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
.ВЫХОД:
       popad                                             ;
       ret                                               ;
END IF;}
;--------------------------------------------------------}
ВКОД_ТЕК_ПОКА      :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
           pushad;
.ПОВТОРИТЬ:call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
           call ТИП_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА;
           cmp  ax,ТИП_ЧИСЛ                                  ;
           jnz .ВЫХОД                                        ;
           call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_AX  ;
           test ax,ax                                        ;
           jz  .ВЫХОД                                        ;
           call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
           jmp .ПОВТОРИТЬ                                    ;
           ;-------------------------------------------------;
.ВЫХОД:
           popad;
           ret;
           END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
           pushad;
.ПОВТОРИТЬ:call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
           call ТИП_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА;
           cmp  ax,ТИП_ЧИСЛ                                  ;
           jnz .ВЫХОД                                        ;
           call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_AX  ;
           test ax,ax                                        ;
           jz  .ВЫХОД                                        ;
           call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
           jmp .ПОВТОРИТЬ                                    ;
           ;-------------------------------------------------;
.ВЫХОД:
           popad;
           ret;
           END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
           pushad;
.ПОВТОРИТЬ:call ВЫПОЛНИТЬ_ПЕРВЫЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
           call ТИП_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА;
           cmp  ax,ТИП_ЧИСЛ                                  ;
           jnz .ВЫХОД                                        ;
           call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_AX  ;
           test ax,ax                                        ;
           jz  .ВЫХОД                                        ;
           call ВЫПОЛНИТЬ_ВТОРОЙ_ВЛОЖЕНЫЙ_ЭЛЕМЕНТ_ЭЛЕМЕНТА_DI;
           jmp .ПОВТОРИТЬ                                    ;
           ;-------------------------------------------------;
.ВЫХОД:
           popad;
           ret;
           END IF;}
;--------------------------------------------------------------------}
ВКОД_ТЕК_ВЫВОД     :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                    pushad;
                    call СОЗДАТЬ_СТРОКУ_SI_ДЛИНОЙ_1024_БАЙТ;
                    call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                    call ЭЛЕ_ВЛО;
                    call ДОБ_ЗНА_В_СТР_SI_ИЗ_ЭЛЕ_AX
                    call ВЫВОД_В_КОНСОЛЬ_СТРОКИ_SI
.ВЫХОД:             call УДАЛИТЬ_СТРОКУ_SI;
                    popad;
                    ret;
                    END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                    pushad;
                    call СОЗДАТЬ_СТРОКУ_SI_ДЛИНОЙ_1024_БАЙТ;
                    call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                    call ЭЛЕ_ВЛО;
                    call ДОБ_ЗНА_В_СТР_SI_ИЗ_ЭЛЕ_AX
                    call ВЫВОД_В_КОНСОЛЬ_СТРОКИ_SI
.ВЫХОД:             call УДАЛИТЬ_СТРОКУ_SI;
                    popad;
                    ret;
                    END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                    pushad;
                    call СОЗДАТЬ_СТРОКУ_SI_ДЛИНОЙ_1024_БАЙТ;
                    call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                    call ЭЛЕ_ВЛО;
                    call ДОБ_ЗНА_В_СТР_SI_ИЗ_ЭЛЕ_AX
                    call ВЫВОД_В_КОНСОЛЬ_СТРОКИ_SI
.ВЫХОД:             call УДАЛИТЬ_СТРОКУ_SI;
                    popad;
                    ret;
                    END IF;}
;--------------------------------------------------------------------}
ВКОД_ТЕК_ВЫВОДСТ   :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                    pushad;
                    call ПРЕРЫВАНИЕ           ;
                    call ВКОД_ТЕК_ВЫВОД;
                    call НАЙТИ_КОНСОЛЬ_В_DI;
                    jz  .ВЫХОД;
                    call ОКНО_КНО_ЕНТЕ
                    .ВЫХОД:
                    popad;
                    ret;
                    END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                    pushad;
                    call ПРЕРЫВАНИЕ           ;
                    call ВКОД_ТЕК_ВЫВОД;
                    call НАЙТИ_КОНСОЛЬ_В_DI;
                    jz  .ВЫХОД;
                    call ОКНО_КНО_ЕНТЕ
                    .ВЫХОД:
                    popad;
                    ret;
                    END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                    pushad;
                    call ПРЕРЫВАНИЕ           ;
                    call ВКОД_ТЕК_ВЫВОД;
                    call НАЙТИ_КОНСОЛЬ_В_DI;
                    jz  .ВЫХОД;
                    call ОКНО_КНО_ЕНТЕ
                    .ВЫХОД:
                    popad;
                    ret;
                    END IF;}
;--------------------------------------------------------------------}

ВКОД_ТЕК_ЦИКЛ      :;{

ret;}
ВКОД_ТЕК_ВВОД      :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                   pushad;

                   ;------------------------;
                   call НАЙТИ_БУФЕР_В_AX
                   jz  .ВЫХОД;
                   call СТРОКА_AX_ОЧИСТКА   ;
.ПОВТОР:
                   call ПРЕРЫВАНИЕ;
                   call ДЛИНА_СТРОКИ_AX_В_CX;
                   JZ  .ПОВТОР;
                   mov  si,ax               ;
                   call ЭЛЕ_ЗНА             ;
                   call ЗАПИСАТЬ_СТРОКУ_AX_В_СТРОКУ_SI;
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                   pushad;

                   ;------------------------;
                   call НАЙТИ_БУФЕР_В_AX
                   jz  .ВЫХОД;
                   call СТРОКА_AX_ОЧИСТКА   ;
.ПОВТОР:
                   call ПРЕРЫВАНИЕ;
                   call ДЛИНА_СТРОКИ_AX_В_CX;
                   JZ  .ПОВТОР;
                   mov  si,ax               ;
                   call ЭЛЕ_ЗНА             ;
                   call ЗАПИСАТЬ_СТРОКУ_AX_В_СТРОКУ_SI;
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                   pushad;

                   ;------------------------;
                   call НАЙТИ_БУФЕР_В_AX
                   jz  .ВЫХОД;
                   call СТРОКА_AX_ОЧИСТКА   ;
.ПОВТОР:
                   call ПРЕРЫВАНИЕ;
                   call ДЛИНА_СТРОКИ_AX_В_CX;
                   JZ  .ПОВТОР;
                   mov  si,ax               ;
                   call ЭЛЕ_ЗНА             ;
                   call ЗАПИСАТЬ_СТРОКУ_AX_В_СТРОКУ_SI;
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
;------------------------------------------------------------------------------}
ВКОД_ТЕК_ВВОДСТ    :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                   pushad;

                   ;------------------------;
                   call НАЙТИ_БУФЕР_В_AX
                   jz  .ВЫХОД;
                   call СТРОКА_AX_ОЧИСТКА   ;
.ПОВТОР:
                   call ПРЕРЫВАНИЕ          ;
                   call ДЛИНА_СТРОКИ_AX_В_CX;
                   JZ  .ПОВТОР              ;
                   mov  si,ax               ;
                   add  si,cx               ;
                   dec  si;
                   cmp  [si],byte 13        ;
                   JnZ .ПОВТОР              ;
                   ;------------------------;
                   call ПРЕРЫВАНИЕ          ;
                   mov  [si],Byte 0         ;
                   call ЭЛЕ_ЗНА             ;
                   mov  si,ax               ;
                   call НАЙТИ_БУФЕР_В_AX    ;
                   call ЕСЛИ_СТРОКА_AX_ЧИСЛО_ФЛАГ_Z_1;
                   jnz .ЧИСЛО;
.СТРОКА:           call ЗАПИСАТЬ_ЗНАЧЕНИЕ_AX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО
                   jmp .ВЫХОД;
.ЧИСЛО:            call ПЕРЕВОДИТ_СТРОКУ_AX_В_ЧИСЛО_DX;
                   call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО

.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                   pushad;

                   ;------------------------;
                   call НАЙТИ_БУФЕР_В_AX
                   jz  .ВЫХОД;
                   call СТРОКА_AX_ОЧИСТКА   ;
.ПОВТОР:
                   call ПРЕРЫВАНИЕ          ;
                   call ДЛИНА_СТРОКИ_AX_В_CX;
                   JZ  .ПОВТОР              ;
                   mov  si,ax               ;
                   add  si,cx               ;
                   dec  si;
                   cmp  [si],byte 13        ;
                   JnZ .ПОВТОР              ;
                   ;------------------------;
                   call ПРЕРЫВАНИЕ          ;
                   mov  [si],Byte 0         ;
                   call ЭЛЕ_ЗНА             ;
                   mov  si,ax               ;
                   call НАЙТИ_БУФЕР_В_AX    ;
                   call ЕСЛИ_СТРОКА_AX_ЧИСЛО_ФЛАГ_Z_1;
                   jnz .ЧИСЛО;
.СТРОКА:           call ЗАПИСАТЬ_ЗНАЧЕНИЕ_AX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО
                   jmp .ВЫХОД;
.ЧИСЛО:            call ПЕРЕВОДИТ_СТРОКУ_AX_В_ЧИСЛО_DX;
                   call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО

.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                   pushad;

                   ;------------------------;
                   call НАЙТИ_БУФЕР_В_AX
                   jz  .ВЫХОД;
                   call СТРОКА_AX_ОЧИСТКА   ;
.ПОВТОР:
                   call ПРЕРЫВАНИЕ          ;
                   call ДЛИНА_СТРОКИ_AX_В_CX;
                   JZ  .ПОВТОР              ;
                   mov  si,ax               ;
                   add  si,cx               ;
                   dec  si;
                   cmp  [si],byte 13        ;
                   JnZ .ПОВТОР              ;
                   ;------------------------;
                   call ПРЕРЫВАНИЕ          ;
                   mov  [si],Byte 0         ;
                   call ЭЛЕ_ЗНА             ;
                   mov  si,ax               ;
                   call НАЙТИ_БУФЕР_В_AX    ;
                   call ЕСЛИ_СТРОКА_AX_ЧИСЛО_ФЛАГ_Z_1;
                   jnz .ЧИСЛО;
.СТРОКА:           call ЗАПИСАТЬ_ЗНАЧЕНИЕ_AX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО
                   jmp .ВЫХОД;
.ЧИСЛО:            call ПЕРЕВОДИТ_СТРОКУ_AX_В_ЧИСЛО_DX;
                   call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО

.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
;------------------------------------------------------------------------------}

ВКОД_ТЕК_ЧПОРТ     :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   call ТИП_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА
                   cmp  ax,ТИП_ЧИСЛ;
                   jnz .ВЫХОД;
                   call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_DX
                   mov  ah,0;
                   in   al,dx
                   call ЗАПИСАТЬ_ЗНАЧЕНИЕ_AX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   call ТИП_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА
                   cmp  ax,ТИП_ЧИСЛ;
                   jnz .ВЫХОД;
                   call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_DX
                   mov  ah,0;
                   in   al,dx
                   call ЗАПИСАТЬ_ЗНАЧЕНИЕ_AX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   call ТИП_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА
                   cmp  eax,ТИП_ЧИСЛ;
                   jnz .ВЫХОД;
                   call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_DX
                   xor  eax,eax;
                   in   al,dx
                   call ЗАПИСАТЬ_ЗНАЧЕНИЕ_AX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
;------------------------------------------------------------------------------}
ВКОД_ТЕК_ЧПАМЯТЬ   :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   call ТИП_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА
                   cmp  ax,ТИП_ЧИСЛ;
                   jnz .ВЫХОД;
                   call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_DX
                   mov  si,dx;
                   mov  ax,[si]
                   call ЗАПИСАТЬ_ЗНАЧЕНИЕ_AX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   call ТИП_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА
                   cmp  ax,ТИП_ЧИСЛ;
                   jnz .ВЫХОД;
                   call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_DX
                   mov  si,dx;
                   mov  ax,[si]
                   call ЗАПИСАТЬ_ЗНАЧЕНИЕ_AX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   call ТИП_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА
                   cmp  eax,ТИП_ЧИСЛ;
                   jnz .ВЫХОД;
                   call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_DX
                   mov  esi,edx;
                   mov  eax,[esi]
                   call ЗАПИСАТЬ_ЗНАЧЕНИЕ_AX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО;
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
;------------------------------------------------------------------------------}

ВКОД_ТЕК_ЗПОРТ     :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                    pushad;
                    call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                    call ЭЛЕ_ВЛО; Переходим в скобку
                    ;----------------------------------;
                    call ТИП_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА;
                    cmp  ax,ТИП_ЧИСЛ; ПРоверка значений
                    jnz .ВЫХОД;
                    call ТИП_ВТОРОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА;
                    cmp  ax,ТИП_ЧИСЛ;
                    jnz .ВЫХОД;
                    ;-----------------------------------;
                    call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_DX
                    call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_AX
                    out  dx,al;
.ВЫХОД:
                    popad;
                    ret;
                    END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                    pushad;
                    call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                    call ЭЛЕ_ВЛО; Переходим в скобку
                    ;----------------------------------;
                    call ТИП_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА;
                    cmp  ax,ТИП_ЧИСЛ; ПРоверка значений
                    jnz .ВЫХОД;
                    call ТИП_ВТОРОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА;
                    cmp  ax,ТИП_ЧИСЛ;
                    jnz .ВЫХОД;
                    ;-----------------------------------;
                    call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_DX
                    call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_AX
                    out  dx,al;
.ВЫХОД:
                    popad;
                    ret;
                    END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                    pushad;
                    call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                    call ЭЛЕ_ВЛО; Переходим в скобку
                    ;----------------------------------;
                    call ТИП_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА;
                    cmp  ax,ТИП_ЧИСЛ; ПРоверка значений
                    jnz .ВЫХОД;
                    call ТИП_ВТОРОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА;
                    cmp  ax,ТИП_ЧИСЛ;
                    jnz .ВЫХОД;
                    ;-----------------------------------;
                    call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_DX
                    call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_AX
                    out  dx,al;
.ВЫХОД:
                    popad;
                    ret;
                    END IF;}
;--------------------------------------------------------------------}
ВКОД_ТЕК_ЗПАМЯТЬ   :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                    pushad;
                    call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                    call ЭЛЕ_ВЛО; Переходим в скобку
                    ;----------------------------------;
                    call ТИП_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА;
                    cmp  ax,ТИП_ЧИСЛ; ПРоверка значений
                    jnz .ВЫХОД;
                    call ТИП_ВТОРОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА;
                    cmp  ax,ТИП_ЧИСЛ;
                    jnz .ВЫХОД;
                    ;-----------------------------------;
                    call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_DX
                    call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_AX
                    Mov  si,dx;
                    mov  [si],al;
.ВЫХОД:
                    popad;
                    ret;
                    END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                    pushad;
                    call СОЗДАТЬ_СТРОКУ_SI_ДЛИНОЙ_1024_БАЙТ;
                    call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                    call ЭЛЕ_ВЛО;
                    call ДОБ_ЗНА_В_СТР_SI_ИЗ_ЭЛЕ_AX
                    call ВЫВОД_В_КОНСОЛЬ_СТРОКИ_SI
.ВЫХОД:             call УДАЛИТЬ_СТРОКУ_SI;
                    popad;
                    ret;
                    END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                    pushad;
                    call СОЗДАТЬ_СТРОКУ_SI_ДЛИНОЙ_1024_БАЙТ;
                    call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                    call ЭЛЕ_ВЛО;
                    call ДОБ_ЗНА_В_СТР_SI_ИЗ_ЭЛЕ_AX
                    call ВЫВОД_В_КОНСОЛЬ_СТРОКИ_SI
.ВЫХОД:             call УДАЛИТЬ_СТРОКУ_SI;
                    popad;
                    ret;
                    END IF;}
;--------------------------------------------------------------------}

ВКОД_ТЕК_ЗАПРОСИТЬ :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   call ТИП_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА
                   cmp  ax,ТИП_ЧИСЛ;
                   jz  .ВЫХОД;
                   call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_DX;
                   call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DX_РАЗ_DX;
                   call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                   pushad;


                   ;------------------------;
                   call НАЙТИ_БУФЕР_В_AX
                   jz  .ВЫХОД;
                   call СТРОКА_AX_ОЧИСТКА   ;
.ПОВТОР:
                   call ДЛИНА_СТРОКИ_AX_В_CX;
                   JZ  .ПОВТОР              ;
                   mov  si,ax               ;
                   add  si,cx               ;
                   dec  si;
                   cmp  [si],byte 13        ;
                   JnZ .ПОВТОР              ;
                   ;------------------------;
                   mov  [si],Byte 0         ;
                   call ЭЛЕ_ЗНА             ;
                   mov  si,ax               ;
                   call НАЙТИ_БУФЕР_В_AX    ;
                   call ЕСЛИ_СТРОКА_AX_ЧИСЛО_ФЛАГ_Z_1;
                   jnz .ЧИСЛО;
.СТРОКА:           call ЗАПИСАТЬ_ЗНАЧЕНИЕ_AX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО
                   jmp .ВЫХОД;
.ЧИСЛО:            call ПЕРЕВОДИТ_СТРОКУ_AX_В_ЧИСЛО_DX;
                   call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО

.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                   pushad;


                   ;------------------------;
                   call НАЙТИ_БУФЕР_В_AX
                   jz  .ВЫХОД;
                   call СТРОКА_AX_ОЧИСТКА   ;
.ПОВТОР:

                   call ДЛИНА_СТРОКИ_AX_В_CX;
                   JZ  .ПОВТОР              ;
                   mov  si,ax               ;
                   add  si,cx               ;
                   dec  si;
                   cmp  [si],byte 13        ;
                   JnZ .ПОВТОР              ;
                   ;------------------------;

                   mov  [si],Byte 0         ;
                   call ЭЛЕ_ЗНА             ;
                   mov  si,ax               ;
                   call НАЙТИ_БУФЕР_В_AX    ;
                   call ЕСЛИ_СТРОКА_AX_ЧИСЛО_ФЛАГ_Z_1;
                   jnz .ЧИСЛО;
.СТРОКА:           call ЗАПИСАТЬ_ЗНАЧЕНИЕ_AX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО
                   jmp .ВЫХОД;
.ЧИСЛО:            call ПЕРЕВОДИТ_СТРОКУ_AX_В_ЧИСЛО_DX;
                   call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО

.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
;------------------------------------------------------------------------------}
ВКОД_ТЕК_ОСВОБОДИТЬ:;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   call ТИП_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА
                   cmp  ax,ТИП_ЧИСЛ;
                   jz  .ВЫХОД;
                   call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_DX;
                   call ОСВОБОЖДЕНИЕ_УЧАСТКА_ПАМЯТИ_DX
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                   pushad;


                   ;------------------------;
                   call НАЙТИ_БУФЕР_В_AX
                   jz  .ВЫХОД;
                   call СТРОКА_AX_ОЧИСТКА   ;
.ПОВТОР:

                   call ДЛИНА_СТРОКИ_AX_В_CX;
                   JZ  .ПОВТОР              ;
                   mov  si,ax               ;
                   add  si,cx               ;
                   dec  si;
                   cmp  [si],byte 13        ;
                   JnZ .ПОВТОР              ;
                   ;------------------------;

                   mov  [si],Byte 0         ;
                   call ЭЛЕ_ЗНА             ;
                   mov  si,ax               ;
                   call НАЙТИ_БУФЕР_В_AX    ;
                   call ЕСЛИ_СТРОКА_AX_ЧИСЛО_ФЛАГ_Z_1;
                   jnz .ЧИСЛО;
.СТРОКА:           call ЗАПИСАТЬ_ЗНАЧЕНИЕ_AX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО
                   jmp .ВЫХОД;
.ЧИСЛО:            call ПЕРЕВОДИТ_СТРОКУ_AX_В_ЧИСЛО_DX;
                   call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО

.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                   pushad;


                   ;------------------------;
                   call НАЙТИ_БУФЕР_В_AX
                   jz  .ВЫХОД;
                   call СТРОКА_AX_ОЧИСТКА   ;
.ПОВТОР:

                   call ДЛИНА_СТРОКИ_AX_В_CX;
                   JZ  .ПОВТОР              ;
                   mov  si,ax               ;
                   add  si,cx               ;
                   dec  si;
                   cmp  [si],byte 13        ;
                   JnZ .ПОВТОР              ;
                   ;------------------------;

                   mov  [si],Byte 0         ;
                   call ЭЛЕ_ЗНА             ;
                   mov  si,ax               ;
                   call НАЙТИ_БУФЕР_В_AX    ;
                   call ЕСЛИ_СТРОКА_AX_ЧИСЛО_ФЛАГ_Z_1;
                   jnz .ЧИСЛО;
.СТРОКА:           call ЗАПИСАТЬ_ЗНАЧЕНИЕ_AX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО
                   jmp .ВЫХОД;
.ЧИСЛО:            call ПЕРЕВОДИТ_СТРОКУ_AX_В_ЧИСЛО_DX;
                   call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО

.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
;------------------------------------------------------------------------------}

ВКОД_ТЕК_РОДИТЕЛЬ  :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                   pushad;


                   ;------------------------;
                   call НАЙТИ_БУФЕР_В_AX
                   jz  .ВЫХОД;
                   call СТРОКА_AX_ОЧИСТКА   ;
.ПОВТОР:

                   call ДЛИНА_СТРОКИ_AX_В_CX;
                   JZ  .ПОВТОР              ;
                   mov  si,ax               ;
                   add  si,cx               ;
                   dec  si;
                   cmp  [si],byte 13        ;
                   JnZ .ПОВТОР              ;
                   ;------------------------;

                   mov  [si],Byte 0         ;
                   call ЭЛЕ_ЗНА             ;
                   mov  si,ax               ;
                   call НАЙТИ_БУФЕР_В_AX    ;
                   call ЕСЛИ_СТРОКА_AX_ЧИСЛО_ФЛАГ_Z_1;
                   jnz .ЧИСЛО;
.СТРОКА:           call ЗАПИСАТЬ_ЗНАЧЕНИЕ_AX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО
                   jmp .ВЫХОД;
.ЧИСЛО:            call ПЕРЕВОДИТ_СТРОКУ_AX_В_ЧИСЛО_DX;
                   call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО

.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                   pushad;


                   ;------------------------;
                   call НАЙТИ_БУФЕР_В_AX
                   jz  .ВЫХОД;
                   call СТРОКА_AX_ОЧИСТКА   ;
.ПОВТОР:

                   call ДЛИНА_СТРОКИ_AX_В_CX;
                   JZ  .ПОВТОР              ;
                   mov  si,ax               ;
                   add  si,cx               ;
                   dec  si;
                   cmp  [si],byte 13        ;
                   JnZ .ПОВТОР              ;
                   ;------------------------;
                   mov  [si],Byte 0         ;
                   call ЭЛЕ_ЗНА             ;
                   mov  si,ax               ;
                   call НАЙТИ_БУФЕР_В_AX    ;
                   call ЕСЛИ_СТРОКА_AX_ЧИСЛО_ФЛАГ_Z_1;
                   jnz .ЧИСЛО;
.СТРОКА:           call ЗАПИСАТЬ_ЗНАЧЕНИЕ_AX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО
                   jmp .ВЫХОД;
.ЧИСЛО:            call ПЕРЕВОДИТ_СТРОКУ_AX_В_ЧИСЛО_DX;
                   call ЗАПИСАТЬ_ЗНАЧЕНИЕ_DX_В_ЭЛЕМЕНТ_DI_КАК_ЧИСЛО

.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
;------------------------------------------------------------------------------}

ВКОД_ТЕК_РЕЗЕРВ1   :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                   pushad;
                   call НАЙТИ_КОНСОЛЬ_В_DI;
                   push DI
                   jz  .ВЫХОД; // Если Консоль отсуствует от выход
                   call ОКНО_ТЕК     ;
                   test ax,ax;
                   jz  .ВЫХОД; // Если текст отсуствует от выход
                   mov  di,ax;
                   .ЦИКЛ:;
                   mov  al,[di]
                   test al,al
                   jz  .ВЫХОД;
                   cmp  al,13;
                   jz  .КЦИКЛ;
                   call УДАЛИТЬ_БУКВУ_В_НАЧАЛЕ_СТРОКИ;
                   jmp .ЦИКЛ;
                   .КЦИКЛ:
                   call УДАЛИТЬ_БУКВУ_В_НАЧАЛЕ_СТРОКИ;
                   pop  di
                   call ОКНО_КУР_ВВЕР;
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                   pushad;
                   call НАЙТИ_КОНСОЛЬ_В_DI;
                   push DI
                   jz  .ВЫХОД; // Если Консоль отсуствует от выход
                   call ОКНО_ТЕК     ;
                   test ax,ax;
                   jz  .ВЫХОД; // Если текст отсуствует от выход
                   mov  di,ax;
                   .ЦИКЛ:;
                   mov  al,[di]
                   test al,al
                   jz  .ВЫХОД;
                   cmp  al,13;
                   jz  .КЦИКЛ;
                   call УДАЛИТЬ_БУКВУ_В_НАЧАЛЕ_СТРОКИ;
                   jmp .ЦИКЛ;
                   .КЦИКЛ:
                   call УДАЛИТЬ_БУКВУ_В_НАЧАЛЕ_СТРОКИ;
                   pop  di
                   call ОКНО_КУР_ВВЕР;
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                   pushad;
                   call НАЙТИ_КОНСОЛЬ_В_DI;
                   push eDI
                   jz  .ВЫХОД; // Если Консоль отсуствует от выход
                   call ОКНО_ТЕК     ;
                   test eax,eax;
                   jz  .ВЫХОД; // Если текст отсуствует от выход
                   mov  edi,eax;
                   .ЦИКЛ:;
                   mov  al,[edi]
                   test al,al
                   jz  .ВЫХОД;
                   cmp  al,13;
                   jz  .КЦИКЛ;
                   call УДАЛИТЬ_БУКВУ_В_НАЧАЛЕ_СТРОКИ;
                   jmp .ЦИКЛ;
                   .КЦИКЛ:
                   call УДАЛИТЬ_БУКВУ_В_НАЧАЛЕ_СТРОКИ;
                   pop  edi
                   call ОКНО_КУР_ВВЕР;
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
;------------------------------------------------------------------------------}
ВКОД_ТЕК_РЕЗЕРВ2   :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   ; КОД
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   ; КОД
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   ; КОД
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
;------------------------------------------------------------------------------}
ВКОД_ТЕК_РЕЗЕРВ3   :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   ; КОД
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   ; КОД
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   ; КОД
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
;------------------------------------------------------------------------------}
ВКОД_ТЕК_РЕЗЕРВ4   :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   ; КОД
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   ; КОД
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   ; КОД
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
;------------------------------------------------------------------------------}
ВКОД_ТЕК_РЕЗЕРВ5   :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   ; КОД
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   ; КОД
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   ; КОД
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
;------------------------------------------------------------------------------}
ВКОД_ТЕК_РЕЗЕРВ6   :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   ; КОД
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   ; КОД
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   ; КОД
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
;------------------------------------------------------------------------------}
ВКОД_ТЕК_РЕЗЕРВ7   :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   ; КОД
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   ; КОД
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                   pushad;
                   call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   ; КОД
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
;------------------------------------------------------------------------------}
ВКОД_ТЕК_РАЗРЕШИТЬ :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                   pushad;
                   ;call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   ;MOV [ЗАПРЕТ],byte 0;
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                   pushad;
                   ;call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   ; КОД
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                   pushad;
                   ; call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   ; КОД
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
;------------------------------------------------------------------------------}
ВКОД_ТЕК_ЗАПРЕТИТЬ :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                   pushad;
                   ; call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   ; MOV [ЗАПРЕТ],byte 1;
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                   pushad;
                   ; call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   ; КОД
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                   pushad;
                   ; call ВЫПОЛНИТЬ_ВЛ        ; // Запускаем элемнт на вполнение
                   ; КОД
.ВЫХОД:
                   popad;
                   ret;
                   END IF;}
;------------------------------------------------------------------------------}

;==============================================================================}
;{ ФУНКЦИИ ДЛЯ РАБОТЫ C ЭЛЕМЕНТАМИ                                      .

;---{ Чтение значения полей элементов

ЭЛЕ_ТИП:;{ Возвращает в AX Тип             элемента DI
IF  (ПЛАТФОРМА = ДОС)   ;{
        push di       ;
        xor  ax,ax    ;
        add  DI,ЭЛ_ТИП;
        mov  al,[di]  ;
        pop  di       ;
        ret           ;
        END IF        ;}
IF  (ПЛАТФОРМА = T16)   ;{
        push di       ;
        xor  ax,ax    ;
        add  DI,ЭЛ_ТИП;
        mov  al,[di]  ;
        pop  di       ;
        ret           ;
        END IF        ;}
IF  (ПЛАТФОРМА = T32)   ;{
        push edi        ;
        xor  eax,eax    ;
        add  EDI,ЭЛ_ТИП ;
        mov  al,[edi]   ;
        pop  edi        ;
        ret             ;
        END IF          ;}
;==============================================================================}
ЭЛЕ_ФУН:;{ Возвращает в AX Являеться ли    элемента DI функцией устанавливает флаг Z если это функция
IF  (ПЛАТФОРМА = ДОС)   ;{
        push di       ;
        xor  ax,ax    ;
        add  DI,ЭЛ_ФУН;
        mov  al,[di]  ;
        test al,al    ;
        pop  di       ;
        ret           ;
        END IF        ;}
IF  (ПЛАТФОРМА = T16)   ;{
        push di       ;
        xor  ax,ax    ;
        add  DI,ЭЛ_ФУН;
        mov  al,[di]  ;
        test al,al    ;
        pop  di       ;
        ret           ;
        END IF        ;}
IF  (ПЛАТФОРМА = T32)   ;{
        push edi       ;
        xor  eax,eax    ;
        add  eDI,ЭЛ_ФУН;
        mov  al,[edi]  ;
        test al,al    ;
        pop  edi       ;
        ret           ;
        END IF        ;}
;==============================================================================}
ЭЛЕ_ЗНА:;{ Возвращает в AX Значение        элемента DI
IF  (ПЛАТФОРМА = ДОС)   ;{
        push di       ;
        add  DI,ЭЛ_ЗНА;
        mov  ax,[di]  ;
        test ax,ax    ;
        pop  di       ;
        ret           ;
        END IF        ;}
IF  (ПЛАТФОРМА = T16)   ;{
        push di       ;
        add  DI,ЭЛ_ЗНА;
        mov  ax,[di]  ;
        test ax,ax    ;
        pop  di       ;
        ret           ;
        END IF        ;}
IF  (ПЛАТФОРМА = T32)   ;{
        push edi       ;
        add  eDI,ЭЛ_ЗНА;
        mov  eax,[edi] ;
        test eax,eax   ;
        pop  edi       ;
        ret            ;
        END IF         ;}
;==============================================================================}
ЭЛЕ_ПРЕ:;{ Возвращает в AX Предыдущий      элемент элемента DI
IF  (ПЛАТФОРМА = ДОС)   ;{
        push di       ;
        add  DI,ЭЛ_ПРЕ;
        mov  ax,[di]  ;
        test ax,ax    ;
        pop  di       ;
        ret           ;
        END IF        ;}
IF  (ПЛАТФОРМА = T16)   ;{
        push di       ;
        add  DI,ЭЛ_ПРЕ;
        mov  ax,[di]  ;
        test ax,ax    ;
        pop  di       ;
        ret           ;
        END IF        ;}
IF  (ПЛАТФОРМА = T32)   ;{
        push edi       ;
        add  eDI,ЭЛ_ПРЕ;
        mov  eax,[edi] ;
        test eax,eax   ;
        pop  edi       ;
        ret            ;
        END IF         ;}
;==============================================================================}
ЭЛЕ_СЛЕ:;{ Возвращает в AX Следующий       элемент элемента DI
IF  (ПЛАТФОРМА = ДОС)   ;{
        push di       ;
        add  DI,ЭЛ_СЛЕ;
        mov  ax,[di]  ;
        test ax,ax    ;
        pop  di       ;
        ret           ;
        END IF        ;}
IF  (ПЛАТФОРМА = T16)   ;{
        push di       ;
        add  DI,ЭЛ_СЛЕ;
        mov  ax,[di]  ;
        test ax,ax    ;
        pop  di       ;
        ret           ;
        END IF        ;}
IF  (ПЛАТФОРМА = T32)   ;{
        push edi       ;
        add  eDI,ЭЛ_СЛЕ;
        mov  eax,[edi] ;
        test eax,eax   ;
        pop  edi       ;
        ret            ;
        END IF         ;}
;==============================================================================}
ЭЛЕ_РОД:;{ Возвращает в AX Родительский    элемент элемента DI
IF  (ПЛАТФОРМА = ДОС)   ;{
        push di       ;
        add  DI,ЭЛ_РОД;
        mov  ax,[di]  ;
        test ax,ax    ;
        pop  di       ;
        ret           ;
        END IF        ;}
IF  (ПЛАТФОРМА = T16)   ;{
        push di       ;
        add  DI,ЭЛ_РОД;
        mov  ax,[di]  ;
        test ax,ax    ;
        pop  di       ;
        ret           ;
        END IF        ;}
IF  (ПЛАТФОРМА = T32)   ;{
        push edi       ;
        add  eDI,ЭЛ_РОД;
        mov  eax,[edi] ;
        test eax,eax   ;
        pop  edi       ;
        ret            ;
        END IF         ;}
;==============================================================================}
ЭЛЕ_ВЛО:;{ Возвращает в AX Первый вложеный элемент элемента DI
IF  (ПЛАТФОРМА = ДОС)   ;{
        push di       ;
        add  DI,ЭЛ_ВЛО;
        mov  ax,[di]  ;
        test ax,ax    ;
        pop  di       ;
        ret           ;
        ENd IF        ;}
IF  (ПЛАТФОРМА = T16)   ;{
        push di       ;
        add  DI,ЭЛ_ВЛО;
        mov  ax,[di]  ;
        test ax,ax    ;
        pop  di       ;
        ret           ;
        ENd IF        ;}
IF  (ПЛАТФОРМА = T32)   ;{
        push edi       ;
        add  eDI,ЭЛ_ВЛО;
        mov  eax,[edi] ;
        test eax,eax   ;
        pop  edi       ;
        ret            ;
        ENd IF         ;}
;==============================================================================}
ЭЛЕ_КОД:;{ Возвращает в AX Код             элемент элемента DI
IF  (ПЛАТФОРМА = ДОС)   ;{
        push di       ;
        add  DI,ЭЛ_КОД;
        mov  ax,[di]  ;
        test ax,ax    ;
        pop  di       ;
        ret           ;
        END IF        ;}
IF  (ПЛАТФОРМА = T16)   ;{
        push di       ;
        add  DI,ЭЛ_КОД;
        mov  ax,[di]  ;
        test ax,ax    ;
        pop  di       ;
        ret           ;
        END IF        ;}
IF  (ПЛАТФОРМА = T32)   ;{
        push edi       ;
        add  eDI,ЭЛ_КОД;
        mov  eax,[edi] ;
        test eax,eax   ;
        pop  edi       ;
        ret           ;
        END IF        ;}
;==============================================================================}

;---}
;---{ Вспомогательные функции


ЭЛЕ_ТИП_ЧИСЛО:;{ Если Тип элемента DI ЧИСЛО
IF  (ПЛАТФОРМА = ДОС)   ;{
        pushad          ;
        mov  dx,1       ; ))))))))
        call ЭЛЕ_ТИП    ;
        cmp  ax,ТИП_ЧИСЛ;
        jz  .ЧИСЛО      ;
        mov  dx,0       ; )))))))
.ЧИСЛО:
        test dx,dx      ; хи
        popad           ;
        ret             ;
        END IF          ;}
IF  (ПЛАТФОРМА = T16)   ;{
        pushad          ;
        mov  dx,1       ; ))))))))
        call ЭЛЕ_ТИП    ;
        cmp  ax,ТИП_ЧИСЛ;
        jz .ЧИСЛО       ;
        mov  dx,0       ; )))))))
.ЧИСЛО:
        test dx,dx      ; хи
        popad           ;
        ret             ;
        END IF          ;}
IF  (ПЛАТФОРМА = T32)   ;{
        pushad           ;
        mov  edx,1       ; ))))))))
        call ЭЛЕ_ТИП     ;
        cmp  eax,ТИП_ЧИСЛ;
        jz .ЧИСЛО        ;
        mov  dl,0        ; Оптимизация
.ЧИСЛО:
        test dl,dl       ; )))))
        popad            ;
        ret              ;
        END IF          ;}
;==============================================================================}
ЭЛЕ_ТИП_СТРОКА:;{ Если Тип элемента DI Строка
IF  (ПЛАТФОРМА = ДОС)   ;{
        pushad          ;
        mov  dx,1       ; ))))))))
        call ЭЛЕ_ТИП    ;
        cmp  ax,ТИП_СТРО;
        jz  .СТРОКА     ;
        mov  dx,0       ; )))))))
.СТРОКА:
        test dx,dx      ; хи
        popad           ;
        ret             ;
        END IF          ;}
IF  (ПЛАТФОРМА = T16)   ;{
        pushad          ;
        mov  dx,1       ; ))))))))
        call ЭЛЕ_ТИП    ;
        cmp  ax,ТИП_СТРО;
        jz .СТРОКА      ;
        mov  dx,0       ; )))))))
.СТРОКА:
        test dx,dx      ; хи
        popad           ;
        ret             ;
        END IF          ;}
IF  (ПЛАТФОРМА = T32)   ;{
        pushad           ;
        mov  edx,1       ; ))))))))
        call ЭЛЕ_ТИП     ;
        cmp  eax,ТИП_СТРО;
        jz .СТРОКА       ;
        mov  dl,0        ; Оптимизация
.СТРОКА:
        test dl,dl       ; )))))
        popad            ;
        ret              ;
        END IF          ;}
;==============================================================================}


;---}

СОЗДАТЬ_КОРНЕВОЙ_ЭЛЕМЕНТ:;{ Создание коневого элемента
IF  (ПЛАТФОРМА = ДОС)   ;{
                    pushad;
                    mov  SI,ИМЯ_КОР   ;// Указывает адрес строки с именем котрое нужно присвоимть элементу
                    mov  DI,0         ;// Указывает в каком элементе создаем элемент
                    mov  al,0         ;
                    mov  AH,0         ;// Указываем Являетсья ли элмеент функцией
                    mov  bx,0         ;// Указываем значение
                    Call ЭЛЕ_СОЗДАТЬ  ;// Создаем элемент
                    mov  [КОР_ЭЛЕМ],di;// Записываем адрес созданого элемента
                    popad;
                    ret;
                    END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                    pushad;
                    mov  SI,ИМЯ_КОР   ;// Указывает адрес строки с именем котрое нужно присвоимть элементу
                    mov  DI,0         ;// Указывает в каком элементе создаем элемент
                    mov  al,0         ;
                    mov  AH,0         ;// Указываем Являетсья ли элмеент функцией
                    mov  bx,0         ;// Указываем значение
                    Call ЭЛЕ_СОЗДАТЬ  ;// Создаем элемент
                    mov  [КОР_ЭЛЕМ],di;// Записываем адрес созданого элемента
                    popad;
                    ret;
                    END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                    pushad;
                    mov  ESI,ИМЯ_КОР   ;// Указывает адрес строки с именем котрое нужно присвоимть элементу
                    mov  EDI,0         ;// Указывает в каком элементе создаем элемент
                    mov  al,0          ;
                    mov  AH,0          ;// Указываем Являетсья ли элмеент функцией
                    mov  Ebx,0         ;// Указываем значение
                    Call ЭЛЕ_СОЗДАТЬ   ;// Создаем элемент
                    mov  [КОР_ЭЛЕМ],Edi;// Записываем адрес созданого элемента
                    popad;
                    ret;
                    END IF;}
ИМЯ_КОР: DB "КОР_ЭЛЕ",0;
;==============================================================================}
ЭЛЕ_СОЗДАТЬ_КОД :;{ возвращает адрес внось созданого элемента в DI Создание элемента с именем SI-адрес строки с именем элемента AL - Тип элемента Ah Показатель функции DI- адрес того элемента в котрый добвавлем BX- Значение аааа
IF  (ПЛАТФОРМА = ДОС)   ;{
            pushad               ;{ ОПИСАНИЕ
            ; Создает новый элемент --------------------------------------------
            ; DI - Адрес элемента В котром ьудет создан новый элемнет если 0
            ;      то не в каком просто создаеться элемнт
            ; SI - Имя элемента создаеться копия Строки SI и задаеться как имя
            ; AL - Это тип создаваемого Элемента
            ; AH - Участвует ли элемнт в поиске
            ; BX - Значение элемента Либо адрес строки либо число
            ;------------------------------------------------------------------}
            ;------------------------;// Проверю что я тут попереломал ))))
            mov   DX,16              ;// Выделяем участок памяти под элемент
            call  ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DX_РАЗ_DX;
            call  ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI;// Добавляем  Вот тут нужно переделать
            ;------------------------;

            mov   cx,si
            mov   si,dx            ;
            add   si,ЭЛ_КОД        ;
            mov  [si],cx           ;




            ;----------------------;
            mov   si,dx            ;
            add   si,ЭЛ_ЗНА        ;
            mov  [si],bx           ;
            ;----------------------;
            mov   si,dx            ;// Указываем тип элемента
            add   si,ЭЛ_ТИП        ;
            mov  [si],al           ;
            ;--------------------;
            mov   si,dx            ;// Указываем являеться ли элемент функцией
            add   si,ЭЛ_ФУН        ;
            mov  [si],ah           ;
            ;--------------------;

            pop   SI               ;
            push  dX               ;
            popad                  ;
            ret                    ;
            END IF                 ;}
IF  (ПЛАТФОРМА = T16)   ;{
            pushad               ;{ ОПИСАНИЕ
            ; Создает новый элемент --------------------------------------------
            ; DI - Адрес элемента В котром ьудет создан новый элемнет если 0
            ;      то не в каком просто создаеться элемнт
            ; SI - Имя элемента создаеться копия Строки SI и задаеться как имя
            ; AL - Это тип создаваемого Элемента
            ; AH - Участвует ли элемнт в поиске
            ; BX - Значение элемента Либо адрес строки либо число
            ;------------------------------------------------------------------}
            ;------------------------;// Проверю что я тут попереломал ))))
            mov   DX,16              ;// Выделяем участок памяти под элемент
            call  ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DX_РАЗ_DX;
            call  ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI;// Добавляем  Вот тут нужно переделать
            ;------------------------;

            mov   cx,si
            mov   si,dx            ;
            add   si,ЭЛ_КОД        ;
            mov  [si],cx           ;




            ;----------------------;
            mov   si,dx            ;
            add   si,ЭЛ_ЗНА        ;
            mov  [si],bx           ;
            ;----------------------;
            mov   si,dx            ;// Указываем тип элемента
            add   si,ЭЛ_ТИП        ;
            mov  [si],al           ;
            ;--------------------;
            mov   si,dx            ;// Указываем являеться ли элемент функцией
            add   si,ЭЛ_ФУН        ;
            mov  [si],ah           ;
            ;--------------------;

            pop   SI               ;
            push  dX               ;
            popad                  ;
            ret                    ;
            END IF                 ;}
IF  (ПЛАТФОРМА = T32)   ;{
            pushad               ;{ ОПИСАНИЕ
            ; Создает новый элемент --------------------------------------------
            ; DI - Адрес элемента В котром ьудет создан новый элемнет если 0
            ;      то не в каком просто создаеться элемнт
            ; SI - Имя элемента создаеться копия Строки SI и задаеться как имя
            ; AL - Это тип создаваемого Элемента
            ; AH - Участвует ли элемнт в поиске
            ; BX - Значение элемента Либо адрес строки либо число
            ;------------------------------------------------------------------}
            ;------------------------;// Проверю что я тут попереломал ))))
            mov   eDX,28              ;// Выделяем участок памяти под элемент
            call  ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DX_РАЗ_DX;
            call  ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI;// Добавляем  Вот тут нужно переделать
            ;------------------------;

            mov   ecx,esi
            mov   esi,edx            ;
            add   esi,ЭЛ_КОД        ;
            mov  [esi],ecx           ;




            ;----------------------;
            mov   esi,edx            ;
            add   esi,ЭЛ_ЗНА        ;
            mov  [esi],ebx           ;
            ;----------------------;
            mov   esi,edx            ;// Указываем тип элемента
            add   esi,ЭЛ_ТИП        ;
            mov  [esi],al           ;
            ;--------------------;
            mov   esi,edx            ;// Указываем являеться ли элемент функцией
            add   esi,ЭЛ_ФУН        ;
            mov  [esi],ah           ;
            ;--------------------;

            pop   eSI               ;
            push  edX               ;
            popad                  ;
            ret                    ;
            END IF                 ;}
;==============================================================================}
ЭЛЕ_ОДИН    :;{ Если в элементе 1 вложеный элемент возвращает 1 если ноль или больше 1 то 0 возвращет
IF  (ПЛАТФОРМА = ДОС)   ;{
       pushad;
       test di,di;
       jz  .ЛОЖ;
       call ЭЛЕ_ВЛО;
       jz  .ЛОЖ;
       mov  di,ax;
       call ЭЛЕ_СЛЕ;
       jnz .ЛОЖ;
       mov  ax,1;
       test ax,ax;
       jmp .ВЫХОД;
.ЛОЖ:  mov  ax,0;
       test ax,ax;
.ВЫХОД:
       popad ;
       ret   ;
       END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
       pushad;
       test di,di;
       jz  .ЛОЖ;
       call ЭЛЕ_ВЛО;
       jz  .ЛОЖ;
       mov  di,ax;
       call ЭЛЕ_СЛЕ;
       jnz .ЛОЖ;
       mov  ax,1;
       test ax,ax;
       jmp .ВЫХОД;
.ЛОЖ:  mov  ax,0;
       test ax,ax;
.ВЫХОД:
       popad ;
       ret   ;
       END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
       pushad;
       test edi,edi;
       jz  .ЛОЖ;
       call ЭЛЕ_ВЛО;
       jz  .ЛОЖ;
       mov  edi,eax;
       call ЭЛЕ_СЛЕ;
       jnz .ЛОЖ;
       mov  eax,1;
       test eax,eax;
       jmp .ВЫХОД;
.ЛОЖ:  mov  eax,0;
       test eax,eax;
.ВЫХОД:
       popad ;
       ret   ;
       END IF;}
;}
ЭЛЕ_СОЗДАТЬ :;{ возвращает адрес внось созданого элемента в DI Создание элемента с именем SI-адрес строки с именем элемента AL - Тип элемента Ah Показатель функции DI- адрес того элемента в котрый добвавлем BX- Значение аааа
IF  (ПЛАТФОРМА = ДОС)   ;{
            pushad               ;{ ОПИСАНИЕ
            ; Создает новый элемент --------------------------------------------
            ; DI - Адрес элемента В котром ьудет создан новый элемнет если 0
            ;      то не в каком просто создаеться элемнт
            ; SI - Имя элемента создаеться копия Строки SI и задаеться как имя
            ; AL - Это тип создаваемого Элемента
            ; AH - Участвует ли элемнт в поиске
            ; BX - Значение элемента Либо адрес строки либо число
            ;------------------------------------------------------------------}
            ;------------------------;// Проверю что я тут попереломал ))))
            mov   DX,16              ;// Выделяем участок памяти под элемент
            call  ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DX_РАЗ_DX;
            call  ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI;// Добавляем  Вот тут нужно переделать
            ;------------------------;

            mov   cx,si
            call  СЛО_В_КОДCX      ;
            mov   si,dx            ;
            add   si,ЭЛ_КОД        ;
            mov  [si],cx           ;

            ;----------------------;
            mov   si,dx            ;
            add   si,ЭЛ_ЗНА        ;
            mov  [si],bx           ;
            ;----------------------;
            mov   si,dx            ;// Указываем тип элемента
            add   si,ЭЛ_ТИП        ;
            mov  [si],al           ;
            ;--------------------;
            mov   si,dx            ;// Указываем являеться ли элемент функцией
            add   si,ЭЛ_ФУН        ;
            mov  [si],ah           ;
            ;--------------------;

            pop   SI               ;
            push  dX               ;
            popad                  ;
            ret                    ;
            END IF                 ;}
IF  (ПЛАТФОРМА = T16)   ;{
            pushad               ;{ ОПИСАНИЕ
            ; Создает новый элемент --------------------------------------------
            ; DI - Адрес элемента В котром ьудет создан новый элемнет если 0
            ;      то не в каком просто создаеться элемнт
            ; SI - Имя элемента создаеться копия Строки SI и задаеться как имя
            ; AL - Это тип создаваемого Элемента
            ; AH - Участвует ли элемнт в поиске
            ; BX - Значение элемента Либо адрес строки либо число
            ;------------------------------------------------------------------}
            ;------------------------;// Проверю что я тут попереломал ))))
            mov   DX,16              ;// Выделяем участок памяти под элемент
            call  ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DX_РАЗ_DX;
            call  ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI;// Добавляем  Вот тут нужно переделать
            ;------------------------;

            mov   cx,si
            call  СЛО_В_КОДCX      ;
            mov   si,dx            ;
            add   si,ЭЛ_КОД        ;
            mov  [si],cx           ;

            ;----------------------;
            mov   si,dx            ;
            add   si,ЭЛ_ЗНА        ;
            mov  [si],bx           ;
            ;----------------------;
            mov   si,dx            ;// Указываем тип элемента
            add   si,ЭЛ_ТИП        ;
            mov  [si],al           ;
            ;--------------------;
            mov   si,dx            ;// Указываем являеться ли элемент функцией
            add   si,ЭЛ_ФУН        ;
            mov  [si],ah           ;
            ;--------------------;

            pop   SI               ;
            push  dX               ;
            popad                  ;
            ret                    ;
            END IF                 ;}
IF  (ПЛАТФОРМА = T32)   ;{
            pushad               ;{ ОПИСАНИЕ
            ; Создает новый элемент --------------------------------------------
            ; DI - Адрес элемента В котром ьудет создан новый элемнет если 0
            ;      то не в каком просто создаеться элемнт
            ; SI - Имя элемента создаеться копия Строки SI и задаеться как имя
            ; AL - Это тип создаваемого Элемента
            ; AH - Участвует ли элемнт в поиске
            ; BX - Значение элемента Либо адрес строки либо число
            ;------------------------------------------------------------------}
            ;------------------------;// Проверю что я тут попереломал ))))
            mov   EDX,28              ;// Выделяем участок памяти под элемент
            call  ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DX_РАЗ_DX;
            call  ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI;// Добавляем  Вот тут нужно переделать
            ;------------------------;

            mov   ecx,esi
            call  СЛО_В_КОДCX      ;
            mov   esi,edx          ;
            add   esi,ЭЛ_КОД       ;
            mov  [esi],ecx         ;

            ;----------------------;
            mov   esi,edx          ;
            add   esi,ЭЛ_ЗНА       ;
            mov  [esi],ebx         ;
            ;----------------------;
            mov   esi,edx          ;// Указываем тип элемента
            add   esi,ЭЛ_ТИП       ;
            mov  [esi],al          ;
            ;----------------------;
            mov   esi,edx          ;// Указываем являеться ли элемент функцией
            add   esi,ЭЛ_ФУН       ;
            mov  [esi],ah          ;
            ;----------------------;

            pop   eSI              ;
            push  edX              ;
            popad                  ;
            ret                    ;
            END IF                 ;}
;==============================================================================}
ЭЛЕ_КОПИЯ_ПА:;{ Копирвоание параметров Функции DX В DI
IF  (ПЛАТФОРМА = ДОС)   ;{
             pushad;

             ;-----------;
             mov  ax,dx  ;
             call ЭЛЕ_ЧИТ_СКО_ИЗ_ЭЛЕ_AX;
             jz  .ВЫХОД  ;
             mov  bx,ax  ;
             ;-----------;
             mov  ax,di  ;
             call ЭЛЕ_ЧИТ_СКО_ИЗ_ЭЛЕ_AX;
             jz  .ВЫХОД  ;
             mov  di,ax  ;

.ЦИКЛ:
             test di,di  ;
             jz  .ВЫХОД  ;
             test bx,bx  ;
             jz  .ВЫХОД  ;

             call ПРИСВОИТЬ_ЗНА_В_ЭЛЕ_DI_ИЗ_ЭЛЕ_BX;

             call ЭЛЕ_СЛЕ      ;
             mov  di,ax;

             push di;
             mov  di,bx;
             call ЭЛЕ_СЛЕ      ;
             mov  bx,ax;
             pop  di;
             jmp .ЦИКЛ;

.КЦИКЛА:

.ВЫХОД:
             popad;
             ret;
             END iF;}
IF  (ПЛАТФОРМА = T16)   ;{
             pushad;

             ;-----------;
             mov  ax,dx  ;
             call ЭЛЕ_ЧИТ_СКО_ИЗ_ЭЛЕ_AX;
             jz  .ВЫХОД  ;
             mov  bx,ax  ;
             ;-----------;
             mov  ax,di  ;
             call ЭЛЕ_ЧИТ_СКО_ИЗ_ЭЛЕ_AX;
             jz  .ВЫХОД  ;
             mov  di,ax  ;

.ЦИКЛ:
             test di,di  ;
             jz  .ВЫХОД  ;
             test bx,bx  ;
             jz  .ВЫХОД  ;

             call ПРИСВОИТЬ_ЗНА_В_ЭЛЕ_DI_ИЗ_ЭЛЕ_BX;

             call ЭЛЕ_СЛЕ      ;
             mov  di,ax;

             push di;
             mov  di,bx;
             call ЭЛЕ_СЛЕ      ;
             mov  bx,ax;
             pop  di;
             jmp .ЦИКЛ;

.КЦИКЛА:

.ВЫХОД:
             popad;
             ret;
             END iF;}
IF  (ПЛАТФОРМА = T32)   ;{
             pushad;

             ;-----------;
             mov  eax,edx  ;
             call ЭЛЕ_ЧИТ_СКО_ИЗ_ЭЛЕ_AX;
             jz  .ВЫХОД  ;
             mov  ebx,eax  ;
             ;-----------;
             mov  eax,edi  ;
             call ЭЛЕ_ЧИТ_СКО_ИЗ_ЭЛЕ_AX;
             jz  .ВЫХОД  ;
             mov  edi,eax  ;

.ЦИКЛ:
             test edi,edi  ;
             jz  .ВЫХОД  ;
             test ebx,ebx  ;
             jz  .ВЫХОД  ;

             call ПРИСВОИТЬ_ЗНА_В_ЭЛЕ_DI_ИЗ_ЭЛЕ_BX;

             call ЭЛЕ_СЛЕ      ;
             mov  edi,eax;

             push edi;
             mov  edi,ebx;
             call ЭЛЕ_СЛЕ      ;
             mov  ebx,eax;
             pop  edi;
             jmp .ЦИКЛ;

.КЦИКЛА:

.ВЫХОД:
             popad;
             ret;
             END iF;}
;==============================================================================}
ЭЛЕ_РОДИТЕЛЬ:;{ Возвращает в регистре DI Адрес родительского элемента в DI сразу устанавливает флаг Z=0 если NIL
IF  (ПЛАТФОРМА = ДОС)   ;{
             add  DI,ЭЛ_РОД;// ПРибавляем к адресу элемента DI смещение для чтения РОдителя
             mov  DI,[DI]  ;// ЧИтаем адрес родителя
             test DI,DI    ;// ПРоверяем есть ли родитель устанавливаем флаг
             ret           ;// Сразу устанвливает флаг если NIL
             END iF        ;}
IF  (ПЛАТФОРМА = T16)   ;{
             add  DI,ЭЛ_РОД;// ПРибавляем к адресу элемента DI смещение для чтения РОдителя
             mov  DI,[DI]  ;// ЧИтаем адрес родителя
             test DI,DI    ;// ПРоверяем есть ли родитель устанавливаем флаг
             ret           ;// Сразу устанвливает флаг если NIL
             END iF        ;}
IF  (ПЛАТФОРМА = T32)   ;{
             add  EDI,ЭЛ_РОД;// ПРибавляем к адресу элемента DI смещение для чтения РОдителя
             mov  EDI,[EDI]  ;// ЧИтаем адрес родителя
             test EDI,EDI    ;// ПРоверяем есть ли родитель устанавливаем флаг
             ret           ;// Сразу устанвливает флаг если NIL
             END iF        ;}
;==============================================================================}
ЭЛЕ_ПОСЛЕД  :;{ Находит последний элемент в списке элемента DI
IF  (ПЛАТФОРМА = ДОС)   ;{
            pushad       ;
            mov  si,0    ;// ПО умолчанию резальтат равен 0 то биш нету вложеных елемнтов а следователоьно и нету последнего элемента
            call ЭЛЕ_ВЛО ;// открываем первый элемент вложеного списка в элементе Di В регистр AX
.ЦИКЛ:
            TEST AX,AX   ;// Проверяем не достигли ли мы нулевого элемента
            JZ  .КЦИКЛ   ;// Если дрстигли нулевой элемент то выходим из списка
            Mov  Si,ax   ;// Запоминаем последний не нуллевой элемент в списке
            Mov  di,ax   ;
            call ЭЛЕ_СЛЕ ;// Переходим к следующему элементу
            Jmp .ЦИКЛ    ;
.КЦИКЛ:
            pop  di      ;
            push SI      ;// Возврвщаемый элемент храниться в SI но возвпращаеться в регистре DI
            test si,si   ;
            popad        ;
            ret          ;
            END iF       ;}
IF  (ПЛАТФОРМА = T16)   ;{
            pushad       ;
            mov  si,0    ;// ПО умолчанию резальтат равен 0 то биш нету вложеных елемнтов а следователоьно и нету последнего элемента
            call ЭЛЕ_ВЛО ;// открываем первый элемент вложеного списка в элементе Di В регистр AX
.ЦИКЛ:
            TEST AX,AX   ;// Проверяем не достигли ли мы нулевого элемента
            JZ  .КЦИКЛ   ;// Если дрстигли нулевой элемент то выходим из списка
            Mov  Si,ax   ;// Запоминаем последний не нуллевой элемент в списке
            Mov  di,ax   ;
            call ЭЛЕ_СЛЕ ;// Переходим к следующему элементу
            Jmp .ЦИКЛ    ;
.КЦИКЛ:
            pop  di      ;
            push SI      ;// Возврвщаемый элемент храниться в SI но возвпращаеться в регистре DI
            test si,si   ;
            popad        ;
            ret          ;
            END iF       ;}
IF  (ПЛАТФОРМА = T32)   ;{
            pushad       ;
            mov  esi,0    ;// ПО умолчанию резальтат равен 0 то биш нету вложеных елемнтов а следователоьно и нету последнего элемента
            call ЭЛЕ_ВЛО ;// открываем первый элемент вложеного списка в элементе Di В регистр AX
.ЦИКЛ:
            TEST eAX,eAX ;// Проверяем не достигли ли мы нулевого элемента
            JZ  .КЦИКЛ   ;// Если дрстигли нулевой элемент то выходим из списка
            Mov  eSi,eax   ;// Запоминаем последний не нуллевой элемент в списке
            Mov  edi,eax   ;
            call ЭЛЕ_СЛЕ ;// Переходим к следующему элементу
            Jmp .ЦИКЛ    ;
.КЦИКЛ:
            pop  edi      ;
            push eSI      ;// Возврвщаемый элемент храниться в SI но возвпращаеться в регистре DI
            test esi,esi   ;
            popad        ;
            ret          ;
            END iF       ;}
;==============================================================================}
ЭЛЕ_НАЗАД   :;{ Перемещаеться к предыдущему элементу если его нет поднимаеться на верх по иирархии
IF  (ПЛАТФОРМА = ДОС)   ;{
         push ax;
         test di,di  ;
         jz  .ДАЛЕЕ  ;
         call ЭЛЕ_ПРЕ;
         test ax,ax  ;
         jnz .ДАЛЕЕ  ;
         call ЭЛЕ_РОД;
.ДАЛЕЕ:  mov  di,ax  ;
         test di,di  ;
         pop ax      ;
         ret         ;
         END IF      ;}
IF  (ПЛАТФОРМА = T16)   ;{
         push ax;
         test di,di  ;
         jz  .ДАЛЕЕ  ;
         call ЭЛЕ_ПРЕ;
         test ax,ax  ;
         jnz .ДАЛЕЕ  ;
         call ЭЛЕ_РОД;
.ДАЛЕЕ:  mov  di,ax  ;
         test di,di  ;
         pop ax      ;
         ret         ;
         END IF      ;}
IF  (ПЛАТФОРМА = T32)   ;{
         push eax;
         test edi,edi  ;
         jz  .ДАЛЕЕ  ;
         call ЭЛЕ_ПРЕ;
         test eax,eax  ;
         jnz .ДАЛЕЕ  ;
         call ЭЛЕ_РОД;
.ДАЛЕЕ:  mov  edi,eax  ;
         test edi,edi  ;
         pop eax      ;
         ret         ;
         END IF      ;}
;}
ЭЛЕ_УДАЛИТЬ :;{ Удаяляет элемент DI из списка
IF  (ПЛАТФОРМА = ДОС)   ;{
            pushad
            ;-----------;
            call ЭЛЕ_ПРЕ  ;// CX Запоминаем предыдущий элемент удаляемлого элемента в регистр
            mov  cx,ax;   ;
            ;-----------;

            ;-----------;
            call ЭЛЕ_СЛЕ  ;// DX Запоминаем предыдущий элемент удаляемлого элемента в регистр
            mov  Dx,ax;   ;
            ;-----------;

            ;------------
            test cx,cx    ;// Записываем в предыдущем элементе следуюший элемент
            jz  .НЕТУ1    ;// Проверяем есть ли вообще предыдущий элмеент
            Mov  Si,Cx    ;
            add  Si,ЭЛ_СЛЕ;
            Mov [si],dx   ;
            ;------------

.НЕТУ1:     ;------------
            test dx,dx    ;// Записываем в Cледующем элементе предыдущимй
            jz  .НЕТУ2    ;// ПРоверяем если вообще следующий элемент
            mov  si,dx    ;
            add  si,ЭЛ_ПРЕ;
            mov [si],cx   ;
            ;------------

.НЕТУ2:     ;-------------// Настройка родительского элемента

            call ЭЛЕ_РОД   ;// Читаем адрес родительского эдемента
            test ax,ax     ;// Проверяем есть ли вобще родительский элемент
            Jz  .НЕТУ3     ;// Если нету родительского элемента то идем дальше

            add  ax,ЭЛ_ВЛО ;// Читем поле блок родительского элменета
            mov  si,ax     ;
            mov  ax,[si]   ;// ПРочитали значение поля BLO родительского элменета


            cmp  ax,di     ;// ПРоверяем не являемся ли мы первым элментом вложеного спсика в родительском элементе
            Jnz .НЕТУ3     ;// Если мы не указаны в родительском элементе идем дальше
            mov [si],dx    ;// сли указаны то записываем след элемент вместо себя

.НЕТУ3:      ;// Отстыковка элемнта
            mov Si,di      ;// Востанавливаем значение удаляемог элмента
            add SI,ЭЛ_РОД  ;
            mov word[si],0 ;// остоеденяем родительский элемент
            inc Si         ;
            inc si         ;// Переходим к полю предыдущий элемент
            mov word[si],0 ;// остоеденяем предыдущий элемент
            inc Si         ;
            inc si         ;// Переходим к полю следующий  элемент
            mov word[si],0 ;// остоеденяем Следующий  элемент


.ВЫХОД:
            popad
            ret;
            END IF         ;}
IF  (ПЛАТФОРМА = T16)   ;{
            pushad
            ;-----------;
            call ЭЛЕ_ПРЕ  ;// CX Запоминаем предыдущий элемент удаляемлого элемента в регистр
            mov  cx,ax;   ;
            ;-----------;

            ;-----------;
            call ЭЛЕ_СЛЕ  ;// DX Запоминаем предыдущий элемент удаляемлого элемента в регистр
            mov  Dx,ax;   ;
            ;-----------;

            ;------------
            test cx,cx    ;// Записываем в предыдущем элементе следуюший элемент
            jz  .НЕТУ1    ;// Проверяем есть ли вообще предыдущий элмеент
            Mov  Si,Cx    ;
            add  Si,ЭЛ_СЛЕ;
            Mov [si],dx   ;
            ;------------

.НЕТУ1:     ;------------
            test dx,dx    ;// Записываем в Cледующем элементе предыдущимй
            jz  .НЕТУ2    ;// ПРоверяем если вообще следующий элемент
            mov  si,dx    ;
            add  si,ЭЛ_ПРЕ;
            mov [si],cx   ;
            ;------------

.НЕТУ2:     ;-------------// Настройка родительского элемента

            call ЭЛЕ_РОД   ;// Читаем адрес родительского эдемента
            test ax,ax     ;// Проверяем есть ли вобще родительский элемент
            Jz  .НЕТУ3     ;// Если нету родительского элемента то идем дальше

            add  ax,ЭЛ_ВЛО ;// Читем поле блок родительского элменета
            mov  si,ax     ;
            mov  ax,[si]   ;// ПРочитали значение поля BLO родительского элменета


            cmp  ax,di     ;// ПРоверяем не являемся ли мы первым элментом вложеного спсика в родительском элементе
            Jnz .НЕТУ3     ;// Если мы не указаны в родительском элементе идем дальше
            mov [si],dx    ;// сли указаны то записываем след элемент вместо себя

.НЕТУ3:      ;// Отстыковка элемнта
            mov Si,di      ;// Востанавливаем значение удаляемог элмента
            add SI,ЭЛ_РОД  ;
            mov word[si],0 ;// остоеденяем родительский элемент
            inc Si         ;
            inc si         ;// Переходим к полю предыдущий элемент
            mov word[si],0 ;// остоеденяем предыдущий элемент
            inc Si         ;
            inc si         ;// Переходим к полю следующий  элемент
            mov word[si],0 ;// остоеденяем Следующий  элемент


.ВЫХОД:
            popad
            ret;
            END IF         ;}
IF  (ПЛАТФОРМА = T32)   ;{
            pushad
            ;-----------;
            call ЭЛЕ_ПРЕ  ;// CX Запоминаем предыдущий элемент удаляемлого элемента в регистр
            mov  ecx,eax;   ;
            ;-----------;

            ;-----------;
            call ЭЛЕ_СЛЕ  ;// DX Запоминаем предыдущий элемент удаляемлого элемента в регистр
            mov  eDx,eax;   ;
            ;-----------;

            ;------------
            test ecx,ecx    ;// Записываем в предыдущем элементе следуюший элемент
            jz  .НЕТУ1    ;// Проверяем есть ли вообще предыдущий элмеент
            Mov  eSi,eCx    ;
            add  eSi,ЭЛ_СЛЕ;
            Mov [esi],edx   ;
            ;------------

.НЕТУ1:     ;------------
            test edx,edx    ;// Записываем в Cледующем элементе предыдущимй
            jz  .НЕТУ2    ;// ПРоверяем если вообще следующий элемент
            mov  esi,edx    ;
            add  esi,ЭЛ_ПРЕ;
            mov [esi],ecx   ;
            ;------------

.НЕТУ2:     ;-------------// Настройка родительского элемента

            call ЭЛЕ_РОД   ;// Читаем адрес родительского эдемента
            test eax,eax     ;// Проверяем есть ли вобще родительский элемент
            Jz  .НЕТУ3     ;// Если нету родительского элемента то идем дальше

            add  eax,ЭЛ_ВЛО ;// Читем поле блок родительского элменета
            mov  esi,eax     ;
            mov  eax,[esi]   ;// ПРочитали значение поля BLO родительского элменета


            cmp  eax,edi     ;// ПРоверяем не являемся ли мы первым элментом вложеного спсика в родительском элементе
            Jnz .НЕТУ3     ;// Если мы не указаны в родительском элементе идем дальше
            mov [esi],edx    ;// сли указаны то записываем след элемент вместо себя

.НЕТУ3:      ;// Отстыковка элемнта
            mov  eSi,edi      ;// Востанавливаем значение удаляемог элмента
            add  eSI,ЭЛ_РОД  ;
            mov [esi],DWORD 0 ;// остоеденяем родительский элемент
            mov  eSi,edi      ;// Востанавливаем значение удаляемог элмента
            add  eSI,ЭЛ_ПРЕ  ;
            mov [esi],DWORD 0 ;// остоеденяем предыдущий элемент
            mov  eSi,edi      ;// Востанавливаем значение удаляемог элмента
            add  eSI,ЭЛ_СЛЕ  ;
            mov [Esi],DWORD 0 ;// остоеденяем Следующий  элемент


.ВЫХОД:
            popad
            ret;
            END IF         ;}
;==============================================================================}
ЭЛЕ_КОПИЯ_ВС:;{ Копию элемнта Di и всех вложеных элемнтов и назначать родителя DX созданая копия возвращеться  в DI
IF  (ПЛАТФОРМА = ДОС)   ;{
            pushad
            test di,di    ;
            jnz .ДАЛЕЕ    ;
            mov  dx,0     ;
            jmp .ВЫХОД    ;

.ДАЛЕЕ:

            push di       ;
            call ЭЛЕ_КОПИЯ;
            mov  dx,di    ;
            pop  di       ;

            call ЭЛЕ_ВЛО  ;

.ЦИКЛ:
            test ax,ax       ;
            jz  .КЦИКЛ       ;
            mov  di,ax       ;
            push di          ;
            call ЭЛЕ_КОПИЯ_ВС;
            pop  di          ;
            call ЭЛЕ_СЛЕ     ;
            jmp .ЦИКЛ        ;
.КЦИКЛ:
.ВЫХОД:
            pop  si       ;
            push dx       ;
            popad;
            ret;
            END IF        ;}
IF  (ПЛАТФОРМА = T16)   ;{
            pushad
            test di,di    ;
            jnz .ДАЛЕЕ    ;
            mov  dx,0     ;
            jmp .ВЫХОД    ;

.ДАЛЕЕ:

            push di       ;
            call ЭЛЕ_КОПИЯ;
            mov  dx,di    ;
            pop  di       ;

            call ЭЛЕ_ВЛО  ;

.ЦИКЛ:
            test ax,ax       ;
            jz  .КЦИКЛ       ;
            mov  di,ax       ;
            push di          ;
            call ЭЛЕ_КОПИЯ_ВС;
            pop  di          ;
            call ЭЛЕ_СЛЕ     ;
            jmp .ЦИКЛ        ;
.КЦИКЛ:
.ВЫХОД:
            pop  si       ;
            push dx       ;
            popad;
            ret;
            END IF        ;}
IF  (ПЛАТФОРМА = T32)   ;{
            pushad
            test edi,edi    ;
            jnz .ДАЛЕЕ    ;
            mov  edx,0     ;
            jmp .ВЫХОД    ;

.ДАЛЕЕ:

            push edi       ;
            call ЭЛЕ_КОПИЯ;
            mov  edx,edi    ;
            pop  edi       ;

            call ЭЛЕ_ВЛО  ;

.ЦИКЛ:
            test eax,eax       ;
            jz  .КЦИКЛ       ;
            mov  edi,eax       ;
            push edi          ;
            call ЭЛЕ_КОПИЯ_ВС;
            pop  edi          ;
            call ЭЛЕ_СЛЕ     ;
            jmp .ЦИКЛ        ;
.КЦИКЛ:
.ВЫХОД:
            pop  esi       ;
            push edx       ;
            popad;
            ret;
            END IF        ;}
;==============================================================================}
ЭЛЕ_КОПИЯ   :;{ Копию элемнта Di и назначать родителя DX созданая копия возвращеться  в DI
IF  (ПЛАТФОРМА = ДОС)   ;{
            pushad;

            call ЭЛЕ_ТИП     ; // Возвращет тип элемнта в AX
            cmp  al,ТИП_СТРО ; // Если занчение строка то
            jz  .ЭТО_СТРОКА  ;

            call ЭЛЕ_ЗНА     ; // Читаем значе в AX
            mov  bx,ax       ; // bx-значение
            jmp .ДАЛЕЕ       ;

.ЭТО_СТРОКА:
            ;----------------------;
            mov  cx,di             ;
            call ЭЛЕ_ЗНА           ;
            mov  di,ax             ;
            call РАЗМЕР_AX_УЧАСТКА_ПАМЯТИ_DI
            call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_AX_БАЙТ    ; // Возвращет в DI АДРЕС Созданой СТРОКИ
            mov  si,di             ;
            mov  di,cx             ;
            call ЭЛЕ_ЗНА           ; // Возвращает значение адрес строки
            mov  di,ax             ;
            call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI;
            mov  di,cx             ;
            mov  bx,si             ; // bx-значение
            jmp .ДАЛЕЕ             ;
            ;----------------------;
.ДАЛЕЕ:
            call ЭЛЕ_КОД     ; // Возвращет адрес строки с именем элемнта в AX
            mov  si,ax       ; // Si-Имя элемнат
            call ЭЛЕ_ТИП     ; // Возвращет тип элемнта в AX
            mov  cl,al       ; // al-ТИп
            call ЭЛЕ_ФУН     ; // Возвращет тип элемнта в AX
            mov  ch,al       ; // ah-показат фун
            mov  ax,cx       ;
            mov  di,dx       ;
            call ЭЛЕ_СОЗДАТЬ_КОД ; // Создает элемент и возвращает его дарес в DI


            pop  si          ;
            push di          ;
            popad            ;
            ret              ;
            END iF           ;}
IF  (ПЛАТФОРМА = T16)   ;{
            pushad;

            call ЭЛЕ_ТИП     ; // Возвращет тип элемнта в AX
            cmp  al,ТИП_СТРО ; // Если занчение строка то
            jz  .ЭТО_СТРОКА  ;

            call ЭЛЕ_ЗНА     ; // Читаем значе в AX
            mov  bx,ax       ; // bx-значение
            jmp .ДАЛЕЕ       ;

.ЭТО_СТРОКА:
            ;----------------------;
            mov  cx,di             ;
            call ЭЛЕ_ЗНА           ;
            mov  di,ax             ;
            call РАЗМЕР_AX_УЧАСТКА_ПАМЯТИ_DI
            call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_AX_БАЙТ    ; // Возвращет в DI АДРЕС Созданой СТРОКИ
            mov  si,di             ;
            mov  di,cx             ;
            call ЭЛЕ_ЗНА           ; // Возвращает значение адрес строки
            mov  di,ax             ;
            call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI;
            mov  di,cx             ;
            mov  bx,si             ; // bx-значение
            jmp .ДАЛЕЕ             ;
            ;----------------------;
.ДАЛЕЕ:
            call ЭЛЕ_КОД     ; // Возвращет адрес строки с именем элемнта в AX
            mov  si,ax       ; // Si-Имя элемнат
            call ЭЛЕ_ТИП     ; // Возвращет тип элемнта в AX
            mov  cl,al       ; // al-ТИп
            call ЭЛЕ_ФУН     ; // Возвращет тип элемнта в AX
            mov  ch,al       ; // ah-показат фун
            mov  ax,cx       ;
            mov  di,dx       ;
            call ЭЛЕ_СОЗДАТЬ_КОД ; // Создает элемент и возвращает его дарес в DI


            pop  si          ;
            push di          ;
            popad            ;
            ret              ;
            END iF           ;}
IF  (ПЛАТФОРМА = T32)   ;{
            pushad;

            call ЭЛЕ_ТИП     ; // Возвращет тип элемнта в AX
            cmp  al,ТИП_СТРО ; // Если занчение строка то
            jz  .ЭТО_СТРОКА  ;

            call ЭЛЕ_ЗНА     ; // Читаем значе в AX
            mov  ebx,eax       ; // bx-значение
            jmp .ДАЛЕЕ       ;

.ЭТО_СТРОКА:
            ;----------------------;
            mov  ecx,edi             ;
            call ЭЛЕ_ЗНА           ;
            mov  edi,eax             ;
            call РАЗМЕР_AX_УЧАСТКА_ПАМЯТИ_DI
            call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_AX_БАЙТ    ; // Возвращет в DI АДРЕС Созданой СТРОКИ
            mov  esi,edi             ;
            mov  edi,ecx             ;
            call ЭЛЕ_ЗНА           ; // Возвращает значение адрес строки
            mov  edi,eax             ;
            call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI;
            mov  edi,ecx             ;
            mov  ebx,esi             ; // bx-значение
            jmp .ДАЛЕЕ             ;
            ;----------------------;
.ДАЛЕЕ:
            call ЭЛЕ_КОД     ; // Возвращет адрес строки с именем элемнта в AX
            mov  esi,eax       ; // Si-Имя элемнат
            call ЭЛЕ_ТИП     ; // Возвращет тип элемнта в AX
            mov  cl,al       ; // al-ТИп
            call ЭЛЕ_ФУН     ; // Возвращет тип элемнта в AX
            mov  ch,al       ; // ah-показат фун
            mov  eax,ecx       ;
            mov  edi,edx       ;
            call ЭЛЕ_СОЗДАТЬ_КОД ; // Создает элемент и возвращает его дарес в DI


            pop  esi          ;
            push edi          ;
            popad            ;
            ret              ;
            END iF           ;}
;==============================================================================}
ЭЛЕ_УСТ_ПАР :;{ Функция устанавливает параметр CX В значение AX В элементе DI
IF  (ПЛАТФОРМА = ДОС)   ;{
         pushad ;
         call  ЭЛЕ_ПОСЛЕД;// перемщаемся к последнему элементу
         call  ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI ;// производим поиск нужного нам параметра
         jz   .ВЫХОД     ;
         ADD   DI,ЭЛ_ЗНА ;
         mov  [DI],AX    ;
.ВЫХОД:
         popad           ;
         ret             ;
         END IF          ;}
IF  (ПЛАТФОРМА = T16)   ;{
         pushad ;
         call  ЭЛЕ_ПОСЛЕД;// перемщаемся к последнему элементу
         call  ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI ;// производим поиск нужного нам параметра
         jz   .ВЫХОД     ;
         ADD   DI,ЭЛ_ЗНА ;
         mov  [DI],AX    ;
.ВЫХОД:
         popad           ;
         ret             ;
         END IF          ;}
IF  (ПЛАТФОРМА = T32)   ;{
         pushad ;
         call  ЭЛЕ_ПОСЛЕД;// перемщаемся к последнему элементу
         call  ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI ;// производим поиск нужного нам параметра
         jz   .ВЫХОД     ;
         ADD   EDI,ЭЛ_ЗНА ;
         mov  [EDI],EAX    ;
.ВЫХОД:
         popad           ;
         ret             ;
         END IF          ;}
;==============================================================================}
ЭЛЕ_ПАРСУМ  :;{ Складывает параметр с именем CX Во всех родительских элементах DI возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
        push di          ;
        push bx          ;

        mov  aX,0        ;// по умолчанию результат равен 0
        ;----------------;
        Call ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI   ;
        JZ  .ВЫХОД       ;

        call ЭЛЕ_ЗНА     ;// Чтение значения искомого поля
        mov  bx,ax       ;// Запоминаем найденое значение
        call ЭЛЕ_НАЗАД   ;
        jz  .ВЫХОД       ;
        Call ЭЛЕ_ПАРСУМ  ;// Складываем анологичный параметр родительского элемента
        add  ax,bx       ;
        ;----------------;
.ВЫХОД:
        pop bx           ;
        pop di           ;
        ret;
        END IF           ;}
IF  (ПЛАТФОРМА = T16)   ;{
        push di          ;
        push bx          ;

        mov  aX,0        ;// по умолчанию результат равен 0
        ;----------------;
        Call ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI   ;
        JZ  .ВЫХОД       ;

        call ЭЛЕ_ЗНА     ;// Чтение значения искомого поля
        mov  bx,ax       ;// Запоминаем найденое значение
        call ЭЛЕ_НАЗАД   ;
        jz  .ВЫХОД       ;
        Call ЭЛЕ_ПАРСУМ  ;// Складываем анологичный параметр родительского элемента
        add  ax,bx       ;
        ;----------------;
.ВЫХОД:
        pop bx           ;
        pop di           ;
        ret;
        END IF           ;}
IF  (ПЛАТФОРМА = T32)   ;{
        push edi          ;
        push ebx          ;

        mov  eaX,0        ;// по умолчанию результат равен 0
        ;----------------;
        Call ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI   ;
        JZ  .ВЫХОД       ;

        call ЭЛЕ_ЗНА     ;// Чтение значения искомого поля
        mov  ebx,eax       ;// Запоминаем найденое значение
        call ЭЛЕ_НАЗАД   ;
        jz  .ВЫХОД       ;
        Call ЭЛЕ_ПАРСУМ  ;// Складываем анологичный параметр родительского элемента
        add  eax,ebx       ;
        ;----------------;
.ВЫХОД:
        pop ebx           ;
        pop edi           ;
        ret;
        END IF           ;}
;==============================================================================}
ЭЛЕ_ОСВОБОДИ:;{ Освобождает память занимаемую элементом DI;
IF  (ПЛАТФОРМА = ДОС)   ;{
            pushad;

            mov    bx,DI            ; // Запоминаем свой адрес
            call   ЭЛЕ_УДАЛИТЬ      ;

.ЦИКЛ:      Call   ЭЛЕ_ВЛО          ; // Пытаемся прочитать первый вложеный элемент ;
            jz    .КЦИКЛ            ;
            mov    di,ax            ;
            call   ЭЛЕ_ОСВОБОДИ     ;
            mov    di,bx            ;
            jmp   .ЦИКЛ             ;
.КЦИКЛ:
            mov    di,bx            ; // Востанавливаем адерс
            ;-----------------------;
            call   ЭЛЕ_ТИП          ;
            cmp    ax,ТИП_СТРО      ;
            JNZ   .НЕ_СТРОКА        ;
            ;-----------------------;
            call   ЭЛЕ_ЗНА          ;
            mov    di,ax            ;
            call   ОСВОБОЖДЕНИЕ_УЧАСТКА_ПАМЯТИ_DI;
            mov    di,bx            ;
            ;-----------------------;
.НЕ_СТРОКА:
            ;-----------------------;
            ;call   ЭЛЕ_ИМЯ          ;
            ;mov    di,ax            ;
            ;call   ОСВОБОЖДЕНИЕ_УЧАСТКА_ПАМЯТИ_DI;
            ;mov    di,bx            ;
            ;-----------------------;

            call   ОСВОБОЖДЕНИЕ_УЧАСТКА_ПАМЯТИ_DI;

            popad                   ;
            ret                     ;
            END IF                  ;}
IF  (ПЛАТФОРМА = T16)   ;{
            pushad;

            mov    bx,DI            ; // Запоминаем свой адрес
            call   ЭЛЕ_УДАЛИТЬ      ;

.ЦИКЛ:      Call   ЭЛЕ_ВЛО          ; // Пытаемся прочитать первый вложеный элемент ;
            jz    .КЦИКЛ            ;
            mov    di,ax            ;
            call   ЭЛЕ_ОСВОБОДИ     ;
            mov    di,bx            ;
            jmp   .ЦИКЛ             ;
.КЦИКЛ:
            mov    di,bx            ; // Востанавливаем адерс
            ;-----------------------;
            call   ЭЛЕ_ТИП          ;
            cmp    ax,ТИП_СТРО      ;
            JNZ   .НЕ_СТРОКА        ;
            ;-----------------------;
            call   ЭЛЕ_ЗНА          ;
            mov    di,ax            ;
            call   ОСВОБОЖДЕНИЕ_УЧАСТКА_ПАМЯТИ_DI;
            mov    di,bx            ;
            ;-----------------------;
.НЕ_СТРОКА:
            ;-----------------------;
            ;call   ЭЛЕ_ИМЯ          ;
            ;mov    di,ax            ;
            ;call   ОСВОБОЖДЕНИЕ_УЧАСТКА_ПАМЯТИ_DI;
            ;mov    di,bx            ;
            ;-----------------------;

            call   ОСВОБОЖДЕНИЕ_УЧАСТКА_ПАМЯТИ_DI;

            popad                   ;
            ret                     ;
            END IF                  ;}
IF  (ПЛАТФОРМА = T32)   ;{
            pushad;

            mov    ebx,eDI            ; // Запоминаем свой адрес
            call   ЭЛЕ_УДАЛИТЬ      ;

.ЦИКЛ:      Call   ЭЛЕ_ВЛО          ; // Пытаемся прочитать первый вложеный элемент ;
            jz    .КЦИКЛ            ;
            mov    edi,eax            ;
            call   ЭЛЕ_ОСВОБОДИ     ;
            mov    edi,ebx            ;
            jmp   .ЦИКЛ             ;
.КЦИКЛ:
            mov    edi,ebx            ; // Востанавливаем адерс
            ;-----------------------;
            call   ЭЛЕ_ТИП          ;
            cmp    eax,ТИП_СТРО      ;
            JNZ   .НЕ_СТРОКА        ;
            ;-----------------------;
            call   ЭЛЕ_ЗНА          ;
            mov    edi,eax            ;
            call   ОСВОБОЖДЕНИЕ_УЧАСТКА_ПАМЯТИ_DI;
            mov    edi,ebx            ;
            ;-----------------------;
.НЕ_СТРОКА:
            call   ОСВОБОЖДЕНИЕ_УЧАСТКА_ПАМЯТИ_DI;

            popad                   ;
            ret                     ;
            END IF                  ;}
;==============================================================================}

ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI:;{ Добавляем элемент DX в элмеент DI
IF  (ПЛАТФОРМА = ДОС)   ;{
         pushad          ;
         mov  cx,di      ;//сохраняем адрес родительского  элемента в котрый нужно доавить

         test DI,DI      ;
         jz  .NEX        ;// Если нету родительского элемента просто пишем 0 в родитель в конце процедуры

         ;--------------
         MOV  DI,DX      ;
         CALL ЭЛЕ_УДАЛИТЬ;// Удаляеи элемент из предыдущего списка если он там был
         ;--------------

         ;------------
         mov  DI,CX     ;
         Call ЭЛЕ_ПОСЛЕД;// Ощим последний элемент в родительском элементе
         jnz .ADDNEX    ;// Если есть хоть один вложенй элемент присоеденяем к последнему элемнту
                        ;// Если нет не одного вложеного элемента то присоеденяем к родителю как первый вложенй элемент
         MOV  Si,cx     ;
         ADD  SI,ЭЛ_ВЛО ;
         Mov [Si],DX    ;// ПРисоеденяем в родительском элементе добавляемый элемент как первый элемент вложеного списка
         Jmp .NEX       ;
         ;------------

.ADDNEX: ;------------
         mov  SI,DI      ;// В DI находиться адрес последнего элемента в списке куда добавляем элмент
         add  SI,ЭЛ_СЛЕ  ;// ПРисоеденяем добавляемый элмент в конец спсика
         mov [SI],DX     ;// Записываем добавляемый элемент DX

         mov  Si,DX      ;
         add  si,ЭЛ_ПРЕ  ;// Указывем в добавлемом элементе предыдущий
         mov [si],di     ;
         ;------------

.NEX:    MOV  Si,DX       ;// Указываем родительский элемент
         add  si,ЭЛ_РОД   ;//
         mov [SI],cx      ;//

         popad;
         ret;
         END iF           ;}
IF  (ПЛАТФОРМА = T16)   ;{
         pushad          ;
         mov  cx,di      ;//сохраняем адрес родительского  элемента в котрый нужно доавить

         test DI,DI      ;
         jz  .NEX        ;// Если нету родительского элемента просто пишем 0 в родитель в конце процедуры

         ;--------------
         MOV  DI,DX      ;
         CALL ЭЛЕ_УДАЛИТЬ;// Удаляеи элемент из предыдущего списка если он там был
         ;--------------

         ;------------
         mov  DI,CX     ;
         Call ЭЛЕ_ПОСЛЕД;// Ощим последний элемент в родительском элементе
         jnz .ADDNEX    ;// Если есть хоть один вложенй элемент присоеденяем к последнему элемнту
                        ;// Если нет не одного вложеного элемента то присоеденяем к родителю как первый вложенй элемент
         MOV  Si,cx     ;
         ADD  SI,ЭЛ_ВЛО ;
         Mov [Si],DX    ;// ПРисоеденяем в родительском элементе добавляемый элемент как первый элемент вложеного списка
         Jmp .NEX       ;
         ;------------

.ADDNEX: ;------------
         mov  SI,DI      ;// В DI находиться адрес последнего элемента в списке куда добавляем элмент
         add  SI,ЭЛ_СЛЕ  ;// ПРисоеденяем добавляемый элмент в конец спсика
         mov [SI],DX     ;// Записываем добавляемый элемент DX

         mov  Si,DX      ;
         add  si,ЭЛ_ПРЕ  ;// Указывем в добавлемом элементе предыдущий
         mov [si],di     ;
         ;------------

.NEX:    MOV  Si,DX       ;// Указываем родительский элемент
         add  si,ЭЛ_РОД   ;//
         mov [SI],cx      ;//

         popad;
         ret;
         END iF           ;}
IF  (ПЛАТФОРМА = T32)   ;{
         pushad          ;
         mov  ecx,edi      ;//сохраняем адрес родительского  элемента в котрый нужно доавить

         test eDI,eDI      ;
         jz  .NEX        ;// Если нету родительского элемента просто пишем 0 в родитель в конце процедуры

         ;--------------
         MOV  eDI,eDX      ;
         CALL ЭЛЕ_УДАЛИТЬ;// Удаляеи элемент из предыдущего списка если он там был
         ;--------------

         ;------------
         mov  eDI,eCX     ;
         Call ЭЛЕ_ПОСЛЕД;// Ощим последний элемент в родительском элементе
         jnz .ADDNEX    ;// Если есть хоть один вложенй элемент присоеденяем к последнему элемнту
                        ;// Если нет не одного вложеного элемента то присоеденяем к родителю как первый вложенй элемент
         MOV  eSi,ecx     ;
         ADD  eSI,ЭЛ_ВЛО ;
         Mov [eSi],eDX    ;// ПРисоеденяем в родительском элементе добавляемый элемент как первый элемент вложеного списка
         Jmp .NEX       ;
         ;------------

.ADDNEX: ;------------
         mov  eSI,eDI      ;// В DI находиться адрес последнего элемента в списке куда добавляем элмент
         add  eSI,ЭЛ_СЛЕ  ;// ПРисоеденяем добавляемый элмент в конец спсика
         mov [eSI],eDX     ;// Записываем добавляемый элемент DX

         mov  eSi,eDX      ;
         add  esi,ЭЛ_ПРЕ  ;// Указывем в добавлемом элементе предыдущий
         mov [esi],edi     ;
         ;------------

.NEX:    MOV  eSi,eDX       ;// Указываем родительский элемент
         add  esi,ЭЛ_РОД   ;//
         mov [eSI],ecx      ;//

         popad;
         ret;
         END iF           ;}
;==============================================================================}
ДОБ_ЭЛЕ_СX_В_ЭЛЕ_DI:;{ Добавляем элемент CX в элмеент DI
IF  (ПЛАТФОРМА = ДОС)   ;{
            push dx;
            mov  dx,cx;
            call ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI
            pop  dx;
            ret;
            END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
            push dx;
            mov  dx,cx;
            call ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI
            pop  dx;
            ret;
            END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
            push edx;
            mov  edx,ecx;
            call ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI
            pop  edx;
            ret;
            END IF;}
;==============================================================================}


ЭЛЕ_ПОИСК_ВН_ПО_КОДУ_CX    :;{ Поиск внутри элемента элемнта с кодом CX
IF  (ПЛАТФОРМА = ДОС)   ;{
           PUSHAD;
           mov si,0           ; ПО умолчанию результат равен 0 то есть не нашли
           call ЭЛЕ_ПОСЛЕД    ;
           JZ  .ВЫХОД         ;
.ЦИКЛ:
           test  di,di        ;
           jz   .ВЫХОД        ;
           call  ЭЛЕ_КОД_РАВ  ;
           jnz  .НАШЛИ        ; Еслти это элемент с с искомым именем идем на выход элемент найден
           ;-----------------
           call  ЭЛЕ_ПРЕ      ;
           mov  di,ax         ;
           Jmp  .ЦИКЛ         ;
           ;-----------------

.НАШЛИ:    mov SI,DI          ;

.ВЫХОД:
           test si,si         ;
           pop  di            ;
           push si            ;
           popad              ;
           ret                ;
           END IF             ;}
IF  (ПЛАТФОРМА = T16)   ;{
           PUSHAD;
           mov si,0           ; ПО умолчанию результат равен 0 то есть не нашли
           call ЭЛЕ_ПОСЛЕД    ;
           JZ  .ВЫХОД         ;
.ЦИКЛ:
           test  di,di        ;
           jz   .ВЫХОД        ;
           call  ЭЛЕ_КОД_РАВ  ;
           jnz  .НАШЛИ        ; Еслти это элемент с с искомым именем идем на выход элемент найден
           ;-----------------
           call  ЭЛЕ_ПРЕ      ;
           mov  di,ax         ;
           Jmp  .ЦИКЛ         ;
           ;-----------------

.НАШЛИ:    mov SI,DI          ;

.ВЫХОД:
           test si,si         ;
           pop  di            ;
           push si            ;
           popad              ;
           ret                ;
           END IF             ;}
IF  (ПЛАТФОРМА = T32)   ;{
           PUSHAD;
           mov  esi,0           ; ПО умолчанию результат равен 0 то есть не нашли
           call ЭЛЕ_ПОСЛЕД    ;
           JZ  .ВЫХОД         ;
.ЦИКЛ:
           test  edi,edi        ;
           jz   .ВЫХОД        ;
           call  ЭЛЕ_КОД_РАВ  ;
           jnz  .НАШЛИ        ; Еслти это элемент с с искомым именем идем на выход элемент найден
           ;-----------------
           call  ЭЛЕ_ПРЕ      ;
           mov  edi,eax         ;
           Jmp  .ЦИКЛ         ;
           ;-----------------

.НАШЛИ:    mov eSI,eDI          ;

.ВЫХОД:
           test esi,esi         ;
           pop  edi            ;
           push esi            ;
           popad              ;
           ret                ;
           END IF             ;}
;==============================================================================}
ЭЛЕ_КОД_РАВ                :;{ Сравнивает имя элемента с строкой CX
IF  (ПЛАТФОРМА = ДОС)   ;{
            pushad;
            call ЭЛЕ_КОД;
            CMP  ax,cx  ;
            jz  .РАВНО  ;
            mov  al,0   ;
            test al,al  ;
            Jmp .ВЫХОД  ;

.РАВНО:     mov  al,1   ;
            test al,al  ;
.ВЫХОД:
            popad
            ret;
            END IF      ;}
IF  (ПЛАТФОРМА = T16)   ;{
            pushad;
            call ЭЛЕ_КОД;
            CMP  ax,cx  ;
            jz  .РАВНО  ;
            mov  al,0   ;
            test al,al  ;
            Jmp .ВЫХОД  ;

.РАВНО:     mov  al,1   ;
            test al,al  ;
.ВЫХОД:
            popad
            ret;
            END IF      ;}
IF  (ПЛАТФОРМА = T32)   ;{
            pushad;
            call ЭЛЕ_КОД;
            CMP  eax,ecx  ;
            jz  .РАВНО  ;
            mov  al,0   ;
            test al,al  ;
            Jmp .ВЫХОД  ;

.РАВНО:     mov  al,1   ;
            test al,al  ;
.ВЫХОД:
            popad
            ret;
            END IF      ;}
;==============================================================================}
ЭЛЕ_КОД_РАВФ               :;{ Сравнивает имя элемента с строкой CX и проверяет являеться ли функцией элемент
IF  (ПЛАТФОРМА = ДОС)   ;{
            pushad              ;
            call ЭЛЕ_ФУН        ;// Устанавливает флаг Z если это функция возвращает в AX значение поля Функция элемента
            jz  .ВЫХОД          ;// Если не функцуия то выход
            call ЭЛЕ_КОД_РАВ    ;// сравниаем имена Устанвливает флаг Z если равн имена
.ВЫХОД:
            popad               ;
            ret                 ;
            END IF              ;}
IF  (ПЛАТФОРМА = T16)   ;{
            pushad              ;
            call ЭЛЕ_ФУН        ;// Устанавливает флаг Z если это функция возвращает в AX значение поля Функция элемента
            jz  .ВЫХОД          ;// Если не функцуия то выход
            call ЭЛЕ_КОД_РАВ    ;// сравниаем имена Устанвливает флаг Z если равн имена
.ВЫХОД:
            popad               ;
            ret                 ;
            END IF              ;}
IF  (ПЛАТФОРМА = T32)   ;{
            pushad              ;
            call ЭЛЕ_ФУН        ;// Устанавливает флаг Z если это функция возвращает в AX значение поля Функция элемента
            jz  .ВЫХОД          ;// Если не функцуия то выход
            call ЭЛЕ_КОД_РАВ    ;// сравниаем имена Устанвливает флаг Z если равн имена
.ВЫХОД:
            popad               ;
            ret                 ;
            END IF              ;}
;==============================================================================}
ЭЛЕ_ПОИСК_ПР_ПО_КОДУ_CX    :;{ ПОиск элемента с Кодом CX в предыдущих элементах элемента DI возвращает результат в DI
IF  (ПЛАТФОРМА = ДОС)   ;{
            pushad;
            mov si,0         ;// По умолчанию резльутат равен 0  то есть не нашел
.ЦИКЛ:
            ;-----------------
            call ЭЛЕ_ПРЕ     ;
            JZ  .ВЫХОД       ;
            mov  DI,AX       ;
            CALL ЭЛЕ_КОД_РАВФ;
            JNZ .НАШОЛ       ;
            jmp .ЦИКЛ        ;
            ;-----------------
.НАШОЛ:     mov  si,DI       ;
.ВЫХОД:
            test si,si       ;
            pop  ax;
            push si;
            popad  ;
            ret    ;
            END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
            pushad;
            mov si,0         ;// По умолчанию резльутат равен 0  то есть не нашел
.ЦИКЛ:
            ;-----------------
            call ЭЛЕ_ПРЕ     ;
            JZ  .ВЫХОД       ;
            mov  DI,AX       ;
            CALL ЭЛЕ_КОД_РАВФ;
            JNZ .НАШОЛ       ;
            jmp .ЦИКЛ        ;
            ;-----------------
.НАШОЛ:     mov  si,DI       ;
.ВЫХОД:
            test si,si       ;
            pop  ax;
            push si;
            popad  ;
            ret    ;
            END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
            pushad;
            mov esi,0         ;// По умолчанию резльутат равен 0  то есть не нашел
.ЦИКЛ:
            ;-----------------
            call ЭЛЕ_ПРЕ     ;
            JZ  .ВЫХОД       ;
            mov  eDI,eAX       ;
            CALL ЭЛЕ_КОД_РАВФ;
            JNZ .НАШОЛ       ;
            jmp .ЦИКЛ        ;
            ;-----------------
.НАШОЛ:     mov  esi,eDI       ;
.ВЫХОД:
            test esi,esi       ;
            pop  eax;
            push esi;
            popad  ;
            ret    ;
            END IF;}
;==============================================================================}
ЭЛЕ_ПОИСК_ПА_ПО_КОДУ_CX    :;{ ПОиск элемента с Кодом  CX в параметрах элемента DI
IF  (ПЛАТФОРМА = ДОС)   ;{
           PUSHAD;
           mov si,0           ; ПО умолчанию результат равен 0 то есть не нашли

           call ЭЛЕ_ФУН       ; // ПРоверяем функция ли это
           jz  .ВЫХОД         ;

           ;-----------------
           Call ЭЛЕ_ВЛО       ; ПРоверяем еть ли вообще параметры внутри элемента
           JZ  .ВЫХОД         ;
           mov  di,ax         ;


           call ЭЛЕ_КОД       ;
           cmp  ax,КОД_КОМ_ОСКОБКА;// проверяем что это скобка
           jnz .ВЫХОД         ;


           Call ЭЛЕ_ВЛО       ; ПРоверяем еть ли элемнет внтури скобки

.ЦИКЛ:
           test  ax,ax        ;
           jz   .ВЫХОД        ;
           mov   di,ax        ;
           call  ЭЛЕ_КОД_РАВ  ;
           jnz  .НАШЛИ        ; Еслти это элемент с с искомым именем идем на выход элемент найден
           ;-----------------
           call  ЭЛЕ_СЛЕ      ;
           Jmp  .ЦИКЛ         ;
           ;-----------------

.НАШЛИ:    mov SI,DI          ;

.ВЫХОД:
           test si,si         ;
           pop  di            ;
           push si            ;
           popad              ;
           ret                ;
           END iF             ;}
IF  (ПЛАТФОРМА = T16)   ;{
           PUSHAD;
           mov si,0           ; ПО умолчанию результат равен 0 то есть не нашли

           call ЭЛЕ_ФУН       ; // ПРоверяем функция ли это
           jz  .ВЫХОД         ;

           ;-----------------
           Call ЭЛЕ_ВЛО       ; ПРоверяем еть ли вообще параметры внутри элемента
           JZ  .ВЫХОД         ;
           mov  di,ax         ;


           call ЭЛЕ_КОД       ;
           cmp  ax,КОД_КОМ_ОСКОБКА;// проверяем что это скобка
           jnz .ВЫХОД         ;


           Call ЭЛЕ_ВЛО       ; ПРоверяем еть ли элемнет внтури скобки

.ЦИКЛ:
           test  ax,ax        ;
           jz   .ВЫХОД        ;
           mov   di,ax        ;
           call  ЭЛЕ_КОД_РАВ  ;
           jnz  .НАШЛИ        ; Еслти это элемент с с искомым именем идем на выход элемент найден
           ;-----------------
           call  ЭЛЕ_СЛЕ      ;
           Jmp  .ЦИКЛ         ;
           ;-----------------

.НАШЛИ:    mov SI,DI          ;

.ВЫХОД:
           test si,si         ;
           pop  di            ;
           push si            ;
           popad              ;
           ret                ;
           END iF             ;}
IF  (ПЛАТФОРМА = T32)   ;{
           PUSHAD;
           mov  esi,0           ; ПО умолчанию результат равен 0 то есть не нашли

           call ЭЛЕ_ФУН       ; // ПРоверяем функция ли это
           jz  .ВЫХОД         ;

           ;-----------------
           Call ЭЛЕ_ВЛО       ; ПРоверяем еть ли вообще параметры внутри элемента
           JZ  .ВЫХОД         ;
           mov  edi,eax         ;


           call ЭЛЕ_КОД       ;
           cmp  eax,КОД_КОМ_ОСКОБКА;// проверяем что это скобка
           jnz .ВЫХОД         ;


           Call ЭЛЕ_ВЛО       ; ПРоверяем еть ли элемнет внтури скобки

.ЦИКЛ:
           test  eax,eax        ;
           jz   .ВЫХОД        ;
           mov   edi,eax        ;
           call  ЭЛЕ_КОД_РАВ  ;
           jnz  .НАШЛИ        ; Еслти это элемент с с искомым именем идем на выход элемент найден
           ;-----------------
           call  ЭЛЕ_СЛЕ      ;
           Jmp  .ЦИКЛ         ;
           ;-----------------

.НАШЛИ:    mov eSI,eDI          ;

.ВЫХОД:
           test esi,esi         ;
           pop  edi            ;
           push esi            ;
           popad              ;
           ret                ;
           END iF             ;}
;==============================================================================}
ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI       :;{ Поиск элемента по Коду наружу ищит елемнт с Кодом CX с элемента DI элемент DI не участвует в поиске возвращает Арес элемента в DI
IF  (ПЛАТФОРМА = ДОС)   ;{

           push ax;
           ;-------------------;
           mov   ax,di         ;// Запоминаем элемент с котрого ведем поиск
           ;-------------------;
           call  ЭЛЕ_КОД_РАВФ  ;
           jnz  .ВЫХОД         ;
           ;-------------------;
           mov   di,ax         ;
           call  ЭЛЕ_ПОИСК_ПР_ПО_КОДУ_CX ;// Ищим в предыдущих элементах
           jnz  .ВЫХОД         ;
           ;-------------------;
           mov   di,ax         ;
           call  ЭЛЕ_ПОИСК_ПА_ПО_КОДУ_CX ;// Ищим в параметрах
           jnz  .ВЫХОД         ;
           ;-------------------;
           mov   di,ax         ;
           call  ЭЛЕ_РОДИТЕЛЬ  ; Ищитм в родительском элементе
           jz   .ВЫХОД         ;
           ;-------------------;
           call  ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI;
.ВЫХОД:

           test  di,di         ;
           pop   ax            ;
           ret                 ;
           END IF              ;}
IF  (ПЛАТФОРМА = T16)   ;{
           push ax;

           ;-------------------;
           mov   ax,di         ;// Запоминаем элемент с котрого ведем поиск
           ;-------------------;
           call  ЭЛЕ_КОД_РАВФ  ;
           jnz  .ВЫХОД         ;
           ;-------------------;
           mov   di,ax         ;
           call  ЭЛЕ_ПОИСК_ПР_ПО_КОДУ_CX ;// Ищим в предыдущих элементах
           jnz  .ВЫХОД         ;
           ;-------------------;
           mov   di,ax         ;
           call  ЭЛЕ_ПОИСК_ПА_ПО_КОДУ_CX ;// Ищим в параметрах
           jnz  .ВЫХОД         ;
           ;-------------------;
           mov   di,ax         ;
           call  ЭЛЕ_РОДИТЕЛЬ  ; Ищитм в родительском элементе
           jz   .ВЫХОД         ;
           ;-------------------;
           call  ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI;
.ВЫХОД:
           test  di,di         ;
           pop   ax            ;
           ret                 ;
           END IF              ;}
IF  (ПЛАТФОРМА = T32)   ;{
           push eax;

           ;-------------------;
           mov   eax,edi         ;// Запоминаем элемент с котрого ведем поиск
           ;-------------------;
           call  ЭЛЕ_КОД_РАВФ  ;
           jnz  .ВЫХОД         ;
           ;-------------------;
           mov   edi,eax         ;
           call  ЭЛЕ_ПОИСК_ПР_ПО_КОДУ_CX ;// Ищим в предыдущих элементах
           jnz  .ВЫХОД         ;
           ;-------------------;
           mov   edi,eax         ;
           call  ЭЛЕ_ПОИСК_ПА_ПО_КОДУ_CX ;// Ищим в параметрах
           jnz  .ВЫХОД         ;
           ;-------------------;
           mov   edi,eax         ;
           call  ЭЛЕ_РОДИТЕЛЬ  ; Ищитм в родительском элементе
           jz   .ВЫХОД         ;
           ;-------------------;
           call  ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI;
.ВЫХОД:
           test  edi,edi         ;
           pop   eax            ;
           ret                 ;
           END IF              ;}
;==============================================================================}
ЭЛЕ_ПОИСК_ПО_КОДУ_AX       :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 pushad;
                 mov  cx,ax;
                 call ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI;
                 pop  si;
                 push di;
                 popad;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 pushad;
                 mov  cx,ax;
                 call ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI;
                 pop  si;
                 push di;
                 popad;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 pushad;
                 mov  ecx,eax;
                 call ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI;
                 pop  esi;
                 push edi;
                 popad;
                 ret;
                 END IF;}
;==============================================================================}



ДОБ_ЗНА_В_СТР_SI_ИЗ_ЭЛЕ_AX :;{ Копировать значение элемента в DI из элемнета BX
IF  (ПЛАТФОРМА = ДОС)   ;{
          pushad;
          mov  di,ax;
          call ЭЛЕ_ТИП;
          cmp  ax,ТИП_СТРО;
          jz  .СТРОКА;
          cmp  ax,ТИП_ЧИСЛ;
          jz  .ЧИСЛО;
          jmp .ВЫХОД;
.СТРОКА: ;{СТРОКА<СТРОКА    ;
          call ЭЛЕ_ЗНА      ;
          call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_SI_СТРОКУ_AX;
          jmp .ВЫХОД       ;
         ;-----------------}
.ЧИСЛО:  ;{СТРОКА<ЧИСЛО     ;
          call ЭЛЕ_ЗНА;
          call ДОБАВИТЬ_ЧИСЛО_AX_В_КОНЕЦ_СТРОКИ_SI
          jmp .ВЫХОД        ;
          ;-----------------}
.ВЫХОД:
          popad;
          ret;
          END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
          pushad;
          mov  di,ax;
          call ЭЛЕ_ТИП;
          cmp  ax,ТИП_СТРО;
          jz  .СТРОКА;
          cmp  ax,ТИП_ЧИСЛ;
          jz  .ЧИСЛО;
          jmp .ВЫХОД;
.СТРОКА: ;{СТРОКА<СТРОКА    ;
          call ЭЛЕ_ЗНА      ;
          call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_SI_СТРОКУ_AX;
          jmp .ВЫХОД       ;
         ;-----------------}
.ЧИСЛО:  ;{СТРОКА<ЧИСЛО     ;
          call ЭЛЕ_ЗНА;
          call ДОБАВИТЬ_ЧИСЛО_AX_В_КОНЕЦ_СТРОКИ_SI
          jmp .ВЫХОД        ;
          ;-----------------}
.ВЫХОД:
          popad;
          ret;
          END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
          pushad;
          mov  edi,eax;
          call ЭЛЕ_ТИП;
          cmp  eax,ТИП_СТРО;
          jz  .СТРОКА;
          cmp  eax,ТИП_ЧИСЛ;
          jz  .ЧИСЛО;
          jmp .ВЫХОД;
.СТРОКА: ;{СТРОКА<СТРОКА    ;
          call ЭЛЕ_ЗНА      ;
          call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_SI_СТРОКУ_AX;
          jmp .ВЫХОД       ;
         ;-----------------}
.ЧИСЛО:  ;{СТРОКА<ЧИСЛО     ;
          call ЭЛЕ_ЗНА;
          call ДОБАВИТЬ_ЧИСЛО_AX_В_КОНЕЦ_СТРОКИ_SI
          jmp .ВЫХОД        ;
          ;-----------------}
.ВЫХОД:
          popad;
          ret;
          END IF;}
;==============================================================================}
ДОБ_ЗНА_В_ЭЛЕ_DI_ИЗ_ЭЛЕ_BX :;{ Копировать значение элемента в DI из элемнета BX
IF  (ПЛАТФОРМА = ДОС)   ;{
          pushad;
          call ТИП_ОПЕРАЦИИ_DI_BX;

          cmp  ax,КОМ_ЧИС_ЧИС;
          jz  .ЧЧ;
          cmp  ax,КОМ_ЧИС_СТР;
          jz  .ЧС;
          cmp  ax,КОМ_СТР_ЧИС;
          jz  .СЧ;
          cmp  ax,КОМ_СТР_СТР;
          jz  .СС;

          jmp .ВЫХОД;
.ЧЧ:     ;{ЧИСЛО<ЧИСЛО      ;

          push di;
          mov  di,bx        ;
          call ЭЛЕ_ЗНА      ;
          Mov  dx,ax        ;
          pop  di           ;

          call ЭЛЕ_ЗНА      ;
          add  ax,dx;

          mov  si,di        ;
          add  SI,ЭЛ_ЗНА    ;
          mov [si],ax       ;
          jmp .ВЫХОД        ;
         ;-----------------}
.СС:     ;{СТРОКА<СТРОКА    ;
          call ЭЛЕ_ЗНА      ;
          mov  dx,ax        ;
          mov  di,bx        ;
          call ЭЛЕ_ЗНА      ;
          mov  cx,ax        ;
          call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_DX_СТРОКУ_CX;
          jmp .ВЫХОД       ;
         ;-----------------}
.ЧС:     ;{ЧИСЛО<СТРОКА     ;

          call ЭЛЕ_ЗНА;
          call СОЗДАТЬ_СТРОКУ_DX_ДЛИНОЙ_16_БАЙТ;
          call ЗАПИСАТЬ_ЧИСЛО_AX_В_СТРОКУ_DX

          mov  si,di        ;
          add  SI,ЭЛ_ТИП    ;
          mov  byte[si],ТИП_СТРО;

          mov  si,di        ;
          add  SI,ЭЛ_ЗНА    ;
          mov  WORD[si],DX  ;

          mov  di,BX        ;
          call ЭЛЕ_ЗНА      ;
          mov  cx,ax;
          call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_DX_СТРОКУ_CX

          jmp .ВЫХОД        ;
         ;-----------------}
.СЧ:     ;{СТРОКА<ЧИСЛО     ;

          call ЭЛЕ_ЗНА;
          mov  si,ax;
          mov  di,bx;
          call ЭЛЕ_ЗНА;
          call ДОБАВИТЬ_ЧИСЛО_AX_В_КОНЕЦ_СТРОКИ_SI

          jmp .ВЫХОД        ;
          ;-----------------}
.ВЫХОД:
          popad;
          ret;
          END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
          pushad;
          call ТИП_ОПЕРАЦИИ_DI_BX;

          cmp  ax,КОМ_ЧИС_ЧИС;
          jz  .ЧЧ;
          cmp  ax,КОМ_ЧИС_СТР;
          jz  .ЧС;
          cmp  ax,КОМ_СТР_ЧИС;
          jz  .СЧ;
          cmp  ax,КОМ_СТР_СТР;
          jz  .СС;

          jmp .ВЫХОД;
.ЧЧ:     ;{ЧИСЛО<ЧИСЛО      ;

          push di;
          mov  di,bx        ;
          call ЭЛЕ_ЗНА      ;
          Mov  dx,ax        ;
          pop  di           ;

          call ЭЛЕ_ЗНА      ;
          add  ax,dx;

          mov  si,di        ;
          add  SI,ЭЛ_ЗНА    ;
          mov [si],ax       ;
          jmp .ВЫХОД        ;
         ;-----------------}
.СС:     ;{СТРОКА<СТРОКА    ;
          call ЭЛЕ_ЗНА      ;
          mov  dx,ax        ;
          mov  di,bx        ;
          call ЭЛЕ_ЗНА      ;
          mov  cx,ax        ;
          call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_DX_СТРОКУ_CX;
          jmp .ВЫХОД       ;
         ;-----------------}
.ЧС:     ;{ЧИСЛО<СТРОКА     ;

          call ЭЛЕ_ЗНА;
          call СОЗДАТЬ_СТРОКУ_DX_ДЛИНОЙ_16_БАЙТ;
          call ЗАПИСАТЬ_ЧИСЛО_AX_В_СТРОКУ_DX

          mov  si,di        ;
          add  SI,ЭЛ_ТИП    ;
          mov  byte[si],ТИП_СТРО;

          mov  si,di        ;
          add  SI,ЭЛ_ЗНА    ;
          mov  WORD[si],DX  ;

          mov  di,BX        ;
          call ЭЛЕ_ЗНА      ;
          mov  cx,ax;
          call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_DX_СТРОКУ_CX

          jmp .ВЫХОД        ;
         ;-----------------}
.СЧ:     ;{СТРОКА<ЧИСЛО     ;

          call ЭЛЕ_ЗНА;
          mov  si,ax;
          mov  di,bx;
          call ЭЛЕ_ЗНА;
          call ДОБАВИТЬ_ЧИСЛО_AX_В_КОНЕЦ_СТРОКИ_SI

          jmp .ВЫХОД        ;
          ;-----------------}
.ВЫХОД:
          popad;
          ret;
          END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
          pushad;
          call ТИП_ОПЕРАЦИИ_DI_BX;

          cmp  ax,КОМ_ЧИС_ЧИС;
          jz  .ЧЧ;
          cmp  ax,КОМ_ЧИС_СТР;
          jz  .ЧС;
          cmp  ax,КОМ_СТР_ЧИС;
          jz  .СЧ;
          cmp  ax,КОМ_СТР_СТР;
          jz  .СС;

          jmp .ВЫХОД;
.ЧЧ:     ;{ЧИСЛО<ЧИСЛО      ;

          push edi;
          mov  edi,ebx        ;
          call ЭЛЕ_ЗНА      ;
          Mov  edx,eax        ;
          pop  edi           ;

          call ЭЛЕ_ЗНА      ;
          add  eax,edx;

          mov  esi,edi        ;
          add  eSI,ЭЛ_ЗНА    ;
          mov [esi],eax       ;
          jmp .ВЫХОД        ;
         ;-----------------}
.СС:     ;{СТРОКА<СТРОКА    ;
          call ЭЛЕ_ЗНА      ;
          mov  edx,eax        ;
          mov  edi,ebx        ;
          call ЭЛЕ_ЗНА      ;
          mov  ecx,eax        ;
          call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_DX_СТРОКУ_CX;
          jmp .ВЫХОД       ;
         ;-----------------}
.ЧС:     ;{ЧИСЛО<СТРОКА     ;

          call ЭЛЕ_ЗНА;
          call СОЗДАТЬ_СТРОКУ_DX_ДЛИНОЙ_16_БАЙТ;
          call ЗАПИСАТЬ_ЧИСЛО_AX_В_СТРОКУ_DX

          mov  esi,edi        ;
          add  eSI,ЭЛ_ТИП    ;
          mov  [esi],Byte ТИП_СТРО;

          mov  esi,edi        ;
          add  eSI,ЭЛ_ЗНА    ;
          mov  [si],eDX  ;

          mov  edi,eBX        ;
          call ЭЛЕ_ЗНА      ;
          mov  ecx,eax;
          call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_DX_СТРОКУ_CX

          jmp .ВЫХОД        ;
         ;-----------------}
.СЧ:     ;{СТРОКА<ЧИСЛО     ;

          call ЭЛЕ_ЗНА;
          mov  esi,eax;
          mov  edi,ebx;
          call ЭЛЕ_ЗНА;
          call ДОБАВИТЬ_ЧИСЛО_AX_В_КОНЕЦ_СТРОКИ_SI

          jmp .ВЫХОД        ;
          ;-----------------}
.ВЫХОД:
          popad;
          ret;
          END IF;}
;==============================================================================}
ДОБ_ЗНА_В_ЭЛЕ_CX_ИЗ_ЭЛЕ_DX :;{ Добавить в значение элемента CX значеие элемента DX
IF  (ПЛАТФОРМА = ДОС)   ;{
          pushad;
          mov di,cx;
          mov bx,dx;
          call ДОБ_ЗНА_В_ЭЛЕ_DI_ИЗ_ЭЛЕ_BX
          popad ;
          ret;
          END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
          pushad;
          mov di,cx;
          mov bx,dx;
          call ДОБ_ЗНА_В_ЭЛЕ_DI_ИЗ_ЭЛЕ_BX
          popad ;
          ret;
          END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
          pushad;
          mov edi,ecx;
          mov ebx,edx;
          call ДОБ_ЗНА_В_ЭЛЕ_DI_ИЗ_ЭЛЕ_BX
          popad ;
          ret;
          END IF;}
;==============================================================================}
ЭЛЕ_ЧИТ_СКО_ИЗ_ЭЛЕ_AX:;{ Читает скобку из элемента AX
IF  (ПЛАТФОРМА = ДОС)   ;{
         push di     ;
         mov  di,ax  ;
         call ЭЛЕ_ВЛО;
         jz  .НЕТУ   ;
         mov  di,ax  ;
         call ЭЛЕ_КОД;
         cmp  ax,КОД_КОМ_ОСКОБКА;
         jnz .НЕТУ   ;
         call ЭЛЕ_ВЛО; // Читаем первый вложеный элмент внтури скобки
         jmp .ВЫХОД  ;
.НЕТУ:   mov ax,0    ;
.ВЫХОД:
         test ax,ax  ;
         pop  di;
         ret
         END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
         push di     ;
         mov  di,ax  ;
         call ЭЛЕ_ВЛО;
         jz  .НЕТУ   ;
         mov  di,ax  ;
         call ЭЛЕ_КОД;
         cmp  ax,КОД_КОМ_ОСКОБКА;
         jnz .НЕТУ   ;
         call ЭЛЕ_ВЛО; // Читаем первый вложеный элмент внтури скобки
         jmp .ВЫХОД  ;
.НЕТУ:   mov ax,0    ;
.ВЫХОД:
         test ax,ax  ;
         pop  di;
         ret
         END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
         push edi     ;
         mov  edi,eax  ;
         call ЭЛЕ_ВЛО;
         jz  .НЕТУ   ;
         mov  edi,eax  ;
         call ЭЛЕ_КОД;
         cmp  eax,КОД_КОМ_ОСКОБКА;
         jnz .НЕТУ   ;
         call ЭЛЕ_ВЛО; // Читаем первый вложеный элмент внтури скобки
         jmp .ВЫХОД  ;
.НЕТУ:   mov  eax,0    ;
.ВЫХОД:
         test eax,eax  ;
         pop  edi;
         ret
         END IF;}
;==============================================================================}
ЧИТАТЬ_ВЛОЖЕНЫЕ_ЗНАЧЕНИЯ_В_CX_DX:;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                    push ax;
                    call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_AX;
                    mov  Cx,ax                         ;
                    call ЗНАЧЕНИЕ_ВТОРОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_AX;
                    MOV  Dx,ax
                    POP  ax;
                    RET;
                    END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                    push ax;
                    call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_AX;
                    mov  Cx,ax                         ;
                    call ЗНАЧЕНИЕ_ВТОРОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_AX;
                    MOV  Dx,ax
                    POP  ax;
                    RET;
                    END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                    push eax;
                    call ЗНАЧЕНИЕ_ПЕРВОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_AX;
                    mov  eCx,eax                         ;
                    call ЗНАЧЕНИЕ_ВТОРОГО_ВЛОЖЕНОГО_ЭЛЕМЕНТА_DI_В_AX;
                    MOV  eDx,eax
                    POP  eax;
                    RET;
                    END IF;}
;==============================================================================}
;==============================================================================}
;{ ФУНКЦИИ ДЛЯ РАБОТЫ C ОКНАМИ                                          .

;---{ Параметры окна

ОКНО_ПАР:;{ Чтение параметра окна DI с именем AX если такого параметра нет возвращает флаг переполнения
IF  (ПЛАТФОРМА = ДОС)   ;{
        Push DI        ;
        push cx        ;
        mov  cx,ax     ;
        mov  ax,0      ;
        test di,di     ;
        jz  .ВЫХОД     ;
        call ЭЛЕ_ПОСЛЕД;// Ищим последний элемент в окне
        call ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI ;// Ищим элемент с таким именем
        JZ  .ВЫХОД     ;// Если нет такого параметра элемента выход

        call ЭЛЕ_ЗНА    ;// достаем значение этого параметра

.ВЫХОД: test ax,ax     ;
        pop  cx        ;
        pop  DI        ;
        ret            ;
        END IF         ;}
IF  (ПЛАТФОРМА = T16)   ;{
        Push DI        ;
        push cx        ;
        mov  cx,ax     ;
        mov  ax,0      ;
        test di,di     ;
        jz  .ВЫХОД     ;
        call ЭЛЕ_ПОСЛЕД;// Ищим последний элемент в окне
        call ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI ;// Ищим элемент с таким именем
        JZ  .ВЫХОД     ;// Если нет такого параметра элемента выход

        call ЭЛЕ_ЗНА    ;// достаем значение этого параметра

.ВЫХОД: test ax,ax     ;
        pop  cx        ;
        pop  DI        ;
        ret            ;
        END IF         ;}
IF  (ПЛАТФОРМА = T32)   ;{
        Push EDI        ;
        push Ecx        ;
        mov  Ecx,Eax     ;
        mov  Eax,0      ;
        test Edi,Edi     ;
        jz  .ВЫХОД     ;
        call ЭЛЕ_ПОСЛЕД;// Ищим последний элемент в окне
        call ПОИСК_ЭЛЕМЕНТА_ПО_КОДУ_CX_С_ЭЛЕМЕНТА_DI ;// Ищим элемент с таким именем
        JZ  .ВЫХОД     ;// Если нет такого параметра элемента выход

        call ЭЛЕ_ЗНА    ;// достаем значение этого параметра

.ВЫХОД: test Eax,Eax     ;
        pop  Ecx        ;
        pop  EDI        ;
        ret            ;
        END IF         ;}

;==============================================================================}
ОКНО_РАМ:;{ ЧТение Рамки для окна DI  возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
         mov  AX,КОД_ПАР_РАМК;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
         mov  AX,КОД_ПАР_РАМК;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
         mov  EAX,КОД_ПАР_РАМК;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         ret;
         END IF;}
;==============================================================================}
ОКНО_РЕД:;{ ЧТение параметра возможности редактировать содержимого окна Рамки для окна DI  возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
         mov  AX,КОД_ПАР_РЕДА;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
         mov  AX,КОД_ПАР_РЕДА;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
         mov  EAX,КОД_ПАР_РЕДА;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         ret;
         END IF;}
;==============================================================================}
ОКНО_ВИД:;{ ЧТение параметра Видимости окна Рамки для окна DI  возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
         mov  AX,КОД_ПАР_ВИДИ;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
         mov  AX,КОД_ПАР_ВИДИ;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
         mov  EAX,КОД_ПАР_ВИДИ;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         ret;
         END IF;}
;==============================================================================}
ОКНО_ПЕР:;{ ЧТение параметра возможнеости перемещения окна DI  возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
         mov  AX,КОД_ПАР_ПЕРЕ;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
         mov  AX,КОД_ПАР_ПЕРЕ;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
         mov  EAX,КОД_ПАР_ПЕРЕ;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         ret;
         END IF;}
;==============================================================================}

СБРОС_КЕША:;{
mov [ОКНО_ЛЕВ_DI],Dword 0;
mov [ОКНО_ВЕР_DI],Dword 0;
mov [ОКНО_ШИР_DI],Dword 0;
mov [ОКНО_ВЫС_DI],Dword 0;

mov [ОКНО_АТР_DI],Dword 0;
mov [ОКНО_АТР_AX],Dword 0;
mov [ОКНО_АКУ_DI],dword 0;
mov [ОКНО_АКУ_AX],Dword 0;
mov [ОКНО_ТЕК_DI],Dword 0;
mov [ОКНО_ТЕК_AX],Dword 0;
mov [ОКНО_АЛЕ_DI],Dword 0;
mov [ОКНО_АЛЕ_AX],Dword 0;
mov [ОКНО_АВЕ_DI],Dword 0;
mov [ОКНО_АПР_DI],Dword 0;
mov [ОКНО_АПР_AX],Dword 0;
mov [ОКНО_АНИ_DI],Dword 0;
mov [ОКНО_АНИ_AX],dword 0;
ret
;}

ОКНО_ЛЕВ_DI:dd 0;
ОКНО_ЛЕВ_AX:dd 0;
ОКНО_ВЕР_DI:dd 0;
ОКНО_ВЕР_AX:dd 0;
ОКНО_ШИР_DI:dd 0;
ОКНО_ШИР_AX:dd 0;
ОКНО_ВЫС_DI:dd 0;
ОКНО_ВЫС_AX:dd 0;

ОКНО_АТР_DI:dd 0;
ОКНО_АТР_AX:dd 0;
ОКНО_АКУ_DI:dd 0;
ОКНО_АКУ_AX:dd 0;
ОКНО_ТЕК_DI:dd 0;
ОКНО_ТЕК_AX:dd 0;
ОКНО_АЛЕ_DI:dd 0;
ОКНО_АЛЕ_AX:dd 0;
ОКНО_АВЕ_DI:dd 0;
ОКНО_АВЕ_AX:dd 0;
ОКНО_АПР_DI:dd 0;
ОКНО_АПР_AX:dd 0;
ОКНО_АНИ_DI:dd 0;
ОКНО_АНИ_AX:dd 0;


ОКНО_ЛЕВ_DI2:dd 0;
ОКНО_ЛЕВ_AX2:dd 0;
ОКНО_ВЕР_DI2:dd 0;
ОКНО_ВЕР_AX2:dd 0;
ОКНО_ШИР_DI2:dd 0;
ОКНО_ШИР_AX2:dd 0;
ОКНО_ВЫС_DI2:dd 0;
ОКНО_ВЫС_AX2:dd 0;

ОКНО_АТР_DI2:dd 0;
ОКНО_АТР_AX2:dd 0;
ОКНО_АКУ_DI2:dd 0;
ОКНО_АКУ_AX2:dd 0;
ОКНО_ТЕК_DI2:dd 0;
ОКНО_ТЕК_AX2:dd 0;
ОКНО_АЛЕ_DI2:dd 0;
ОКНО_АЛЕ_AX2:dd 0;
ОКНО_АВЕ_DI2:dd 0;
ОКНО_АВЕ_AX2:dd 0;
ОКНО_АПР_DI2:dd 0;
ОКНО_АПР_AX2:dd 0;
ОКНО_АНИ_DI2:dd 0;
ОКНО_АНИ_AX2:dd 0;

;-----------------------------------------------------------------------
ОКНО_ЛЕВ:;{ Чтение координат по X для окна DI  возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
;{КЕШ
         cmp  di,[ОКНО_ЛЕВ_DI];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_ЛЕВ_AX];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_ЛЕВ2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}


         mov  AX,КОД_ПАР_ЛЕВО;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         mov [ОКНО_ЛЕВ_DI],DI;
         mov [ОКНО_ЛЕВ_AX],AX;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
;{КЕШ
         cmp  di,[ОКНО_ЛЕВ_DI];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_ЛЕВ_AX];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_ЛЕВ2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
         mov  AX,КОД_ПАР_ЛЕВО;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         mov [ОКНО_ЛЕВ_DI],DI;
         mov [ОКНО_ЛЕВ_AX],AX;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
;{КЕШ
         cmp  Edi,[ОКНО_ЛЕВ_DI];
         jnz .НОВОЕ;
         mov  EAx,[ОКНО_ЛЕВ_AX];
         test Eax,Eax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_ЛЕВ2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
         mov  EAX,КОД_ПАР_ЛЕВО;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         mov [ОКНО_ЛЕВ_DI],EDI;
         mov [ОКНО_ЛЕВ_AX],EAX;
         ret;
         END IF;}
;==============================================================================}
ОКНО_ВЕР:;{ Чтение координат по Y для окна DI  возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
;{КЕШ
         cmp  di,[ОКНО_ВЕР_DI];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_ВЕР_AX];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_ВЕР2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
         mov  AX,КОД_ПАР_ВЕРХ;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР;
         mov [ОКНО_ВЕР_DI],DI;
         mov [ОКНО_ВЕР_AX],AX;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
;{КЕШ
         cmp  di,[ОКНО_ВЕР_DI];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_ВЕР_AX];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_ВЕР2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
         mov  AX,КОД_ПАР_ВЕРХ;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР;
         mov [ОКНО_ВЕР_DI],DI;
         mov [ОКНО_ВЕР_AX],AX;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
;{КЕШ
         cmp  edi,[ОКНО_ВЕР_DI];
         jnz .НОВОЕ;
         mov  eAx,[ОКНО_ВЕР_AX];
         test eax,eax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_ВЕР2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
         mov  EAX,КОД_ПАР_ВЕРХ;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР;
         mov [ОКНО_ВЕР_DI],EDI;
         mov [ОКНО_ВЕР_AX],EAX;
         ret;
         END IF;}
;==============================================================================}
ОКНО_ШИР:;{ Чтение ширину  окна по X для окна DI возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
;{КЕШ
         cmp  di,[ОКНО_ШИР_DI];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_ШИР_AX];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_ШИР2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
         mov  AX,КОД_ПАР_ШИРИ;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         mov [ОКНО_ШИР_DI],DI;
         mov [ОКНО_ШИР_AX],AX;
         ret           ;
         END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
;{КЕШ
         cmp  di,[ОКНО_ШИР_DI];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_ШИР_AX];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_ШИР2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
         mov  AX,КОД_ПАР_ШИРИ;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         mov [ОКНО_ШИР_DI],DI;
         mov [ОКНО_ШИР_AX],AX;
         ret           ;
         END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
;{КЕШ
         cmp  edi,[ОКНО_ШИР_DI];
         jnz .НОВОЕ;
         mov  eAx,[ОКНО_ШИР_AX];
         test eax,eax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_ШИР2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
         mov  EAX,КОД_ПАР_ШИРИ;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         mov [ОКНО_ШИР_DI],EDI;
         mov [ОКНО_ШИР_AX],EAX;
         ret           ;
         END IF;}
;==============================================================================}
ОКНО_ВЫС:;{ Чтение Высоту  окна по Y для окна DI возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
;{КЕШ
         cmp  di,[ОКНО_ВЫС_DI];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_ВЫС_AX];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_ВЫС2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
         mov  AX,КОД_ПАР_ВЫСО;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР;
         mov [ОКНО_ВЫС_DI],DI;
         mov [ОКНО_ВЫС_AX],AX;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
;{КЕШ
         cmp  di,[ОКНО_ВЫС_DI];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_ВЫС_AX];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_ВЫС2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
         mov  AX,КОД_ПАР_ВЫСО;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР;
         mov [ОКНО_ВЫС_DI],DI;
         mov [ОКНО_ВЫС_AX],AX;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
;{КЕШ
         cmp  edi,[ОКНО_ВЫС_DI];
         jnz .НОВОЕ;
         mov  eAx,[ОКНО_ВЫС_AX];
         test eax,eax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_ВЫС2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
         mov  EAX,КОД_ПАР_ВЫСО;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР;
         mov [ОКНО_ВЫС_DI],EDI;
         mov [ОКНО_ВЫС_AX],EAX;
         ret;
         END IF;}
;==============================================================================}

ОКНО_ЛЕВ2:;{ Чтение координат по X для окна DI  возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
;{КЕШ
         cmp  di,[ОКНО_ЛЕВ_DI2];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_ЛЕВ_AX2];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
         mov  AX,КОД_ПАР_ЛЕВО;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         mov [ОКНО_ЛЕВ_DI2],DI;
         mov [ОКНО_ЛЕВ_AX2],AX;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
;{КЕШ
         cmp  di,[ОКНО_ЛЕВ_DI2];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_ЛЕВ_AX2];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
         mov  AX,КОД_ПАР_ЛЕВО;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         mov [ОКНО_ЛЕВ_DI2],DI;
         mov [ОКНО_ЛЕВ_AX2],AX;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
;{КЕШ
         cmp  Edi,[ОКНО_ЛЕВ_DI2];
         jnz .НОВОЕ;
         mov  EAx,[ОКНО_ЛЕВ_AX2];
         test Eax,Eax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
         mov  EAX,КОД_ПАР_ЛЕВО;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         mov [ОКНО_ЛЕВ_DI2],EDI;
         mov [ОКНО_ЛЕВ_AX2],EAX;
         ret;
         END IF;}
;==============================================================================}
ОКНО_ВЕР2:;{ Чтение координат по Y для окна DI  возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
;{КЕШ
         cmp  di,[ОКНО_ВЕР_DI2];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_ВЕР_AX2];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
         mov  AX,КОД_ПАР_ВЕРХ;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР;
         mov [ОКНО_ВЕР_DI2],DI;
         mov [ОКНО_ВЕР_AX2],AX;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
;{КЕШ
         cmp  di,[ОКНО_ВЕР_DI2];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_ВЕР_AX2];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
         mov  AX,КОД_ПАР_ВЕРХ;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР;
         mov [ОКНО_ВЕР_DI2],DI;
         mov [ОКНО_ВЕР_AX2],AX;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
;{КЕШ
         cmp  edi,[ОКНО_ВЕР_DI2];
         jnz .НОВОЕ;
         mov  eAx,[ОКНО_ВЕР_AX2];
         test eax,eax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
         mov  EAX,КОД_ПАР_ВЕРХ;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР;
         mov [ОКНО_ВЕР_DI2],EDI;
         mov [ОКНО_ВЕР_AX2],EAX;
         ret;
         END IF;}
;==============================================================================}
ОКНО_ШИР2:;{ Чтение ширину  окна по X для окна DI возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
;{КЕШ
         cmp  di,[ОКНО_ШИР_DI2];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_ШИР_AX2];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
         mov  AX,КОД_ПАР_ШИРИ;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         mov [ОКНО_ШИР_DI2],DI;
         mov [ОКНО_ШИР_AX2],AX;
         ret           ;
         END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
;{КЕШ
         cmp  di,[ОКНО_ШИР_DI2];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_ШИР_AX2];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
         mov  AX,КОД_ПАР_ШИРИ;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         mov [ОКНО_ШИР_DI2],DI;
         mov [ОКНО_ШИР_AX2],AX;
         ret           ;
         END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
;{КЕШ
         cmp  edi,[ОКНО_ШИР_DI2];
         jnz .НОВОЕ;
         mov  eAx,[ОКНО_ШИР_AX2];
         test eax,eax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
         mov  EAX,КОД_ПАР_ШИРИ;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         mov [ОКНО_ШИР_DI2],EDI;
         mov [ОКНО_ШИР_AX2],EAX;
         ret           ;
         END IF;}
;==============================================================================}
ОКНО_ВЫС2:;{ Чтение Высоту  окна по Y для окна DI возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
;{КЕШ
         cmp  di,[ОКНО_ВЫС_DI2];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_ВЫС_AX2];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
         mov  AX,КОД_ПАР_ВЫСО;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР;
         mov [ОКНО_ВЫС_DI2],DI;
         mov [ОКНО_ВЫС_AX2],AX;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
;{КЕШ
         cmp  di,[ОКНО_ВЫС_DI2];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_ВЫС_AX2];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
         mov  AX,КОД_ПАР_ВЫСО;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР;
         mov [ОКНО_ВЫС_DI2],DI;
         mov [ОКНО_ВЫС_AX2],AX;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
;{КЕШ
         cmp  edi,[ОКНО_ВЫС_DI2];
         jnz .НОВОЕ;
         mov  eAx,[ОКНО_ВЫС_AX2];
         test eax,eax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
         mov  EAX,КОД_ПАР_ВЫСО;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР;
         mov [ОКНО_ВЫС_DI2],EDI;
         mov [ОКНО_ВЫС_AX2],EAX;
         ret;
         END IF;}
;==============================================================================}

;-----------------------------------------------------------------------
ОКНО_ТСX:;{ Чтение смещение текста  X нутри окна DI возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
        mov  AX,КОД_ПАР_ТСМX;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        ret            ;
        END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
        mov  AX,КОД_ПАР_ТСМX;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        ret            ;
        END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
        mov  EAX,КОД_ПАР_ТСМX;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        ret            ;
        END IF;}
;==============================================================================}
ОКНО_ТСY:;{ Чтение смещение текста  Y нутри окна DI возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
         mov  AX,КОД_ПАР_ТСМY;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР  ;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
         mov  AX,КОД_ПАР_ТСМY;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР  ;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
         mov  EAX,КОД_ПАР_ТСМY;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР  ;
         ret;
         END IF;}

;==============================================================================}
ОКНО_ТКX:;{ Чтение координат курсора X нутри окна DI возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
        mov  AX,КОД_ПАР_ТКУX;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
        mov  AX,КОД_ПАР_ТКУX;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
        mov  EAX,КОД_ПАР_ТКУX;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        ret;
        END IF;}
;==============================================================================}
ОКНО_ТКY:;{ Чтение координат курсора Y нутри окна DI возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
         mov  AX,КОД_ПАР_ТКУY;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР  ;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
         mov  AX,КОД_ПАР_ТКУY;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР  ;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
         mov  EAX,КОД_ПАР_ТКУY;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР  ;
         ret;
         END IF;}
;==============================================================================}
;-----------------------------------------------------------------------
ОКНО_АТР:;{ Читает атрибуты окна DI возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
;{КЕШ
         cmp  di,[ОКНО_АТР_DI];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_АТР_AX];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_АТР2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
        mov  AX,КОД_ПАР_АТРИ;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        mov [ОКНО_АТР_DI],DI;
        mov [ОКНО_АТР_AX],AX;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
;{КЕШ
         cmp  di,[ОКНО_АТР_DI];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_АТР_AX];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_АТР2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
        mov  AX,КОД_ПАР_АТРИ;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        mov [ОКНО_АТР_DI],DI;
        mov [ОКНО_АТР_AX],AX;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
;{КЕШ
         cmp  edi,[ОКНО_АТР_DI];
         jnz .НОВОЕ;
         mov  eAx,[ОКНО_АТР_AX];
         test eax,eax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_АТР2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
        mov  EAX,КОД_ПАР_АТРИ;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        mov [ОКНО_АТР_DI],EDI;
        mov [ОКНО_АТР_AX],EAX;
        ret;
        END IF;}
;==============================================================================}
ОКНО_АКУ:;{ Читает атрибуты курсора DI возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
;{КЕШ
         cmp  di,[ОКНО_АКУ_DI];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_АКУ_AX];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_АКУ2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
        mov  AX,КОД_ПАР_АКУР;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        mov [ОКНО_АКУ_DI],DI;
        mov [ОКНО_АКУ_AX],AX;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
;{КЕШ
         cmp  di,[ОКНО_АКУ_DI];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_АКУ_AX];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_АКУ2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
        mov  AX,КОД_ПАР_АКУР;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        mov [ОКНО_АКУ_DI],DI;
        mov [ОКНО_АКУ_AX],AX;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
;{КЕШ
         cmp  edi,[ОКНО_АКУ_DI];
         jnz .НОВОЕ;
         mov  eAx,[ОКНО_АКУ_AX];
         test eax,eax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_АКУ2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
        mov  EAX,КОД_ПАР_АКУР;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        mov [ОКНО_АКУ_DI],EDI;
        mov [ОКНО_АКУ_AX],EAX;
        ret;
        END IF;}
;==============================================================================}
ОКНО_ТЕК:;{ Читает адреса текста окна  DI возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
;{КЕШ
         cmp  di,[ОКНО_ТЕК_DI];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_ТЕК_AX];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_ТЕК2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
        mov  AX,КОД_ПАР_ТЕКС;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        mov [ОКНО_ТЕК_DI],DI;
        mov [ОКНО_ТЕК_AX],AX;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
;{КЕШ
         cmp  di,[ОКНО_ТЕК_DI];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_ТЕК_AX];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_ТЕК2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
        mov  AX,КОД_ПАР_ТЕКС;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        mov [ОКНО_ТЕК_DI],DI;
        mov [ОКНО_ТЕК_AX],AX;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
;{КЕШ
         cmp  edi,[ОКНО_ТЕК_DI];
         jnz .НОВОЕ;
         mov  eAx,[ОКНО_ТЕК_AX];
         test eax,eax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_ТЕК2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
        mov  EAX,КОД_ПАР_ТЕКС;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        mov [ОКНО_ТЕК_DI],EDI;
        mov [ОКНО_ТЕК_AX],EAX;
        ret;
        END IF;}
;==============================================================================}
ОКНО_АЛЕ:;{ Чтение абсолютных координат по X для окна возвращает в AX
IF  (ПЛАТФОРМА = ДОС)   ;{
;{КЕШ
         cmp  di,[ОКНО_АЛЕ_DI];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_АЛЕ_AX];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_АЛЕ2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
        mov [ОКНО_АЛЕ_DI],DI;
        push cx         ;
        push di         ;
        push dx         ;
        call ОКНО_ЛЕВ   ;// Теперь в AX WIN_LEF окна DI;
        mov  dx,ax      ;
        MOV  cx,КОД_ПАР_ЛЕВО;// Указываем что будеи искать WIN_LEF
        call ЭЛЕ_ПАРСУМ ;// Находим сумму всех окон с параметром WIN_LEF;
        add  ax,dx      ;// Прибавляем сумму всех параметров WIN_LEF в предках
        mov [ОКНО_АЛЕ_AX],AX;
        pop  dx         ;
        pop  di         ;
        pop  cx         ;
        ret             ;
        END IF          ;}
IF  (ПЛАТФОРМА = T16)   ;{
;{КЕШ
         cmp  di,[ОКНО_АЛЕ_DI];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_АЛЕ_AX];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_АЛЕ2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
        mov [ОКНО_АЛЕ_DI],DI;
        push cx         ;
        push di         ;
        push dx         ;
        call ОКНО_ЛЕВ   ;// Теперь в AX WIN_LEF окна DI;
        mov  dx,ax      ;
        MOV  cx,КОД_ПАР_ЛЕВО;// Указываем что будеи искать WIN_LEF
        call ЭЛЕ_ПАРСУМ ;// Находим сумму всех окон с параметром WIN_LEF;
        add  ax,dx      ;// Прибавляем сумму всех параметров WIN_LEF в предках
        mov [ОКНО_АЛЕ_AX],AX;
        pop  dx         ;
        pop  di         ;
        pop  cx         ;
        ret             ;
        END IF          ;}
IF  (ПЛАТФОРМА = T32)   ;{
;{КЕШ
         cmp  edi,[ОКНО_АЛЕ_DI];
         jnz .НОВОЕ;
         mov  eAx,[ОКНО_АЛЕ_AX];
         test eax,eax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_АЛЕ2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
        pushad;
        mov [ОКНО_АЛЕ_DI],EDI;

        call ОКНО_ЛЕВ     ;// Теперь в AX WIN_LEF окна DI;
        mov  edx,eax      ;
        MOV  ecx,КОД_ПАР_ЛЕВО;// Указываем что будеи искать WIN_LEF
        call ЭЛЕ_ПАРСУМ   ;// Находим сумму всех окон с параметром WIN_LEF;
        add  eax,edx      ;// Прибавляем сумму всех параметров WIN_LEF в предках
        call ВОЗВРАТИТЬ_AX;
        mov [ОКНО_АЛЕ_AX],EAX;
        popad             ;
        ret               ;
        END IF            ;}
;==============================================================================}
ОКНО_АВЕ:;{ Чтение абсолютных координат по Y для окна возвращает в AX
IF  (ПЛАТФОРМА = ДОС)   ;{
;{КЕШ
         cmp  di,[ОКНО_АВЕ_DI];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_АВЕ_AX];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_АВЕ2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
        mov [ОКНО_АВЕ_DI],DI;
        push cx        ;
        push di        ;
        push dx        ;
        call ОКНО_ВЕР  ;// Теперь в AX WIN_TOP окна DI;
        mov  dx,ax;
        MOV  cx,КОД_ПАР_ВЕРХ;// Указываем что будеи искать WIN_TOP
        call ЭЛЕ_ПАРСУМ;// Находим сумму всех окон с параметром WIN_TOP;
        add  ax,dx     ;// Прибавляем сумму всех параметров WIN_TOP в предках
        mov [ОКНО_АВЕ_AX],AX;
        pop  dx        ;
        pop  di        ;
        pop  cx        ;
        ret            ;
        END IF         ;}
IF  (ПЛАТФОРМА = T16)   ;{
;{КЕШ
         cmp  di,[ОКНО_АВЕ_DI];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_АВЕ_AX];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_АВЕ2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
        mov [ОКНО_АВЕ_DI],DI;
        push cx        ;
        push di        ;
        push dx        ;
        call ОКНО_ВЕР  ;// Теперь в AX WIN_TOP окна DI;
        mov  dx,ax;
        MOV  cx,КОД_ПАР_ВЕРХ;// Указываем что будеи искать WIN_TOP
        call ЭЛЕ_ПАРСУМ;// Находим сумму всех окон с параметром WIN_TOP;
        add  ax,dx     ;// Прибавляем сумму всех параметров WIN_TOP в предках
        mov [ОКНО_АВЕ_AX],AX;
        pop  dx        ;
        pop  di        ;
        pop  cx        ;
        ret            ;
        END IF         ;}
IF  (ПЛАТФОРМА = T32)   ;{
;{КЕШ
         cmp  edi,[ОКНО_АВЕ_DI];
         jnz .НОВОЕ;
         mov  eAx,[ОКНО_АВЕ_AX];
         test eax,eax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_АВЕ2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
        mov [ОКНО_АВЕ_DI],EDI;
        push cx        ;
        push di        ;
        push dx        ;
        call ОКНО_ВЕР  ;// Теперь в AX WIN_TOP окна DI;
        mov  dx,ax;
        MOV  cx,КОД_ПАР_ВЕРХ;// Указываем что будеи искать WIN_TOP
        call ЭЛЕ_ПАРСУМ;// Находим сумму всех окон с параметром WIN_TOP;
        add  ax,dx     ;// Прибавляем сумму всех параметров WIN_TOP в предках
        mov [ОКНО_АВЕ_AX],EAX;
        pop  dx        ;
        pop  di        ;
        pop  cx        ;
        ret            ;
        END IF         ;}
;==============================================================================}
ОКНО_АПР:;{ Вычисление Абсолютных координат правой стороны окна DI в AX X2 Right
IF  (ПЛАТФОРМА = ДОС)   ;{
;{КЕШ
         cmp  di,[ОКНО_АПР_DI];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_АПР_AX];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_АПР2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
        mov [ОКНО_АПР_DI],DI;
        push cx;
        Call ОКНО_АЛЕ;
        Mov  CX,ax;
        Call ОКНО_ШИР;
        Add  Ax,CX;
        mov [ОКНО_АПР_AX],AX;
        pop  cx;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
;{КЕШ
         cmp  di,[ОКНО_АПР_DI];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_АПР_AX];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_АПР2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
        mov [ОКНО_АПР_DI],DI;
        push cx;
        Call ОКНО_АЛЕ;
        Mov  CX,ax;
        Call ОКНО_ШИР;
        Add  Ax,CX;
        mov [ОКНО_АПР_AX],AX;
        pop  cx;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
;{КЕШ
         cmp  edi,[ОКНО_АПР_DI];
         jnz .НОВОЕ;
         mov  eAx,[ОКНО_АПР_AX];
         test eax,eax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_АПР2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
        mov [ОКНО_АПР_DI],eDI;
        push cx;
        Call ОКНО_АЛЕ;
        Mov  CX,ax;
        Call ОКНО_ШИР;
        Add  Ax,CX;
        mov [ОКНО_АПР_AX],eAX;
        pop  cx;
        ret;
        END IF;}
;==============================================================================}
ОКНО_АНИ:;{ Вычисление Абсолютных координат нижней  стороны окна Y2 Bootom
IF  (ПЛАТФОРМА = ДОС)   ;{
;{КЕШ
         cmp  di,[ОКНО_АНИ_DI];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_АНИ_AX];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_АНИ2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
        mov [ОКНО_АНИ_DI],DI;
        push cx;
        Call ОКНО_АВЕ;
        Mov  CX,ax;
        Call ОКНО_ВЫС;
        Add  Ax,CX;
        mov [ОКНО_АНИ_AX],AX;
        pop  cx;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
;{КЕШ
         cmp  di,[ОКНО_АНИ_DI];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_АНИ_AX];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_АНИ2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
        mov [ОКНО_АНИ_DI],DI;
        push cx;
        Call ОКНО_АВЕ;
        Mov  CX,ax;
        Call ОКНО_ВЫС;
        Add  Ax,CX;
        mov [ОКНО_АНИ_AX],AX;
        pop  cx;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
;{КЕШ
         cmp  Edi,[ОКНО_АНИ_DI];
         jnz .НОВОЕ;
         mov  EAx,[ОКНО_АНИ_AX];
         test Eax,Eax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:  call ОКНО_АНИ2;
         jz  .НОВОЕ2;
         ret ;
.НОВОЕ2:
;}
        mov [ОКНО_АНИ_DI],EDI;
        push cx;
        Call ОКНО_АВЕ;
        Mov  CX,ax;
        Call ОКНО_ВЫС;
        Add  Ax,CX;
        mov [ОКНО_АНИ_AX],EAX;
        pop  cx;
        ret;
        END IF;}
;==============================================================================}

ОКНО_АТР2:;{ Читает атрибуты окна DI возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
;{КЕШ
         cmp  di,[ОКНО_АТР_DI2];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_АТР_AX2];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
        mov  AX,КОД_ПАР_АТРИ;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        mov [ОКНО_АТР_DI2],DI;
        mov [ОКНО_АТР_AX2],AX;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
;{КЕШ
         cmp  di,[ОКНО_АТР_DI2];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_АТР_AX2];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
        mov  AX,КОД_ПАР_АТРИ;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        mov [ОКНО_АТР_DI2],DI;
        mov [ОКНО_АТР_AX2],AX;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
;{КЕШ
         cmp  edi,[ОКНО_АТР_DI2];
         jnz .НОВОЕ;
         mov  eAx,[ОКНО_АТР_AX2];
         test eax,eax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
        mov  EAX,КОД_ПАР_АТРИ;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        mov [ОКНО_АТР_DI2],EDI;
        mov [ОКНО_АТР_AX2],EAX;
        ret;
        END IF;}
;==============================================================================}
ОКНО_АКУ2:;{ Читает атрибуты курсора DI возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
;{КЕШ
         cmp  di,[ОКНО_АКУ_DI2];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_АКУ_AX2];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
        mov  AX,КОД_ПАР_АКУР;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        mov [ОКНО_АКУ_DI2],DI;
        mov [ОКНО_АКУ_AX2],AX;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
;{КЕШ
         cmp  di,[ОКНО_АКУ_DI2];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_АКУ_AX2];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
        mov  AX,КОД_ПАР_АКУР;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        mov [ОКНО_АКУ_DI2],DI;
        mov [ОКНО_АКУ_AX2],AX;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
;{КЕШ
         cmp  edi,[ОКНО_АКУ_DI2];
         jnz .НОВОЕ;
         mov  eAx,[ОКНО_АКУ_AX2];
         test eax,eax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
        mov  EAX,КОД_ПАР_АКУР;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        mov [ОКНО_АКУ_DI2],EDI;
        mov [ОКНО_АКУ_AX2],EAX;
        ret;
        END IF;}
;==============================================================================}
ОКНО_ТЕК2:;{ Читает адреса текста окна  DI возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
;{КЕШ
         cmp  di,[ОКНО_ТЕК_DI2];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_ТЕК_AX2];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
        mov  AX,КОД_ПАР_ТЕКС;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        mov [ОКНО_ТЕК_DI2],DI;
        mov [ОКНО_ТЕК_AX2],AX;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
;{КЕШ
         cmp  di,[ОКНО_ТЕК_DI2];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_ТЕК_AX2];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
        mov  AX,КОД_ПАР_ТЕКС;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        mov [ОКНО_ТЕК_DI2],DI;
        mov [ОКНО_ТЕК_AX2],AX;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
;{КЕШ
         cmp  edi,[ОКНО_ТЕК_DI2];
         jnz .НОВОЕ;
         mov  eAx,[ОКНО_ТЕК_AX2];
         test eax,eax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
        mov  EAX,КОД_ПАР_ТЕКС;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        mov [ОКНО_ТЕК_DI2],EDI;
        mov [ОКНО_ТЕК_AX2],EAX;
        ret;
        END IF;}
;==============================================================================}
ОКНО_АЛЕ2:;{ Чтение абсолютных координат по X для окна возвращает в AX
IF  (ПЛАТФОРМА = ДОС)   ;{
;{КЕШ
         cmp  di,[ОКНО_АЛЕ_DI2];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_АЛЕ_AX2];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
        mov [ОКНО_АЛЕ_DI2],DI;
        push cx         ;
        push di         ;
        push dx         ;
        call ОКНО_ЛЕВ   ;// Теперь в AX WIN_LEF окна DI;
        mov  dx,ax      ;
        MOV  cx,КОД_ПАР_ЛЕВО;// Указываем что будеи искать WIN_LEF
        call ЭЛЕ_ПАРСУМ ;// Находим сумму всех окон с параметром WIN_LEF;
        add  ax,dx      ;// Прибавляем сумму всех параметров WIN_LEF в предках
        mov [ОКНО_АЛЕ_AX2],AX;
        pop  dx         ;
        pop  di         ;
        pop  cx         ;
        ret             ;
        END IF          ;}
IF  (ПЛАТФОРМА = T16)   ;{
;{КЕШ
         cmp  di,[ОКНО_АЛЕ_DI2];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_АЛЕ_AX2];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
        mov [ОКНО_АЛЕ_DI2],DI;
        push cx         ;
        push di         ;
        push dx         ;
        call ОКНО_ЛЕВ   ;// Теперь в AX WIN_LEF окна DI;
        mov  dx,ax      ;
        MOV  cx,КОД_ПАР_ЛЕВО;// Указываем что будеи искать WIN_LEF
        call ЭЛЕ_ПАРСУМ ;// Находим сумму всех окон с параметром WIN_LEF;
        add  ax,dx      ;// Прибавляем сумму всех параметров WIN_LEF в предках
        mov [ОКНО_АЛЕ_AX2],AX;
        pop  dx         ;
        pop  di         ;
        pop  cx         ;
        ret             ;
        END IF          ;}
IF  (ПЛАТФОРМА = T32)   ;{
;{КЕШ
         cmp  edi,[ОКНО_АЛЕ_DI2];
         jnz .НОВОЕ;
         mov  eAx,[ОКНО_АЛЕ_AX2];
         test eax,eax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
        pushad;
        mov [ОКНО_АЛЕ_DI2],EDI;

        call ОКНО_ЛЕВ     ;// Теперь в AX WIN_LEF окна DI;
        mov  edx,eax      ;
        MOV  ecx,КОД_ПАР_ЛЕВО;// Указываем что будеи искать WIN_LEF
        call ЭЛЕ_ПАРСУМ   ;// Находим сумму всех окон с параметром WIN_LEF;
        add  eax,edx      ;// Прибавляем сумму всех параметров WIN_LEF в предках
        call ВОЗВРАТИТЬ_AX;
        mov [ОКНО_АЛЕ_AX2],EAX;
        popad             ;
        ret               ;
        END IF            ;}
;==============================================================================}
ОКНО_АВЕ2:;{ Чтение абсолютных координат по Y для окна возвращает в AX
IF  (ПЛАТФОРМА = ДОС)   ;{
;{КЕШ
         cmp  di,[ОКНО_АВЕ_DI2];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_АВЕ_AX2];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
        mov [ОКНО_АВЕ_DI2],DI;
        push cx        ;
        push di        ;
        push dx        ;
        call ОКНО_ВЕР  ;// Теперь в AX WIN_TOP окна DI;
        mov  dx,ax;
        MOV  cx,КОД_ПАР_ВЕРХ;// Указываем что будеи искать WIN_TOP
        call ЭЛЕ_ПАРСУМ;// Находим сумму всех окон с параметром WIN_TOP;
        add  ax,dx     ;// Прибавляем сумму всех параметров WIN_TOP в предках
        mov [ОКНО_АВЕ_AX2],AX;
        pop  dx        ;
        pop  di        ;
        pop  cx        ;
        ret            ;
        END IF         ;}
IF  (ПЛАТФОРМА = T16)   ;{
;{КЕШ
         cmp  di,[ОКНО_АВЕ_DI2];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_АВЕ_AX2];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
        mov [ОКНО_АВЕ_DI2],DI;
        push cx        ;
        push di        ;
        push dx        ;
        call ОКНО_ВЕР  ;// Теперь в AX WIN_TOP окна DI;
        mov  dx,ax;
        MOV  cx,КОД_ПАР_ВЕРХ;// Указываем что будеи искать WIN_TOP
        call ЭЛЕ_ПАРСУМ;// Находим сумму всех окон с параметром WIN_TOP;
        add  ax,dx     ;// Прибавляем сумму всех параметров WIN_TOP в предках
        mov [ОКНО_АВЕ_AX2],AX;
        pop  dx        ;
        pop  di        ;
        pop  cx        ;
        ret            ;
        END IF         ;}
IF  (ПЛАТФОРМА = T32)   ;{
;{КЕШ
         cmp  edi,[ОКНО_АВЕ_DI2];
         jnz .НОВОЕ;
         mov  eAx,[ОКНО_АВЕ_AX2];
         test eax,eax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
        mov [ОКНО_АВЕ_DI2],EDI;
        push cx        ;
        push di        ;
        push dx        ;
        call ОКНО_ВЕР  ;// Теперь в AX WIN_TOP окна DI;
        mov  dx,ax;
        MOV  cx,КОД_ПАР_ВЕРХ;// Указываем что будеи искать WIN_TOP
        call ЭЛЕ_ПАРСУМ;// Находим сумму всех окон с параметром WIN_TOP;
        add  ax,dx     ;// Прибавляем сумму всех параметров WIN_TOP в предках
        mov [ОКНО_АВЕ_AX2],EAX;
        pop  dx        ;
        pop  di        ;
        pop  cx        ;
        ret            ;
        END IF         ;}
;==============================================================================}
ОКНО_АПР2:;{ Вычисление Абсолютных координат правой стороны окна DI в AX X2 Right
IF  (ПЛАТФОРМА = ДОС)   ;{
;{КЕШ
         cmp  di,[ОКНО_АПР_DI2];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_АПР_AX2];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
        mov [ОКНО_АПР_DI2],DI;
        push cx;
        Call ОКНО_АЛЕ;
        Mov  CX,ax;
        Call ОКНО_ШИР;
        Add  Ax,CX;
        mov [ОКНО_АПР_AX2],AX;
        pop  cx;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
;{КЕШ
         cmp  di,[ОКНО_АПР_DI2];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_АПР_AX2];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
        mov [ОКНО_АПР_DI2],DI;
        push cx;
        Call ОКНО_АЛЕ;
        Mov  CX,ax;
        Call ОКНО_ШИР;
        Add  Ax,CX;
        mov [ОКНО_АПР_AX2],AX;
        pop  cx;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
;{КЕШ
         cmp  edi,[ОКНО_АПР_DI2];
         jnz .НОВОЕ;
         mov  eAx,[ОКНО_АПР_AX2];
         test eax,eax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
        mov [ОКНО_АПР_DI2],eDI;
        push cx;
        Call ОКНО_АЛЕ;
        Mov  CX,ax;
        Call ОКНО_ШИР;
        Add  Ax,CX;
        mov [ОКНО_АПР_AX2],eAX;
        pop  cx;
        ret;
        END IF;}
;==============================================================================}
ОКНО_АНИ2:;{ Вычисление Абсолютных координат нижней  стороны окна Y2 Bootom
IF  (ПЛАТФОРМА = ДОС)   ;{
;{КЕШ
         cmp  di,[ОКНО_АНИ_DI2];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_АНИ_AX2];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
        mov [ОКНО_АНИ_DI2],DI;
        push cx;
        Call ОКНО_АВЕ;
        Mov  CX,ax;
        Call ОКНО_ВЫС;
        Add  Ax,CX;
        mov [ОКНО_АНИ_AX2],AX;
        pop  cx;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
;{КЕШ
         cmp  di,[ОКНО_АНИ_DI2];
         jnz .НОВОЕ;
         mov  Ax,[ОКНО_АНИ_AX2];
         test ax,ax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
        mov [ОКНО_АНИ_DI2],DI;
        push cx;
        Call ОКНО_АВЕ;
        Mov  CX,ax;
        Call ОКНО_ВЫС;
        Add  Ax,CX;
        mov [ОКНО_АНИ_AX2],AX;
        pop  cx;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
;{КЕШ
         cmp  Edi,[ОКНО_АНИ_DI2];
         jnz .НОВОЕ;
         mov  EAx,[ОКНО_АНИ_AX2];
         test Eax,Eax
         jz  .НОВОЕ;
         ret ;
.НОВОЕ:
;}
        mov [ОКНО_АНИ_DI2],EDI;
        push cx;
        Call ОКНО_АВЕ;
        Mov  CX,ax;
        Call ОКНО_ВЫС;
        Add  Ax,CX;
        mov [ОКНО_АНИ_AX2],EAX;
        pop  cx;
        ret;
        END IF;}
;==============================================================================}
;-----------------------------------------------------------------------

ОКНО_АКX:;{ Чтение абсолютных координат курсора   X нутри окна DI возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
        push DX;
        mov  AX,КОД_ПАР_ТКУX;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        mov  dx,ax    ;
        mov  AX,КОД_ПАР_ТСМX;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        add  ax,Dx;
        test ax,ax;
        POP  DX;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
        push DX;
        mov  AX,КОД_ПАР_ТКУX;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        mov  dx,ax    ;
        mov  AX,КОД_ПАР_ТСМX;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        add  ax,Dx;
        test ax,ax;
        POP  DX;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
        push DX;
        mov  AX,КОД_ПАР_ТКУX;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        mov  dx,ax    ;
        mov  AX,КОД_ПАР_ТСМX;// Указываем имя элемиента котрый будем искать
        call ОКНО_ПАР  ;
        add  ax,Dx;
        test ax,ax;
        POP  DX;
        ret;
        END IF;}
;==============================================================================}
ОКНО_АКY:;{ Чтение координат курсора Y нутри окна DI возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
         push dx;
         mov  AX,КОД_ПАР_ТКУY;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР  ;
         mov  dx,ax;
         mov  AX,КОД_ПАР_ТСМY;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР  ;
         add  ax,dx;
         test ax,ax;
         pop  dx;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
         push dx;
         mov  AX,КОД_ПАР_ТКУY;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР  ;
         mov  dx,ax;
         mov  AX,КОД_ПАР_ТСМY;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР  ;
         add  ax,dx;
         test ax,ax;
         pop  dx;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
         push dx;
         mov  AX,КОД_ПАР_ТКУY;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР  ;
         mov  dx,ax;
         mov  AX,КОД_ПАР_ТСМY;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР  ;
         add  ax,dx;
         test ax,ax;
         pop  dx;
         ret;
         END IF;}
;==============================================================================}

ОКНО_КСК:;{ Количество символов в строке с курсром окна DI возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
          mov  AX,КОД_ПАР_КССК;// Указываем имя элемиента котрый будем искать
          call ОКНО_ПАР ;
          ret;
          END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
          mov  AX,КОД_ПАР_КССК;// Указываем имя элемиента котрый будем искать
          call ОКНО_ПАР ;
          ret;
          END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
          mov  AX,КОД_ПАР_КССК;// Указываем имя элемиента котрый будем искать
          call ОКНО_ПАР ;
          ret;
          END IF;}
;==============================================================================}
ОКНО_КСТ:;{ Чтение Реального количества строк текста Окно DI возвращает AX Количество строк
IF  (ПЛАТФОРМА = ДОС)   ;{
          mov  AX,КОД_ПАР_КОСТ;// Указываем имя элемиента котрый будем искать
          call ОКНО_ПАР ;
          ret;
          END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
          mov  AX,КОД_ПАР_КОСТ;// Указываем имя элемиента котрый будем искать
          call ОКНО_ПАР ;
          ret;
          END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
          mov  AX,КОД_ПАР_КОСТ;// Указываем имя элемиента котрый будем искать
          call ОКНО_ПАР ;
          ret;
          END IF;}
;==============================================================================}
ОКНО_ПАС:;{ окна DI возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
         mov  AX,КОД_ПАР_ПАВС;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
         mov  AX,КОД_ПАР_ПАВС;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
         mov  AX,КОД_ПАР_ПАВС;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         ret;
         END IF;}
;==============================================================================}
ОКНО_ДПС:;{ возвращает длину строки над курсором в окне DI возвращает AX
IF  (ПЛАТФОРМА = ДОС)   ;{
         mov  AX,КОД_ПАР_ДПСТ;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
         mov  AX,КОД_ПАР_ДПСТ;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
         mov  AX,КОД_ПАР_ДПСТ;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         ret;
         END IF;}
;==============================================================================}
ОКНО_БУФ:;{ Строка содержащия списко последних нажатых символов в окне
IF  (ПЛАТФОРМА = ДОС)   ;{
         mov  AX,КОД_ПАР_БУФЕ;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
         mov  AX,КОД_ПАР_БУФЕ;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
         mov  AX,КОД_ПАР_БУФЕ;// Указываем имя элемиента котрый будем искать
         call ОКНО_ПАР ;
         ret;
         END IF;}
;==============================================================================}

;---}
;---{ Обработка нажатых кнопок
ОКНО_КУР_ВПРА:;{ Перемещение крусора окна DI вправо
        pushad;
        call ОКНО_ТКX  ;// читаем кординату курсора
        mov  cx,ax    ;// Запоминаем координату курсорпа
        Call ОКНО_ШИР  ;// Читаем ширину окна
        dec  ax;
        cmp  cx,ax    ; // сравниваем координату крусора и ширину окна
        JAE .ДАЛЕЕ      ;
        INC  CX       ;// Сдвиагем курсор впрво
        mov  ax,cx    ;
        mov  cx,КОД_ПАР_ТКУX;
        call ЭЛЕ_УСТ_ПАР;
        jmp .ВЫХОД    ;
.ДАЛЕЕ:
        call ОКНО_ТСX  ;// Читаем смещенеи внутри текста
        inc  ax       ;// Увеличиваем смещение внтури текста
        mov  cx,КОД_ПАР_ТСМX;
        call ЭЛЕ_УСТ_ПАР;
.ВЫХОД:
        popad;
        ret;
;==============================================================================}
ОКНО_КУР_ВЛЕВ:;{ Перемещение крусора окна DI влево
         pushad;
         call ОКНО_ТКX    ;// читаем кординату курсора
         mov  cx,ax       ;// Запоминаем координату курсорпа

         test cx,cx       ; // сравниваем координату крусора если ноль то некст
         JZ  .ДАЛЕЕ       ;
         DEC  CX          ;// Сдвиагем курсор Влево
         mov  ax,cx       ;
         mov  cx,КОД_ПАР_ТКУX ;
         call ЭЛЕ_УСТ_ПАР ;
         jmp .ВЫХОД       ;
.ДАЛЕЕ:
         call ОКНО_ТСX    ;// Читаем смещенеи внутри текста
         test ax,ax       ;
         jz  .ПЕРЕХОД     ;
         dec  ax          ;// Увеличиваем смещение внтури текста
         mov  cx,КОД_ПАР_ТСМX ;
         call ЭЛЕ_УСТ_ПАР ;
         JMP .ВЫХОД       ;

.ПЕРЕХОД:
         call ОКНО_АКY    ;// Читаем координату курсора по Y
         test ax,ax       ;
         jz  .ВЫХОД       ;
         call ОКНО_ШИР    ;// Читаем ширину окна
         mov  dl,al       ;// Запоминиаем ширну окна
         call ОКНО_ДПС    ;// Читаем длиину предыдущей строки
         DIv  dl          ;// Делем на ширину окна
         mov  bx,ax       ;// Запоминаем рещультат деления

         xor  ax,ax       ;
         mov  al,bh       ;// остаток от деления будет координатой курсора в окне
         mov  cx,КОД_ПАР_ТКУX ;
         call ЭЛЕ_УСТ_ПАР ;

         mov   al,bl      ;// количество смещений в тексте размером в ширину окна
         mul   dl         ;// Умножаем на ширину окна
         mov   cx,КОД_ПАР_ТСМX;
         call  ЭЛЕ_УСТ_ПАР  ;
         call  ОКНО_КУР_ВВЕР;
.ВЫХОД:
         popad;
         ret;
;==============================================================================}
ОКНО_КУР_ВНИЗ:;{ Перемещение крусора окна DI Вниз
        pushad;
        call ОКНО_ТКY   ;// читаем кординату курсора
        mov  cx,ax      ;// Запоминаем координату курсорпа
        Call ОКНО_ВЫС   ;// Читаем  высоту окна
        dec  ax         ;
        cmp  cx,ax      ; // сравниваем координату крусора и высоту окна
        JAE .ДАЛЕЕ      ;
        INC  CX         ;// Сдвиагем курсор вниз
        mov  ax,cx      ;
        mov  cx,КОД_ПАР_ТКУY;
        call ЭЛЕ_УСТ_ПАР;
        jmp .ВЫХОД    ;
.ДАЛЕЕ:
        call ОКНО_ТСY  ;// Читаем смещенеи внутри текста
        inc  ax       ;// Увеличиваем смещение внтури текста
        mov  cx,КОД_ПАР_ТСМY;
        call ЭЛЕ_УСТ_ПАР;
.ВЫХОД:
        popad;
        ret;
;==============================================================================}
ОКНО_КУР_ВВЕР:;{ Перемещение крусора окна DI Вверх
        pushad;
        call ОКНО_ТКY   ;// читаем кординату курсора
        mov  cx,ax      ;// Запоминаем координату курсорпа
        JZ  .ДАЛЕЕ      ;
        DEC  CX         ;// Сдвиагем курсор вверх
        mov  ax,cx      ;
        mov  cx,КОД_ПАР_ТКУY;
        call ЭЛЕ_УСТ_ПАР;
        jmp .ВЫХОД      ;
.ДАЛЕЕ:
        call ОКНО_ТСY   ;// Читаем смещенеи внутри текста
        jz  .ВЫХОД      ;
        dec  ax         ;// уменьшаем  смещение внтури текста
        mov  cx,КОД_ПАР_ТСМY;
        call ЭЛЕ_УСТ_ПАР;
.ВЫХОД:
        popad;
        ret;
;==============================================================================}
ОКНО_КНО_УДЛЕ:;{ Удаление символа слева от курсора
              pushad;
              call ОКНО_АКX;
              jnz .ДАЛЕЕ;
              call ОКНО_АКY;
              jnz .ДАЛЕЕ;
              jmp .ВЫХОД;
.ДАЛЕЕ:
              call ОКНО_ПАС;
              mov  si,ax;
              Call УДАЛЕНИЕ_ИЗ_АДРЕСА_SI_СИМВОЛА_ДО_0;
              Call ОКНО_КУР_ВЛЕВ;

.ВЫХОД:
              popad;
              ret;
;==============================================================================}
ОКНО_КНО_БУКВ:;{ Обработка нажатия кнопок (Буквы цифры и тд и тп AL ) окна DI
              pushad;

              mov   di,[МЫШ_ВЫДЕ2]  ; // Указываем активное окно
              mov   bx,ax           ; // Запоминаем код нажатой кнопки

              ;---------------------;
              pushad
              call ОКНО_БУФ;
              mov  si,ax;
              mov  al,bl;
              call ДОБАВИТЬ_БУКВУ_AL_В_КОНЕЦ_СТРОКИ_SI
              popad;
              ;---------------------;


              call  ОКНО_ПАС        ; // Читаем предположительный адрес в строке куда нужно добавить символ сформированый в ОКНО_ВЫВОД_ТЕ
              mov   si,ax           ;

              ;// Дописываем не достающие переводы строки
              call  ОКНО_КСТ        ; // Читаем количество строк в тексте окна
              mov   cx,ax           ; // теперь в CX Количество строк в тексте
              call  ОКНО_АКY        ; // Читаем Абсолютную позицию курсора в тексте
              mov   dx,ax           ; // теперь в DX абсолютная координата курсора в тексте по Y
.ЦИКЛ2:       CMP   cx,dx           ;
              JA   .КЦИКЛ2          ;
              call  НАЙТИ_КОНЕЦ_СТРОКИ_С_АДРЕСА_SI;
              mov   al,13           ;
              call  ВСТАВКА_СИМВОЛА_AL_ПО_АДРЕСУ_SI_ДО_0;
              inc   CX              ;
              JMP  .ЦИКЛ2           ;

.КЦИКЛ2:
              ;// Дписываем не достающие пробелы если это необходимо
              call  ОКНО_КСК        ;// Читаем правй край в тексте где расположен курсор
              mov   dx,ax           ;// Запоминаем
              call  ОКНО_АКX        ;// Читаем абсолютную координату курсора по X
              mov   cx,ax;
.ЦИКЛ:        cmp   dx,cx           ;// Сравниваем правй край строки в котрой расположен курсор и координату курсора по X
              jae  .ДАЛЕЕ           ;
                                    ; Дописываем необходимое количество пробелов
              mov  al,' '           ;
              call ВСТАВКА_СИМВОЛА_AL_ПО_АДРЕСУ_SI_ДО_0;
              inc  SI               ;
              inc  dx               ;
              jmp .ЦИКЛ             ;
              ;----------------------
.ДАЛЕЕ:
              mov   ax,bx           ;
              cmp   ax,3592         ;
              jz   .ПРОПУСТИТЬ      ;

              call  ВСТАВКА_СИМВОЛА_AL_ПО_АДРЕСУ_SI_ДО_0;
              call  ОКНО_КУР_ВПРА   ;
.ПРОПУСТИТЬ:

              mov  ax,si;
              mov  cx,КОД_ПАР_ПАВС  ;
              call ЭЛЕ_УСТ_ПАР      ;

              popad                 ;
              ret                   ;
;==============================================================================}
ОКНО_КНО_ЕНТЕ:;{ ОБработка нажатия Энтер
             pushad;

             mov cx,КОД_ПАР_ТСМX;
             mov ax,0;
             call ЭЛЕ_УСТ_ПАР;

             mov cx,КОД_ПАР_ТКУX;
             mov ax,0;
             call ЭЛЕ_УСТ_ПАР;

             call ОКНО_КУР_ВНИЗ;
             call  ОКНО_ВЫВОД_ТЕ   ;
             popad;
             ret;
;---}
ОКНО_КНО_РАСК:;{ Обработка нажатия F10 раскладка клавиатуры
             pushad;
             mov  ax,[РАС_КЛАВ] ; // Читаем текущию раскладку
             test ax,ax         ; // Если текущая раскладка 0
             jz  .УСТАН_АНГ     ; // то устанавливаем 1 англ раскладку
.УСТАН_РУС:  ;------------------;
             mov  ax,0          ; // Иначе Установка Рус Раскладки клавиатуры
             mov  [РАС_КЛАВ],ax ; // Если 1 это АНГ бук Если 0 То Рус
             jmp .ВЫХОД         ; // Выход из обработчика нажатых кнопок
.УСТАН_АНГ:  ;------------------; // Установка Агл раскладки клавиатуры
             mov  ax,1          ;
             mov  [РАС_КЛАВ],ax ; // Устанавливаем англ раскладку
             jmp .ВЫХОД         ; // Выход из обработчика нажатых кнопок
             ;------------------;
.ВЫХОД:
             popad;
             ret;
;}
ОКНО_НАЖ_БУКВ:;{ Обработка нажатия букв и цифер на клавиатуре
              pushad              ;
              mov   cx,[РАС_КЛАВ] ; // Читаем раскладку клавиатуры
              test  cx,cx         ; // Если 0 значит преобразовать в руские буквы
              jnz  .АНГ_РАС       ;
              Call  ПРЕОБРАЗУЕТ_АНГ_БУК_AL_В_РУС;
.АНГ_РАС:     call  ОКНО_КНО_БУКВ ;
              popad               ;
              ret                 ;
;}
;==============================================================================}

ЭТО_ОКНО     :;{ Определяет явлеться ли элемент DI Окном JZ - если не окно
IF  (ПЛАТФОРМА = ДОС)   ;{
             pushad         ;;{ ОПИСАНИЕ
             ; ПРоцедура определяет являеться ли элемент окном
             ; И начливае всех необходимых параметров
             ; Что бы нормально вырисовать это окно
             ;}

             test di,di     ;
             jz  .НЕТ       ;
             ;--------------; // Тип элемента должен быть Окно

             ;--------------;
             mov  CX,КОД_ТИП; // Указываем имя элемиента котрый будем искать
             call ЭЛЕ_ПОИСК_ВН_ПО_КОДУ_CX;// Ищим элемент с таким именем

             jz  .НЕТ       ;
             call ЭЛЕ_ТИП   ;
             CMP  ax,ТИП_ЧИСЛ;
             jnz .НЕТ       ;
             call ЭЛЕ_ЗНА   ;
             test ax,ax     ;
             jmp .ВЫХОД     ;
.НЕТ:        mov  ax,0      ;
             test ax,ax     ;
.ВЫХОД:
             popad           ;// Если такого параметра нету если ?
             ret             ;
             END IF          ;}
IF  (ПЛАТФОРМА = T16)   ;{
             pushad         ;;{ ОПИСАНИЕ
             ; ПРоцедура определяет являеться ли элемент окном
             ; И начливае всех необходимых параметров
             ; Что бы нормально вырисовать это окно
             ;}

             test di,di     ;
             jz  .НЕТ       ;
             ;--------------; // Тип элемента должен быть Окно

             ;--------------;
             mov  CX,КОД_ТИП; // Указываем имя элемиента котрый будем искать
             call ЭЛЕ_ПОИСК_ВН_ПО_КОДУ_CX;// Ищим элемент с таким именем

             jz  .НЕТ       ;
             call ЭЛЕ_ТИП   ;
             CMP  ax,ТИП_ЧИСЛ;
             jnz .НЕТ       ;
             call ЭЛЕ_ЗНА   ;
             test ax,ax     ;
             jmp .ВЫХОД     ;
.НЕТ:        mov  ax,0      ;
             test ax,ax     ;
.ВЫХОД:
             popad           ;// Если такого параметра нету если ?
             ret             ;
             END IF          ;}
IF  (ПЛАТФОРМА = T32)   ;{
             pushad         ;;{ ОПИСАНИЕ
             ; ПРоцедура определяет являеться ли элемент окном
             ; И начливае всех необходимых параметров
             ; Что бы нормально вырисовать это окно
             ;}

             test edi,edi   ;
             jz  .НЕТ       ;
             ;--------------; // Тип элемента должен быть Окно

             ;--------------;
             mov  eCX,КОД_ТИП; // Указываем имя элемиента котрый будем искать
             call ЭЛЕ_ПОИСК_ВН_ПО_КОДУ_CX;// Ищим элемент с таким именем

             jz  .НЕТ       ;
             call ЭЛЕ_ТИП   ;
             CMP  eax,ТИП_ЧИСЛ;
             jnz .НЕТ       ;
             call ЭЛЕ_ЗНА   ;
             test eax,eax     ;
             jmp .ВЫХОД     ;
.НЕТ:        mov  eax,0      ;
             test eax,eax     ;
.ВЫХОД:
             popad           ;// Если такого параметра нету если ?
             ret             ;
             END IF          ;}
;------------------------------------------------------------------------------}
КНОПКИ       :;{ Обработка Нажатия кнопок
IF  (ПЛАТФОРМА = ДОС)   ;{
              pushad;

              ;------------------;
              mov  ax,[НАЖ_КНОПК]; // Читаем код нажатой кнопки
              mov  di,[МЫШ_ВЫДЕ2]; // Читаем активное окно
              ;------------------;

              mov  si,ТАБЛИЦА_КНО;
              call ПОИСК_ДВОЙНОЙ_БУКВЫ_AX_В_СТРОКЕ_SI_ШАГ2;
              jz  .БУКВ          ;

              cmp  bx,5          ;
              ja  .ДЛЯ_ОКНА      ;
              call ЗАПУСТИТЬ_CX  ;
              jmp .ВЫХОД         ;
.ДЛЯ_ОКНА:    test di,di         ;
              jz  .ВЫХОД         ;
              call ЗАПУСТИТЬ_CX  ;
              JMP .ВЫХОД         ;

.БУКВ:
              call ЕСЛИ_В_AL_НЕ_СИМВОЛ_ФЛАГ_Z_0;
              jz  .ВЫХОД         ;
              call ОКНО_НАЖ_БУКВ ;

.ВЫХОД:
              ;------------------; // Обработка нажаиых кнопок завершена обнуление наж кнопки
              mov ax,0           ;
              mov [НАЖ_КНОПК],ax ;
              ;------------------;

              popad;
              ret;
              END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
              pushad;

              ;------------------;
              mov  ax,[НАЖ_КНОПК]; // Читаем код нажатой кнопки
              mov  di,[МЫШ_ВЫДЕ2]; // Читаем активное окно
              ;------------------;

              mov  si,ТАБЛИЦА_КНО;
              call ПОИСК_ДВОЙНОЙ_БУКВЫ_AX_В_СТРОКЕ_SI_ШАГ2;
              jz  .БУКВ          ;

              cmp  bx,5          ;
              ja  .ДЛЯ_ОКНА      ;
              call ЗАПУСТИТЬ_CX  ;
              jmp .ВЫХОД         ;
.ДЛЯ_ОКНА:    test di,di         ;
              jz  .ВЫХОД         ;
              call ЗАПУСТИТЬ_CX  ;
              JMP .ВЫХОД         ;

.БУКВ:
              call ЕСЛИ_В_AL_НЕ_СИМВОЛ_ФЛАГ_Z_0;
              jz  .ВЫХОД         ;
              call ОКНО_НАЖ_БУКВ ;

.ВЫХОД:
              ;------------------; // Обработка нажаиых кнопок завершена обнуление наж кнопки
              mov ax,0           ;
              mov [НАЖ_КНОПК],ax ;
              ;------------------;

              popad;
              ret;
              END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
              pushad;
              mov  ecx,0;
              ;------------------;
              mov  eax,[НАЖ_КНОПК]; // Читаем код нажатой кнопки
              mov  edi,[МЫШ_ВЫДЕ2]; // Читаем активное окно
              ;------------------;

              mov  esi,ТАБЛИЦА_КНО;
              call ПОИСК_ДВОЙНОЙ_БУКВЫ_AX_В_СТРОКЕ_SI_ШАГ2;
              jz  .БУКВ          ;

              cmp  ebx,5          ;
              ja  .ДЛЯ_ОКНА      ;
              call ЗАПУСТИТЬ_CX  ;
              jmp .ВЫХОД         ;
.ДЛЯ_ОКНА:    test edi,edi         ;
              jz  .ВЫХОД         ;
              call ЗАПУСТИТЬ_CX  ;
              JMP .ВЫХОД         ;

.БУКВ:
              call ЕСЛИ_В_AL_НЕ_СИМВОЛ_ФЛАГ_Z_0;
              jz  .ВЫХОД         ;
              call ОКНО_НАЖ_БУКВ ;

.ВЫХОД:
              ;------------------; // Обработка нажаиых кнопок завершена обнуление наж кнопки
              mov eax,0           ;
              mov [НАЖ_КНОПК],eax ;
              ;------------------;

              popad;
              ret;
              END IF;}
;==============================================================================}
ОКНО_DI_КН_AX:;{ Нажатие кнопки AX в ОКне DI
IF  (ПЛАТФОРМА = ДОС)   ;{
              pushad                ;
              call  ОКНО_ВЫВОД_ТЕ   ;
              mov   bx,ax           ; // Запоминаем код нажатой кнопки
              call  ОКНО_ПАС        ; // Читаем предположительный адрес в строке куда нужно добавить символ сформированый в ОКНО_ВЫВОД_ТЕ
              mov   si,ax           ;

              ;// Дописываем не достающие переводы строки
              call  ОКНО_КСТ        ; // Читаем количество строк в тексте окна
              mov   cx,ax           ; // теперь в CX Количество строк в тексте
              call  ОКНО_АКY        ; // Читаем Абсолютную позицию курсора в тексте
              mov   dx,ax           ; // теперь в DX абсолютная координата курсора в тексте по Y
.ЦИКЛ2:       CMP   cx,dx           ;
              JA   .КЦИКЛ2          ;
              call  НАЙТИ_КОНЕЦ_СТРОКИ_С_АДРЕСА_SI;
              mov   al,13           ;
              call  ВСТАВКА_СИМВОЛА_AL_ПО_АДРЕСУ_SI_ДО_0;
              inc   CX              ;
              JMP  .ЦИКЛ2           ;

.КЦИКЛ2:
              ;// Дписываем не достающие пробелы если это необходимо
              call  ОКНО_КСК        ;// Читаем правй край в тексте где расположен курсор
              mov   dx,ax           ;// Запоминаем
              call  ОКНО_АКX        ;// Читаем абсолютную координату курсора по X
              mov   cx,ax;
.ЦИКЛ:        cmp   dx,cx           ;// Сравниваем правй край строки в котрой расположен курсор и координату курсора по X
              jae  .ДАЛЕЕ           ;
                                    ; Дописываем необходимое количество пробелов
              mov  al,' '           ;
              call ВСТАВКА_СИМВОЛА_AL_ПО_АДРЕСУ_SI_ДО_0;
              inc  SI               ;
              inc  dx               ;
              jmp .ЦИКЛ             ;
              ;----------------------
.ДАЛЕЕ:
              mov   ax,bx           ;
              cmp   ax,3592         ;
              jz   .ПРОПУСТИТЬ      ;

              call  ВСТАВКА_СИМВОЛА_AL_ПО_АДРЕСУ_SI_ДО_0;
              call  ОКНО_КУР_ВПРА   ;
.ПРОПУСТИТЬ:

              mov  ax,si;
              mov  cx,КОД_ПАР_ПАВС  ;
              call ЭЛЕ_УСТ_ПАР      ;

              popad                 ;
              ret                   ;
              END IF                ;}
IF  (ПЛАТФОРМА = T16)   ;{
              pushad                ;
              call  ОКНО_ВЫВОД_ТЕ   ;
              mov   bx,ax           ; // Запоминаем код нажатой кнопки
              call  ОКНО_ПАС        ; // Читаем предположительный адрес в строке куда нужно добавить символ сформированый в ОКНО_ВЫВОД_ТЕ
              mov   si,ax           ;

              ;// Дописываем не достающие переводы строки
              call  ОКНО_КСТ        ; // Читаем количество строк в тексте окна
              mov   cx,ax           ; // теперь в CX Количество строк в тексте
              call  ОКНО_АКY        ; // Читаем Абсолютную позицию курсора в тексте
              mov   dx,ax           ; // теперь в DX абсолютная координата курсора в тексте по Y
.ЦИКЛ2:       CMP   cx,dx           ;
              JA   .КЦИКЛ2          ;
              call  НАЙТИ_КОНЕЦ_СТРОКИ_С_АДРЕСА_SI;
              mov   al,13           ;
              call  ВСТАВКА_СИМВОЛА_AL_ПО_АДРЕСУ_SI_ДО_0;
              inc   CX              ;
              JMP  .ЦИКЛ2           ;

.КЦИКЛ2:
              ;// Дписываем не достающие пробелы если это необходимо
              call  ОКНО_КСК        ;// Читаем правй край в тексте где расположен курсор
              mov   dx,ax           ;// Запоминаем
              call  ОКНО_АКX        ;// Читаем абсолютную координату курсора по X
              mov   cx,ax;
.ЦИКЛ:        cmp   dx,cx           ;// Сравниваем правй край строки в котрой расположен курсор и координату курсора по X
              jae  .ДАЛЕЕ           ;
                                    ; Дописываем необходимое количество пробелов
              mov  al,' '           ;
              call ВСТАВКА_СИМВОЛА_AL_ПО_АДРЕСУ_SI_ДО_0;
              inc  SI               ;
              inc  dx               ;
              jmp .ЦИКЛ             ;
              ;----------------------
.ДАЛЕЕ:
              mov   ax,bx           ;
              cmp   ax,3592         ;
              jz   .ПРОПУСТИТЬ      ;

              call  ВСТАВКА_СИМВОЛА_AL_ПО_АДРЕСУ_SI_ДО_0;
              call  ОКНО_КУР_ВПРА   ;
.ПРОПУСТИТЬ:

              mov  ax,si;
              mov  cx,КОД_ПАР_ПАВС  ;
              call ЭЛЕ_УСТ_ПАР      ;

              popad                 ;
              ret                   ;
              END IF                ;}
IF  (ПЛАТФОРМА = T32)   ;{
              pushad
              call  ОКНО_ВЫВОД_ТЕ   ;
              mov   ebx,eax           ; // Запоминаем код нажатой кнопки
              call  ОКНО_ПАС        ; // Читаем предположительный адрес в строке куда нужно добавить символ сформированый в ОКНО_ВЫВОД_ТЕ
              mov   esi,eax           ;

              ;// Дописываем не достающие переводы строки
              call  ОКНО_КСТ        ; // Читаем количество строк в тексте окна
              mov   ecx,eax           ; // теперь в CX Количество строк в тексте
              call  ОКНО_АКY        ; // Читаем Абсолютную позицию курсора в тексте
              mov   edx,eax           ; // теперь в DX абсолютная координата курсора в тексте по Y
.ЦИКЛ2:       CMP   ecx,edx           ;
              JA   .КЦИКЛ2          ;
              call  НАЙТИ_КОНЕЦ_СТРОКИ_С_АДРЕСА_SI;
              mov   al,13           ;
              call  ВСТАВКА_СИМВОЛА_AL_ПО_АДРЕСУ_SI_ДО_0;
              inc   eCX              ;
              JMP  .ЦИКЛ2           ;

.КЦИКЛ2:
              ;// Дписываем не достающие пробелы если это необходимо
              call  ОКНО_КСК        ;// Читаем правй край в тексте где расположен курсор
              mov   edx,eax           ;// Запоминаем
              call  ОКНО_АКX        ;// Читаем абсолютную координату курсора по X
              mov   ecx,eax;
.ЦИКЛ:        cmp   edx,ecx           ;// Сравниваем правй край строки в котрой расположен курсор и координату курсора по X
              jae  .ДАЛЕЕ           ;
                                    ; Дописываем необходимое количество пробелов
              mov  al,' '           ;
              call ВСТАВКА_СИМВОЛА_AL_ПО_АДРЕСУ_SI_ДО_0;
              inc  eSI               ;
              inc  edx               ;
              jmp .ЦИКЛ             ;
              ;----------------------
.ДАЛЕЕ:
              mov   eax,ebx           ;
              cmp   eax,3592         ;
              jz   .ПРОПУСТИТЬ      ;

              call  ВСТАВКА_СИМВОЛА_AL_ПО_АДРЕСУ_SI_ДО_0;
              call  ОКНО_КУР_ВПРА   ;
.ПРОПУСТИТЬ:

              mov  eax,esi;
              mov  ecx,КОД_ПАР_ПАВС  ;
              call ЭЛЕ_УСТ_ПАР      ;

              popad                 ;
              ret                   ;
              END IF                ;}
;==============================================================================}
ТАБЛИЦА_КНО  :;{ Таблица для кнопок
dW 15616,КНОП_СОЗ_ОКНА  ; 1
dW 15104,КНОП_ПОМ_ОКНА  ; 2
dW 16896,ОКНО_КНО_РАСК  ; 3
dW 17408,КНОП_ПРИ_ОКНА  ; 4
dW 16640,КНОП_ИНФ_СТРО  ; 5

dW 15872,КНОП_УДА_ОКНА  ; 6
dW 17152,ВЫПОЛНИТЬ_ОК   ; 7
dW 19712,ОКНО_КУР_ВПРА  ; 8
dW 19200,ОКНО_КУР_ВЛЕВ  ; 9
dW 20480,ОКНО_КУР_ВНИЗ  ; 10
dW 18432,ОКНО_КУР_ВВЕР  ; 11
dW 3592 ,ОКНО_КНО_УДАЛ  ; 12
dW 7181 ,ОКНО_КНО_ЕНТР  ; 13
dW 0    ,0              ; 14
;-----------------------}
ИНФ_СТРО:DD 1;
ЗАПУСТИТЬ_CX:;{
IF  (ПЛАТФОРМА = T32);{
call ecx
END IF  ;}
IF  (ПЛАТФОРМА = T16);{
call cx
END IF  ;}
IF  (ПЛАТФОРМА = ДОС);{
call cx
END IF  ;}
ret;
;}
КНОП_УДА_ОКНА:;{ Унопка Удаление окна
IF  (ПЛАТФОРМА = ДОС)   ;{
             pushad;
             mov  di,[МЫШ_ВЫДЕ2];// Читаем активное окно
             test di,di;
             jz  .ВЫХОД;
             call ЭЛЕ_ОСВОБОДИ ;
.ВЫХОД:
             popad;
             ret;
             END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
             pushad;
             mov  di,[МЫШ_ВЫДЕ2];// Читаем активное окно
             test di,di;
             jz  .ВЫХОД;
             call ЭЛЕ_ОСВОБОДИ ;
.ВЫХОД:
             popad;
             ret;
             END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
             pushad;
             mov  edi,[МЫШ_ВЫДЕ2];// Читаем активное окно
             test edi,edi;
             jz  .ВЫХОД;
             call ЭЛЕ_ОСВОБОДИ ;
.ВЫХОД:
             popad;
             ret;
             END IF;}
;=============================================================================}
КНОП_СОЗ_ОКНА:;{ Унопка создания окна
IF  (ПЛАТФОРМА = ДОС)   ;{
             pushad;
             ;mov di,[МЫШ_ВЫДЕ2];// Читаем активное окно
             mov di,[КОР_ЭЛЕМ];// Читаем активное окно

             call .СОЗ_ТЕК          ; // Создаем строку с текстом окна заносим в BX её адрес
             mov  CL,10             ; // Указываем координату окна по X
             mov  CH,10             ; // Указываем координату окна по Y
             mov  DL,10             ; // Указываем Ширину окна
             mov  DH,10             ; // Указываем Указываем высоту окна
             mov  si,.ИМЯ_ОКНА      ;
             call ОКНО_СОЗДАТЬ      ;

             mov  cx,КОД_ПАР_АТРИ       ;
             mov  ax,10110000b      ;
             call ЭЛЕ_УСТ_ПАР       ;

             pop  si                ;
             Push di                ;
             popad                  ;
             ret                    ;
.СОЗ_ТЕК:
             push si;
             push di;
             call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_1024_БАЙТ; // Выделяем участок памяти для текста результат возвращеться адрес DI
             mov  si,di             ; // Указывапем куда копировать то есть в новую строку
             mov  di,.ТЕКС_ОКНА1    ; // Указывапем откудвава копировать
             call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI; // Копируем
             mov  bx,si             ; // Заном адрес строки в BX
             pop  di;
             pop  si;
             ret;
             END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
             pushad;
             ;mov di,[МЫШ_ВЫДЕ2];// Читаем активное окно
             mov di,[КОР_ЭЛЕМ];// Читаем активное окно

             call .СОЗ_ТЕК          ; // Создаем строку с текстом окна заносим в BX её адрес
             mov  CL,10             ; // Указываем координату окна по X
             mov  CH,10             ; // Указываем координату окна по Y
             mov  DL,10             ; // Указываем Ширину окна
             mov  DH,10             ; // Указываем Указываем высоту окна
             mov  si,.ИМЯ_ОКНА      ;
             call ОКНО_СОЗДАТЬ      ;

             mov  cx,КОД_ПАР_АТРИ       ;
             mov  ax,10110000b      ;
             call ЭЛЕ_УСТ_ПАР       ;

             pop  si                ;
             Push di                ;
             popad                  ;
             ret                    ;
.СОЗ_ТЕК:
             push si;
             push di;
             call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_1024_БАЙТ; // Выделяем участок памяти для текста результат возвращеться адрес DI
             mov  si,di             ; // Указывапем куда копировать то есть в новую строку
             mov  di,.ТЕКС_ОКНА1    ; // Указывапем откудвава копировать
             call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI; // Копируем
             mov  bx,si             ; // Заном адрес строки в BX
             pop  di;
             pop  si;
             ret;
             END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
             pushad;

             ;mov Edi,[МЫШ_ВЫДЕ2];// Читаем активное окно
             mov Edi,[КОР_ЭЛЕМ];// Читаем активное окно

             call .СОЗ_ТЕК          ; // Создаем строку с текстом окна заносим в BX её адрес
             mov  CL,10             ; // Указываем координату окна по X
             mov  CH,10             ; // Указываем координату окна по Y
             mov  DL,10             ; // Указываем Ширину окна
             mov  DH,10             ; // Указываем Указываем высоту окна
             mov  Esi,.ИМЯ_ОКНА     ;
             call ОКНО_СОЗДАТЬ      ;

             mov  Ecx,КОД_ПАР_АТРИ  ;
             mov  Eax,10110000b     ;
             call ЭЛЕ_УСТ_ПАР       ;

             pop  Esi               ;
             Push Edi               ;
             popad                  ;
             ret                    ;
.СОЗ_ТЕК:
             push esi;
             push edi;
             call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_1024_БАЙТ; // Выделяем участок памяти для текста результат возвращеться адрес DI
             mov  Esi,edi             ; // Указывапем куда копировать то есть в новую строку
             mov  Edi,.ТЕКС_ОКНА1    ; // Указывапем откудвава копировать
             call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI; // Копируем
             mov  Ebx,esi             ; // Заном адрес строки в BX
             pop  edi;
             pop  esi;
             ret;
             END IF;}

.ТЕКС_ОКНА1:;{
DB ' А(){}',13;
DB ' Б(){}',13;
DB ' Ц(){}',13;
DB ' ВЫВОД("ВВЕДИТЕ А " ) А:=ВВОДСТ ',13;
DB ' ВЫВОД("ВВЕДИТЕ Б " ) Б:=ВВОДСТ ',13;
DB ' ВЫВОД("ВВЕДИТЕ Ц " ) Ц:=ВВОДСТ ',13;
DB ' ВЫВОД("РЕЗУЛЬТАТ " А+Б*Ц)  ',13,0;
.ИМЯ_ОКНА: db ' НОВОЕ ОКНО ',0;
;}
;=============================================================================}
КНОП_ПОМ_ОКНА:;{ Унопка  окна Помощи
IF  (ПЛАТФОРМА = ДОС)   ;{
             pushad;
             mov di,[КОР_ЭЛЕМ]      ;// Читаем активное окно

             mov  CX,КОД_ПОМОЩЬ   ;
             call ЭЛЕ_ПОИСК_ВН_ПО_КОДУ_CX

             jnz  .УДАЛИТЬ_ОКНО     ;
             mov di,[КОР_ЭЛЕМ]      ;// Читаем активное окно

             call .СОЗ_ТЕК          ; // Создаем строку с текстом окна заносим в BX её адрес
             mov  CL,32             ; // Указываем координату окна по X
             mov  CH,1              ; // Указываем координату окна по Y
             mov  DL,45             ; // Указываем Ширину окна
             mov  DH,14             ; // Указываем Указываем высоту окна
             mov  Si,ТЕК_ПОМОЩЬ     ;
             call ОКНО_СОЗДАТЬ      ;

             mov  cx,КОД_ПАР_АТРИ       ;
             mov  ax,01011111b      ;
             call ЭЛЕ_УСТ_ПАР       ;

             pop  si                ;
             Push di                ;
             popad                  ;
             ret                    ;

.УДАЛИТЬ_ОКНО:
              call ЭЛЕ_ОСВОБОДИ ;
              pop  si
              push DI
              popad;
              ret;

.СОЗ_ТЕК:
             push si;
             push di;
             call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_1024_БАЙТ; // Выделяем участок памяти для текста результат возвращеться адрес DI
             mov  si,di             ; // Указывапем куда копировать то есть в новую строку
             mov  di,.ТЕКС_ОКНА1    ; // Указывапем откудвава копировать
             call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI; // Копируем
             mov  bx,si             ; // Заном адрес строки в BX
             pop  di;
             pop  si;
             ret;
             END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
             pushad;
             mov di,[КОР_ЭЛЕМ]      ;// Читаем активное окно

             mov  CX,КОД_ПОМОЩЬ   ;
             call ЭЛЕ_ПОИСК_ВН_ПО_КОДУ_CX

             jnz  .УДАЛИТЬ_ОКНО     ;
             mov di,[КОР_ЭЛЕМ]      ;// Читаем активное окно

             call .СОЗ_ТЕК          ; // Создаем строку с текстом окна заносим в BX её адрес
             mov  CL,32             ; // Указываем координату окна по X
             mov  CH,1              ; // Указываем координату окна по Y
             mov  DL,45             ; // Указываем Ширину окна
             mov  DH,14             ; // Указываем Указываем высоту окна
             mov  Si,ТЕК_ПОМОЩЬ     ;
             call ОКНО_СОЗДАТЬ      ;

             mov  cx,КОД_ПАР_АТРИ       ;
             mov  ax,01011111b      ;
             call ЭЛЕ_УСТ_ПАР       ;

             pop  si                ;
             Push di                ;
             popad                  ;
             ret                    ;

.УДАЛИТЬ_ОКНО:
              call ЭЛЕ_ОСВОБОДИ ;
              pop  si
              push DI
              popad;
              ret;

.СОЗ_ТЕК:
             push si;
             push di;
             call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_1024_БАЙТ; // Выделяем участок памяти для текста результат возвращеться адрес DI
             mov  si,di             ; // Указывапем куда копировать то есть в новую строку
             mov  di,.ТЕКС_ОКНА1    ; // Указывапем откудвава копировать
             call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI; // Копируем
             mov  bx,si             ; // Заном адрес строки в BX
             pop  di;
             pop  si;
             ret;
             END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
             pushad;
             mov edi,[КОР_ЭЛЕМ]      ;// Читаем активное окно

             mov  eCX,КОД_ПОМОЩЬ   ;
             call ЭЛЕ_ПОИСК_ВН_ПО_КОДУ_CX

             jnz  .УДАЛИТЬ_ОКНО     ;
             mov edi,[КОР_ЭЛЕМ]      ;// Читаем активное окно

             call .СОЗ_ТЕК          ; // Создаем строку с текстом окна заносим в BX её адрес
             mov  CL,32             ; // Указываем координату окна по X
             mov  CH,1              ; // Указываем координату окна по Y
             mov  DL,45             ; // Указываем Ширину окна
             mov  DH,14             ; // Указываем Указываем высоту окна
             mov  eSi,ТЕК_ПОМОЩЬ    ;
             call ОКНО_СОЗДАТЬ      ;

             mov  ecx,КОД_ПАР_АТРИ       ;
             mov  eax,01011111b      ;
             call ЭЛЕ_УСТ_ПАР       ;

             pop  esi                ;
             Push edi                ;
             popad                  ;
             ret                    ;

.УДАЛИТЬ_ОКНО:
              call ЭЛЕ_ОСВОБОДИ ;
              pop  esi
              push eDI
              popad;
              ret;

.СОЗ_ТЕК:
             push esi;
             push edi;
             call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_1024_БАЙТ; // Выделяем участок памяти для текста результат возвращеться адрес DI
             mov  esi,edi             ; // Указывапем куда копировать то есть в новую строку
             mov  edi,.ТЕКС_ОКНА1    ; // Указывапем откудвава копировать
             call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI; // Копируем
             mov  ebx,esi             ; // Заном адрес строки в BX
             pop  edi;
             pop  esi;
             ret;
             END IF;}
.ТЕКС_ОКНА1:
db  " -------------------------------------------",13;
db  " Тим ОС в 1.0      Абдулов Тимур Рифович    ",13;
db  " -------------------------------------------",13;
db  "  F1 - Окно помощи",13;
db  "  F3 - Создать окно",13;
db  "  F4 - Закрыть окно",13;
db  "  F7 - Состояние системы",13;
db  "  F8 - Раскладка клаиатуры",13;
db  "  F9 - Запуск программы",13;
db  "  F10- Пример программы",13;
db  " ------------------------------------------- ",13;
db  " Электронная Почта hostingurifa@gmail.com    ",13;
db  " http://sites.google.com/site/abdulovtimuros ",13;
db  " ------------------------------------------- ",13,0;

.ИМЯ_ОКНА:db 'Окно помощи',0;
;=============================================================================}
КНОП_ПРИ_ОКНА:;{ Создает окно с именем SI внутри элемента DI
IF  (ПЛАТФОРМА = ДОС)   ;{
         pushad;
         mov di,[КОР_ЭЛЕМ]     ;// Читаем активное окно
         call .СОЗ_ТЕК          ; // Создаем строку с текстом окна заносим в BX её адрес
         mov  CL,5              ; // Указываем координату окна по X
         mov  CH,5             ; // Указываем координату окна по Y
         mov  DL,30             ; // Указываем Ширину окна
         mov  DH,10             ; // Указываем Указываем высоту окна
         MOV  SI,.ПРИМЕР        ;
         call ОКНО_СОЗДАТЬ      ;
                                ;
         pop  si                ;
         Push di                ;
         popad                  ;
         ret                    ;


.СОЗ_ТЕК:

         push si;
         push di;
         call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_1024_БАЙТ; // Выделяем участок памяти для текста результат возвращеться адрес DI
         mov  si,di             ; // Указывапем куда копировать то есть в новую строку
         mov  di,.ТЕКС_ОКНА1    ; // Указывапем откудвава копировать
         call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI; // Копируем
         mov  bx,si             ; // Заном адрес строки в BX
         pop  di;
         pop  si;
         ret    ;
         END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
         pushad;
         mov di,[КОР_ЭЛЕМ]     ;// Читаем активное окно
         call .СОЗ_ТЕК          ; // Создаем строку с текстом окна заносим в BX её адрес
         mov  CL,5              ; // Указываем координату окна по X
         mov  CH,5             ; // Указываем координату окна по Y
         mov  DL,30             ; // Указываем Ширину окна
         mov  DH,10             ; // Указываем Указываем высоту окна
         MOV  SI,.ПРИМЕР        ;
         call ОКНО_СОЗДАТЬ      ;
                                ;
         pop  si                ;
         Push di                ;
         popad                  ;
         ret                    ;


.СОЗ_ТЕК:

         push si;
         push di;
         call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_1024_БАЙТ; // Выделяем участок памяти для текста результат возвращеться адрес DI
         mov  si,di             ; // Указывапем куда копировать то есть в новую строку
         mov  di,.ТЕКС_ОКНА1    ; // Указывапем откудвава копировать
         call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI; // Копируем
         mov  bx,si             ; // Заном адрес строки в BX
         pop  di;
         pop  si;
         ret    ;
         END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
         pushad;
         mov edi,[КОР_ЭЛЕМ]     ;// Читаем активное окно
         call .СОЗ_ТЕК          ; // Создаем строку с текстом окна заносим в BX её адрес
         mov  CL,5              ; // Указываем координату окна по X
         mov  CH,5              ; // Указываем координату окна по Y
         mov  DL,30             ; // Указываем Ширину окна
         mov  DH,10             ; // Указываем Указываем высоту окна
         MOV  eSI,.ПРИМЕР        ;
         call ОКНО_СОЗДАТЬ      ;
                                ;
         pop  esi                ;
         Push edi                ;
         popad                  ;
         ret                    ;


.СОЗ_ТЕК:

         push esi;
         push edi;
         call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_1024_БАЙТ; // Выделяем участок памяти для текста результат возвращеться адрес DI
         mov  esi,edi             ; // Указывапем куда копировать то есть в новую строку
         mov  edi,.ТЕКС_ОКНА1    ; // Указывапем откудвава копировать
         call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI; // Копируем
         mov  ebx,esi             ; // Заном адрес строки в BX
         pop  edi;
         pop  esi;
         ret    ;
         END IF;}

.ПРИМЕР:Db "ПРИМЕР",0;

.ТЕКС_ОКНА  :;{
DB 'ОКНО(){         ',13;

DB ' ',13;
DB ' ПАР_ЛЕВО (){} ; '   ;// Left координата по X отображемого окна
DB ' ПАР_ВЕРХ (){} ; '   ;// Top координата по Y отображемого окна
DB ' ПАР_ШИРИ (){} ; '   ;// Width Ширина отображемого окна
DB ' ПАР_ВЫСО (){} ; ',13;// HEight Высота  отображемого окна
DB ' ПАР_АТРИ (){} ; '   ;// Атрибуты окна Забыл совсем что писал эти параметры )
DB ' ПАР_АКУР (){} ; '   ;// Атрибуты Курсора Ого у меня даже задать курсор можно
DB ' ПАР_ТСМX (){} ; '   ;// Смещение видимого текста внтури текста по X Круто
DB ' ПАР_ТСМY (){} ; ',13;// Смещение видимого текста внтури текста по Y
DB ' ПАР_ТКУX (){} ; '   ;// координаты  текстового курсора по X
DB ' ПАР_ТКУY (){} ; '   ;// координаты  текстового курсора по Y
DB ' ПАР_ТЕКС (){} ; '   ;// Текст окна для редактирования
DB ' ПАР_КССК (){} ; ',13;// Количество символов  в строке с курсором
DB ' ПАР_КОСТ (){} ; '   ;// Реальное количество строк в тексте окна
DB ' ПАР_ПАВС (){} ; '   ;// Предположительный адрес для вставки символа
DB ' ПАР_ДПСТ (){} ; '   ;// Длина предыдущей строки до курсора
DB ' ТИП (){}      ; ',13;// Длина предыдущей строки до курсора

DB ' ',13;

DB ' ПАР_ЛЕВО :=10 ; '   ;// Left координата по X отображемого окна
DB ' ПАР_ВЕРХ :=10 ; '   ;// Top координата по Y отображемого окна
DB ' ПАР_ШИРИ :=10 ; '   ;// Width Ширина отображемого окна
DB ' ПАР_ВЫСО :=10 ; ',13;// HEight Высота  отображемого окна
DB ' ПАР_АТРИ :=31 ; '   ;// Атрибуты окна Забыл совсем что писал эти параметры )
DB ' ПАР_АКУР :=100; '   ;// Атрибуты Курсора Ого у меня даже задать курсор можно
DB ' ПАР_ТСМX :=0  ; '   ;// Смещение видимого текста внтури текста по X Круто
DB ' ПАР_ТСМY :=0  ; ',13;// Смещение видимого текста внтури текста по Y
DB ' ПАР_ТКУX :=0  ; '   ;// координаты  текстового курсора по X
DB ' ПАР_ТКУY :=0  ; '   ;// координаты  текстового курсора по Y
DB ' ПАР_ТЕКС :=ТЕС; '   ;// Текст окна для редактирования
DB ' ПАР_КССК :=0  ; ',13;// Количество символов  в строке с курсором
DB ' ПАР_КОСТ :=0  ; '   ;// Реальное количество строк в тексте окна
DB ' ПАР_ПАВС :=0  ; '   ;// Предположительный адрес для вставки символа
DB ' ПАР_ДПСТ :=0  ; '   ;// Длина предыдущей строки до курсора
DB ' ТИП :=1       ; ',13;// Длина предыдущей строки до курсора

DB ' ',13;

DB ' РОДИТЕЛЬ:=РАБОЧИЙ_СТОЛ ; ',13;// Длина предыдущей строки до курсора

DB ' ',13;


DB '    x(){};'         ;
DB ' x:=1;'          ;
DB ' while (x<23)' ;
DB ' {'              ;
DB ' x:=x+1;'       ;
DB ' ВЫВОДСТ(x);'     ;
DB ' }'            ,13;
DB '}'                 ,13;
DB 'ОКНО();'            ,13;
DB 0;}
.ТЕКС_ОКНА4 :;{
DB ' А(){}'       ,13;
DB ' Б(){}'       ,13;
DB ' Ц(){}'       ,13;
DB ' ВЫВОД("ВВЕДИТЕ А " ) А:=ВВОДСТ '  ,13;
DB ' ВЫВОД("ВВЕДИТЕ Б " ) Б:=ВВОДСТ '  ,13;
DB ' ВЫВОД("ВВЕДИТЕ Ц " ) Ц:=ВВОДСТ '  ,13;
DB ' ВЫВОД("РЕЗУЛЬТАТ " А+Б*Ц)  '  ,13;
DB 0
;}
.ТЕКС_ОКНА2 :;{
DB ' ВЫВОД(2+3) '  ,13;
DB 0;}
.ТЕКС_ОКНА3 :;{
DB ' x(){};'       ,13;
DB ' з(){};'       ,13;
DB ' ЗАПРЕТИТЬ;'   ,13;
DB ' x:=1;'        ,13;
DB ' while (x<100)',13;
DB ' {'            ,13;
DB ' x:=x+1;'      ,13;
DB ' з:=ЧПОРТ(64);',13;
DB ' ВЫВОДСТ(з);'  ,13;
DB ' }'            ,13;
DB ' РАЗРЕШИТЬ;'   ,13;
DB 0;}
.ТЕКС_ОКНА1 :;{
DB ' x(){};',13;
db '   x:=1;',13;
DB '   while (x<1000)',13;
DB '   {',13;
DB '   ВЫВОДСТ("X="+x);',13;
DB '   x:=x+1;',13;
DB '   if (x>5) {УДА_СТР;}',13;
DB '   }',13;
DB 0;
;}
;==============================================================================}

ОКНО_МОНИТОР :;{ Создает окно МОНИТОР внутри элемента DI
IF  (ПЛАТФОРМА = ДОС)   ;{
         pushad;
         call .СОЗ_ТЕК          ; // Создаем строку с текстом окна заносим в BX её адрес
         mov  SI,МОНИТОР        ;
         mov  CL,1              ; // Указываем координату окна по X
         mov  CH,1              ; // Указываем координату окна по Y
         mov  DL,10             ; // Указываем Ширину окна
         mov  DH,5              ; // Указываем Указываем высоту окна
         call ОКНО_СОЗДАТЬ      ;

         ;----------------------;
         mov  cx,КОД_ПАР_АТРИ   ;
         mov  ax,00001111b      ;
         call ЭЛЕ_УСТ_ПАР       ;
         ;----------------------;

         Call ВОЗВРАТИТЬ_DI     ;
         popad                  ;
         ret                    ;

.СОЗ_ТЕК:
         push si                ;
         push di                ;
         call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_1024_БАЙТ; // Выделяем участок памяти для текста результат возвращеться адрес DI
         mov  si,di             ; // Указывапем куда копировать то есть в новую строку
         mov  di,.ТЕКС_ОКНА1    ; // Указывапем откудвава копировать
         call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI; // Копируем
         mov  bx,si             ; // Заном адрес строки в BX
         pop  di                ;
         pop  si                ;
         ret;
         END iF;}
IF  (ПЛАТФОРМА = T16)   ;{
         pushad;
         call .СОЗ_ТЕК          ; // Создаем строку с текстом окна заносим в BX её адрес
         mov  SI,МОНИТОР        ;
         mov  CL,1              ; // Указываем координату окна по X
         mov  CH,1              ; // Указываем координату окна по Y
         mov  DL,10             ; // Указываем Ширину окна
         mov  DH,5              ; // Указываем Указываем высоту окна
         call ОКНО_СОЗДАТЬ      ;

         ;----------------------;
         mov  cx,КОД_ПАР_АТРИ   ;
         mov  ax,00001111b      ;
         call ЭЛЕ_УСТ_ПАР       ;
         ;----------------------;

         Call ВОЗВРАТИТЬ_DI     ;
         popad                  ;
         ret                    ;

.СОЗ_ТЕК:
         push si                ;
         push di                ;
         call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_1024_БАЙТ; // Выделяем участок памяти для текста результат возвращеться адрес DI
         mov  si,di             ; // Указывапем куда копировать то есть в новую строку
         mov  di,.ТЕКС_ОКНА1    ; // Указывапем откудвава копировать
         call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI; // Копируем
         mov  bx,si             ; // Заном адрес строки в BX
         pop  di                ;
         pop  si                ;
         ret;
         END iF;}
IF  (ПЛАТФОРМА = T32)   ;{
         pushad;
         call .СОЗ_ТЕК          ; // Создаем строку с текстом окна заносим в BX её адрес
         mov  ESI,МОНИТОР        ;
         mov  CL,1              ; // Указываем координату окна по X
         mov  CH,1              ; // Указываем координату окна по Y
         mov  DL,10             ; // Указываем Ширину окна
         mov  DH,5              ; // Указываем Указываем высоту окна
         call ОКНО_СОЗДАТЬ      ;

         ;----------------------;
         mov  ecx,КОД_ПАР_АТРИ   ;
         mov  eax,00001111b      ;
         call ЭЛЕ_УСТ_ПАР       ;
         ;----------------------;
          ;.zzz:
          ;call КУРСОР;
          ;call ОКНО_АВЕ
          ;call ЧИСЛОAX;
          ;call ЭКРАН_ВЫВОД;
          ;jmp .zzz;
         Call ВОЗВРАТИТЬ_DI     ;
         popad                  ;
         ret                    ;

.СОЗ_ТЕК:
         push esi                ;
         push edi                ;
         call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_1024_БАЙТ; // Выделяем участок памяти для текста результат возвращеться адрес DI
         mov  esi,edi             ; // Указывапем куда копировать то есть в новую строку
         mov  edi,.ТЕКС_ОКНА1    ; // Указывапем откудвава копировать
         call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI; // Копируем
         mov  ebx,esi             ; // Заном адрес строки в BX
         pop  edi                ;
         pop  esi                ;
         ret;
         END iF;}
.ТЕКС_ОКНА1: db ' ',13,0;
;==============================================================================}
КНОП_ИНФ_СТРО:;{ Информационная строка
IF  (ПЛАТФОРМА = ДОС)   ;{
              pushad
              mov  si,1
              mov  ax,[ИНФ_СТРО] ;
              test ax,ax         ;
              jz   .ЖЖЖ          ;
              mov Si,0;
.ЖЖЖ:         mov  [ИНФ_СТРО],si
              popad;
              ret;
              END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
              pushad
              mov  si,1
              mov  ax,[ИНФ_СТРО] ;
              test ax,ax         ;
              jz   .ЖЖЖ          ;
              mov Si,0;
.ЖЖЖ:         mov  [ИНФ_СТРО],si
              popad;
              ret;
              END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
              pushad
              mov  esi,1
              mov  eax,[ИНФ_СТРО] ;
              test eax,eax         ;
              jz   .ЖЖЖ          ;
              mov  eSi,0;
.ЖЖЖ:         mov  [ИНФ_СТРО],esi
              popad;
              ret;
              END IF;}
;}
ОКНО_КНО_УДАЛ:;{
pushad;
call ОКНО_КНО_БУКВ ; // Сперва добавлет удаление как буд то это буквы в связи с осбеностями системы и дорисовки не достающих знаков
Call ОКНО_КНО_УДЛЕ ; // Удаляет 2 символа слева
popad;
ret;
;}
ОКНО_КНО_ЕНТР:;{
pushad;
call ОКНО_КНО_БУКВ ;
call ОКНО_КНО_ЕНТЕ ;
popad;
ret;
;}





ОКНО_ПОРЯДОК:;{Порядок окон
IF  (ПЛАТФОРМА = ДОС)   ;{
pushad

mov  dx,[МЫШ_ВЫДЕ2]
mov  di,[МЫШ_ВЫДЕ2]
test Di,Di
jz  .LLL;
mov  si,di;
call ЭЛЕ_РОД;
jz  .LLL;
mov  DI,AX;
mov  bx,di;
call ЭЛЕ_ПОСЛЕД
jz  .LLL;
cmp  di,si;
jz  .LLL;
mov  di,bx;
call ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI
.LLL:
popad;
ret;
END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
pushad

mov  dx,[МЫШ_ВЫДЕ2]
mov  di,[МЫШ_ВЫДЕ2]
test Di,Di
jz  .LLL;
mov  si,di;
call ЭЛЕ_РОД;
jz  .LLL;
mov  DI,AX;
mov  bx,di;
call ЭЛЕ_ПОСЛЕД
jz  .LLL;
cmp  di,si;
jz  .LLL;
mov  di,bx;
call ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI
.LLL:
popad;
ret;
END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
pushad

mov  edx,[МЫШ_ВЫДЕ2]
mov  edi,[МЫШ_ВЫДЕ2]
test eDi,eDi
jz  .LLL;
mov  esi,edi;
call ЭЛЕ_РОД;
jz  .LLL;
mov  eDI,eAX;
mov  ebx,edi;
call ЭЛЕ_ПОСЛЕД
jz  .LLL;
cmp  edi,esi;
jz  .LLL;
mov  edi,ebx;
call ДОБ_ЭЛЕ_DX_В_ЭЛЕ_DI
.LLL:
popad;
ret;
END IF;}
;}

ОКНО_ПРЕДЕЛЫ :;{ Проверка вхождение координат CL-X,DL-Y в пространство окна
IF  (ПЛАТФОРМА = ДОС)   ;{
              pushad;
              ;--------------;// Проверка вхождения сммвола по X
              Call ОКНО_АЛЕ    ;// Получаем абсолютные координаты левого угла окна
              Cmp  Cl,AL       ;// Сравниваем с левым краем окна координату символа по X
              jb  .НЕВХОДИТ    ;
              Call ОКНО_АПР    ;// Читаем абсолютнуюю координату правой стороны окна
              cmp  cl,al       ;// Сравниваем
              JAE .НЕВХОДИТ    ;// Если Правый край окна оказался больше либо равен Координате символа рисовать ненада
              ;--------------;


              ;--------------;// Проверка вхождения сммвола по Y
              Call ОКНО_АВЕ    ;// Получаем абсолютные координаты левого верхнего  угла окна
              Cmp  dl,AL       ;// Сравниваем с левым верхним углом окна координату символа по Y
              jb  .НЕВХОДИТ    ;
              Call ОКНО_АНИ     ;// Читаем абсолютнуюю координату правой нижней стороны окна
              cmp  dl,al       ;// Сравниваем
              JAE .НЕВХОДИТ    ;// Если Правый край окна оказался больше либо равен Координате символа рисовать ненада
              ;--------------;
.ВХОДИТ:
              mov  al,1        ;
              test al,al       ;
              jmp .ВЫХОД       ;
.НЕВХОДИТ:
              mov  al,0        ;
              test al,al       ;
              jmp .ВЫХОД       ;
.ВЫХОД:
              popad;
              ret;
              END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
              pushad;
              ;--------------;// Проверка вхождения сммвола по X
              Call ОКНО_АЛЕ    ;// Получаем абсолютные координаты левого угла окна
              Cmp  Cl,AL       ;// Сравниваем с левым краем окна координату символа по X
              jb  .НЕВХОДИТ    ;
              Call ОКНО_АПР    ;// Читаем абсолютнуюю координату правой стороны окна
              cmp  cl,al       ;// Сравниваем
              JAE .НЕВХОДИТ    ;// Если Правый край окна оказался больше либо равен Координате символа рисовать ненада
              ;--------------;


              ;--------------;// Проверка вхождения сммвола по Y
              Call ОКНО_АВЕ    ;// Получаем абсолютные координаты левого верхнего  угла окна
              Cmp  dl,AL       ;// Сравниваем с левым верхним углом окна координату символа по Y
              jb  .НЕВХОДИТ    ;
              Call ОКНО_АНИ     ;// Читаем абсолютнуюю координату правой нижней стороны окна
              cmp  dl,al       ;// Сравниваем
              JAE .НЕВХОДИТ    ;// Если Правый край окна оказался больше либо равен Координате символа рисовать ненада
              ;--------------;
.ВХОДИТ:
              mov  al,1        ;
              test al,al       ;
              jmp .ВЫХОД       ;
.НЕВХОДИТ:
              mov  al,0        ;
              test al,al       ;
              jmp .ВЫХОД       ;
.ВЫХОД:
              popad;
              ret;
              END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
              pushad;
              ;--------------;// Проверка вхождения сммвола по X
              Call ОКНО_АЛЕ    ;// Получаем абсолютные координаты левого угла окна
              Cmp  Cl,AL       ;// Сравниваем с левым краем окна координату символа по X
              jb  .НЕВХОДИТ    ;
              Call ОКНО_АПР    ;// Читаем абсолютнуюю координату правой стороны окна
              cmp  cl,al       ;// Сравниваем
              JAE .НЕВХОДИТ    ;// Если Правый край окна оказался больше либо равен Координате символа рисовать ненада
              ;--------------;


              ;--------------;// Проверка вхождения сммвола по Y
              Call ОКНО_АВЕ    ;// Получаем абсолютные координаты левого верхнего  угла окна
              Cmp  dl,AL       ;// Сравниваем с левым верхним углом окна координату символа по Y
              jb  .НЕВХОДИТ    ;
              Call ОКНО_АНИ     ;// Читаем абсолютнуюю координату правой нижней стороны окна
              cmp  dl,al       ;// Сравниваем
              JAE .НЕВХОДИТ    ;// Если Правый край окна оказался больше либо равен Координате символа рисовать ненада
              ;--------------;
.ВХОДИТ:
              mov  al,1        ;
              test al,al       ;
              jmp .ВЫХОД       ;
.НЕВХОДИТ:
              mov  al,0        ;
              test al,al       ;
              jmp .ВЫХОД       ;
.ВЫХОД:
              popad;
              ret;
              END IF;}
;==============================================================================}
ОКНО_ВЫВОД_XY:;{ Вывод символа в окно Di-si  Cl-X DL-Y AX-Символ и атрибуты
IF  (ПЛАТФОРМА = ДОС)   ;{
          pushad;

          mov  bx,Ax        ;// Запоминаем Символ и атрибуты
          ;-----------------;
          call ЭТО_ОКНО     ;
          jz  .ДАЛЕЕ        ;// Если элемент не являетсья окном то пропускам проверку пределов
          ;-----------------;

          ;-----------------;
          call ОКНО_ПРЕДЕЛЫ ;
          jz  .ВЫХОД        ;// ПРоверка предлов
          ;-----------------;
.ДАЛЕЕ:
          ;-----------------;
          Call ЭЛЕ_РОДИТЕЛЬ ;// Переходим в родительский элемент
          JZ  .РИСОВАТЬ     ;// Символ рисовать если больше родителей нету
          ;-----------------;

          ;-----------------;
          mov  ax,bx        ;
          call ОКНО_ВЫВОД_XY;
          Jmp .ВЫХОД        ;
          ;-----------------;
.РИСОВАТЬ:

          ;----------------------
          mov  ax,Bx            ;// Востанавливаем сивмол и атрибуты
          call ЭКРАН_ВЫВОД_AX_CX_DX ;// Выводи символ на экран
          ;----------------------


          cmp  cl,[МЫШ_КООX2];
          jnz .ВЫХОД;
          cmp  dl,[МЫШ_КООY2];
          jnz .ВЫХОД;

          ;----------------------
          call МЫШКА_ЩЕЛЧЕК     ;// Установка активного элемента по щелчку мышки
          jz  .ВЫХОД            ;// Если мышка не нажата то выход
          ;----------------------

          mov  di,SI            ;// Востанавливаем элемент источник печати символа

          mov [МЫШ_ВЫДЕ2],di    ;// Записываем дарес элемента по котрому нажата кнопка

          ;----------------------
          mov  bx,1             ;// Устанавливаем Режим перемещени окна
          mov [МЫШ_ТИППЕ],bx    ;// ПО умолчанию режим перемесчения окна
          ;--------------------

          ;--------------------
          call ОКНО_АЛЕ         ;// Читаем Абсолютный Левый край окна
          mov  cx,[МЫШ_КООX2]   ;
          SUB  cx,ax            ;
          mov [МЫШ_СМЕЩX],CX    ;// Записываем смещеие ОТ левого края окна до координаты нажатия мышки

          mov  ax,cx            ;
          mov  cx,КОД_ПАР_ТКУX      ;// Установка текст курсор X
          call ЭЛЕ_УСТ_ПАР      ;
          ;--------------------



          ;-----------------------
          call ОКНО_АВЕ          ;// Читаем Абсолюиный Верхний край окна
          mov  cx,[МЫШ_КООY2]    ;
          SUB  cx,ax             ;
          mov [МЫШ_СМЕЩY],CX     ;

          mov  ax,cx             ;
          mov  cx,КОД_ПАР_ТКУY       ;// Установка текст курсор Y
          call ЭЛЕ_УСТ_ПАР       ;
          ;-----------------------

          ;--------------------;// Вычисление правой кооррдинаты окна
          call ОКНО_АПР          ;// Читаем правый край окна
          mov  cx,ax             ;// cx вычислили правый край окна
          dec  cx;
          ;-----------------------

          ;--------------------;// Вычисление нижней кооррдинаты окна
          call ОКНО_АНИ          ;// Читаем нижний  край окна
          mov  Dx,ax             ;// cx вычислили нижений край окна
          dec  dx;
          ;-----------------------

          ;-----------------------
          cmp [МЫШ_КООX2],CX     ;// Если мышка нажата по правому краю окна то
          jnz .ДАЛЕЕ3            ;
          add bx,1               ;// Если нажато по правому краю окна то BX=2;
          ;-----------------------
.ДАЛЕЕ3:
          ;-----------------------
          cmp [МЫШ_КООY2],DX     ;// Если нажато по нижнему краю окна
          JNZ .ДАЛЕЕ4            ;
          ADD BX,2               ;если нажата по нижнему краю то равно BX=3; либо 4 если по нижнему краю и правому краю
          ;-----------------------

.ДАЛЕЕ4:  MOV [МЫШ_ТИППЕ],BX     ;// Записываем типи дейтсвия над окощком

.ВЫХОД:
         popad;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
          pushad;

          mov  bx,Ax        ;// Запоминаем Символ и атрибуты
          ;-----------------;
          call ЭТО_ОКНО     ;
          jz  .ДАЛЕЕ        ;// Если элемент не являетсья окном то пропускам проверку пределов
          ;-----------------;

          ;-----------------;
          call ОКНО_ПРЕДЕЛЫ ;
          jz  .ВЫХОД        ;// ПРоверка предлов
          ;-----------------;
.ДАЛЕЕ:
          ;-----------------;
          Call ЭЛЕ_РОДИТЕЛЬ ;// Переходим в родительский элемент
          JZ  .РИСОВАТЬ     ;// Символ рисовать если больше родителей нету
          ;-----------------;

          ;-----------------;
          mov  ax,bx        ;
          call ОКНО_ВЫВОД_XY;
          Jmp .ВЫХОД        ;
          ;-----------------;
.РИСОВАТЬ:

          ;----------------------
          mov  ax,Bx            ;// Востанавливаем сивмол и атрибуты
          call ЭКРАН_ВЫВОД_AX_CX_DX ;// Выводи символ на экран
          ;----------------------


          cmp  cl,[МЫШ_КООX2];
          jnz .ВЫХОД;
          cmp  dl,[МЫШ_КООY2];
          jnz .ВЫХОД;

          ;----------------------
          call МЫШКА_ЩЕЛЧЕК     ;// Установка активного элемента по щелчку мышки
          jz  .ВЫХОД            ;// Если мышка не нажата то выход
          ;----------------------

          mov  di,SI            ;// Востанавливаем элемент источник печати символа

          mov [МЫШ_ВЫДЕ2],di    ;// Записываем дарес элемента по котрому нажата кнопка

          ;----------------------
          mov  bx,1             ;// Устанавливаем Режим перемещени окна
          mov [МЫШ_ТИППЕ],bx    ;// ПО умолчанию режим перемесчения окна
          ;--------------------

          ;--------------------
          call ОКНО_АЛЕ         ;// Читаем Абсолютный Левый край окна
          mov  cx,[МЫШ_КООX2]   ;
          SUB  cx,ax            ;
          mov [МЫШ_СМЕЩX],CX    ;// Записываем смещеие ОТ левого края окна до координаты нажатия мышки

          mov  ax,cx            ;
          mov  cx,КОД_ПАР_ТКУX      ;// Установка текст курсор X
          call ЭЛЕ_УСТ_ПАР      ;
          ;--------------------



          ;-----------------------
          call ОКНО_АВЕ          ;// Читаем Абсолюиный Верхний край окна
          mov  cx,[МЫШ_КООY2]    ;
          SUB  cx,ax             ;
          mov [МЫШ_СМЕЩY],CX     ;

          mov  ax,cx             ;
          mov  cx,КОД_ПАР_ТКУY       ;// Установка текст курсор Y
          call ЭЛЕ_УСТ_ПАР       ;
          ;-----------------------

          ;--------------------;// Вычисление правой кооррдинаты окна
          call ОКНО_АПР          ;// Читаем правый край окна
          mov  cx,ax             ;// cx вычислили правый край окна
          dec  cx;
          ;-----------------------

          ;--------------------;// Вычисление нижней кооррдинаты окна
          call ОКНО_АНИ          ;// Читаем нижний  край окна
          mov  Dx,ax             ;// cx вычислили нижений край окна
          dec  dx;
          ;-----------------------

          ;-----------------------
          cmp [МЫШ_КООX2],CX     ;// Если мышка нажата по правому краю окна то
          jnz .ДАЛЕЕ3            ;
          add bx,1               ;// Если нажато по правому краю окна то BX=2;
          ;-----------------------
.ДАЛЕЕ3:
          ;-----------------------
          cmp [МЫШ_КООY2],DX     ;// Если нажато по нижнему краю окна
          JNZ .ДАЛЕЕ4            ;
          ADD BX,2               ;если нажата по нижнему краю то равно BX=3; либо 4 если по нижнему краю и правому краю
          ;-----------------------

.ДАЛЕЕ4:  MOV [МЫШ_ТИППЕ],BX     ;// Записываем типи дейтсвия над окощком

.ВЫХОД:
         popad;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
          pushad;

          mov  ebx,eAx        ;// Запоминаем Символ и атрибуты
          ;-----------------;
          call ЭТО_ОКНО     ;
          jz  .ДАЛЕЕ        ;// Если элемент не являетсья окном то пропускам проверку пределов
          ;-----------------;

          ;-----------------;
          call ОКНО_ПРЕДЕЛЫ ;
          jz  .ВЫХОД        ;// ПРоверка предлов
          ;-----------------;
.ДАЛЕЕ:
          ;-----------------;
          Call ЭЛЕ_РОДИТЕЛЬ ;// Переходим в родительский элемент
          JZ  .РИСОВАТЬ     ;// Символ рисовать если больше родителей нету
          ;-----------------;

          ;-----------------;
          mov  eax,ebx        ;
          call ОКНО_ВЫВОД_XY;
          Jmp .ВЫХОД        ;
          ;-----------------;
.РИСОВАТЬ:

          ;----------------------
          mov  eax,eBx            ;// Востанавливаем сивмол и атрибуты
          call ЭКРАН_ВЫВОД_AX_CX_DX ;// Выводи символ на экран
          ;----------------------


          cmp  cl,[МЫШ_КООX2];
          jnz .ВЫХОД;
          cmp  dl,[МЫШ_КООY2];
          jnz .ВЫХОД;

          ;----------------------
          call МЫШКА_ЩЕЛЧЕК     ;// Установка активного элемента по щелчку мышки
          jz  .ВЫХОД            ;// Если мышка не нажата то выход
          ;----------------------

          mov  edi,eSI            ;// Востанавливаем элемент источник печати символа

          mov [МЫШ_ВЫДЕ2],edi    ;// Записываем дарес элемента по котрому нажата кнопка

          ;----------------------
          mov  ebx,1             ;// Устанавливаем Режим перемещени окна
          mov [МЫШ_ТИППЕ],ebx    ;// ПО умолчанию режим перемесчения окна
          ;--------------------

          ;--------------------
          call ОКНО_АЛЕ         ;// Читаем Абсолютный Левый край окна
          mov  ecx,[МЫШ_КООX2]   ;
          SUB  ecx,eax            ;
          mov [МЫШ_СМЕЩX],eCX    ;// Записываем смещеие ОТ левого края окна до координаты нажатия мышки

          mov  eax,ecx            ;
          mov  ecx,КОД_ПАР_ТКУX      ;// Установка текст курсор X
          call ЭЛЕ_УСТ_ПАР      ;
          ;--------------------



          ;-----------------------
          call ОКНО_АВЕ          ;// Читаем Абсолюиный Верхний край окна
          mov  ecx,[МЫШ_КООY2]    ;
          SUB  ecx,eax             ;
          mov [МЫШ_СМЕЩY],eCX     ;

          mov  eax,ecx             ;
          mov  ecx,КОД_ПАР_ТКУY       ;// Установка текст курсор Y
          call ЭЛЕ_УСТ_ПАР       ;
          ;-----------------------

          ;--------------------;// Вычисление правой кооррдинаты окна
          call ОКНО_АПР          ;// Читаем правый край окна
          mov  ecx,eax             ;// cx вычислили правый край окна
          dec  ecx;
          ;-----------------------

          ;--------------------;// Вычисление нижней кооррдинаты окна
          call ОКНО_АНИ          ;// Читаем нижний  край окна
          mov  eDx,eax             ;// cx вычислили нижений край окна
          dec  edx;
          ;-----------------------

          ;-----------------------
          cmp [МЫШ_КООX2],eCX     ;// Если мышка нажата по правому краю окна то
          jnz .ДАЛЕЕ3            ;
          add ebx,1               ;// Если нажато по правому краю окна то BX=2;
          ;-----------------------
.ДАЛЕЕ3:
          ;-----------------------
          cmp [МЫШ_КООY2],eDX     ;// Если нажато по нижнему краю окна
          JNZ .ДАЛЕЕ4            ;
          ADD eBX,2               ;если нажата по нижнему краю то равно BX=3; либо 4 если по нижнему краю и правому краю
          ;-----------------------

.ДАЛЕЕ4:  MOV [МЫШ_ТИППЕ],eBX     ;// Записываем типи дейтсвия над окощком

.ВЫХОД:
         popad;
         ret;
         END IF;}
;==============================================================================}
ОКНО_ОЧИСТКА :;{ Очищает участок экрана для рисования окна DI-SI
IF  (ПЛАТФОРМА = ДОС)   ;{
          pushad;

          ;------------------ Читаем XY
          Call ОКНО_АЛЕ     ;// Возвращает Координаты по X абсолютные AX для окна DI X1
          MOV  CL,AL        ;
          ;------------------
          Call ОКНО_АВЕ     ;// Возвращает Координаты по Y абсолютные AX для окна DI Y1
          MOV  DL,AL        ;
          ;------------------ Расчитываем X2
          Call ОКНО_АПР     ;// Возвращает ширину окна в регистре AX для окна DI
          MOV  CH,AL        ;
          ;------------------ Расчитываем Y2
          Call ОКНО_АНИ     ;// Возвращает Высоту окна в регистре AX для окна DI
          MOV  DH,AL        ;
          ;------------------  Читаем атрибуты
          Call ОКНО_АТР     ;// Возвращает атрибуты окна в регистре AH для окна DI;
          mov  AH,AL        ;
          mov  AL,' '       ;// Заноим пробел для затирания экрана
          ;------------------

          mov  bl,cl        ;// Запоминаем координату X1

.ЦИКЛ:    ;------------------
          cmp  dl,dh        ;// ПРоверяем не достигли ли нижней границы окна
          JAE .ВЫХОД        ;// Если достигли то очистка закончена
          CMP  CL,CH        ;//
          JAE .СЛЕДСТРО     ;// Если X>=X2 то переходим на след строку для очистки
          mov  si,di;
          call ОКНО_ВЫВОД_XY;
          INC  CL           ;// В противном случае сдвигаемся в право X:=X+1;
          JMP .ЦИКЛ         ;
.СЛЕДСТРО:
          MOV  CL,Bl        ;// Перемещаемся к левому краю
          INC  DL           ;// Увеличиваем координату по Y
          jmp .ЦИКЛ         ;
          ;-----------------
.ВЫХОД:



          popad             ;
          ret               ;
          END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
          pushad;

          ;------------------ Читаем XY
          Call ОКНО_АЛЕ     ;// Возвращает Координаты по X абсолютные AX для окна DI X1
          MOV  CL,AL        ;
          ;------------------
          Call ОКНО_АВЕ     ;// Возвращает Координаты по Y абсолютные AX для окна DI Y1
          MOV  DL,AL        ;
          ;------------------ Расчитываем X2
          Call ОКНО_АПР     ;// Возвращает ширину окна в регистре AX для окна DI
          MOV  CH,AL        ;
          ;------------------ Расчитываем Y2
          Call ОКНО_АНИ     ;// Возвращает Высоту окна в регистре AX для окна DI
          MOV  DH,AL        ;
          ;------------------  Читаем атрибуты
          Call ОКНО_АТР     ;// Возвращает атрибуты окна в регистре AH для окна DI;
          mov  AH,AL        ;
          mov  AL,' '       ;// Заноим пробел для затирания экрана
          ;------------------

          mov  bl,cl        ;// Запоминаем координату X1

.ЦИКЛ:    ;------------------
          cmp  dl,dh        ;// ПРоверяем не достигли ли нижней границы окна
          JAE .ВЫХОД        ;// Если достигли то очистка закончена
          CMP  CL,CH        ;//
          JAE .СЛЕДСТРО     ;// Если X>=X2 то переходим на след строку для очистки
          mov  si,di;
          call ОКНО_ВЫВОД_XY;
          INC  CL           ;// В противном случае сдвигаемся в право X:=X+1;
          JMP .ЦИКЛ         ;
.СЛЕДСТРО:
          MOV  CL,Bl        ;// Перемещаемся к левому краю
          INC  DL           ;// Увеличиваем координату по Y
          jmp .ЦИКЛ         ;
          ;-----------------
.ВЫХОД:



          popad             ;
          ret               ;
          END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
          pushad;
          mov ecx,0;
          mov edx,0;
          ;------------------ Читаем XY
          Call ОКНО_АЛЕ     ;// Возвращает Координаты по X абсолютные AX для окна DI X1
          MOV  CL,AL        ;
          ;------------------
          Call ОКНО_АВЕ     ;// Возвращает Координаты по Y абсолютные AX для окна DI Y1
          MOV  DL,AL        ;
          ;------------------ Расчитываем X2
          Call ОКНО_АПР     ;// Возвращает ширину окна в регистре AX для окна DI
          MOV  CH,AL        ;
          ;------------------ Расчитываем Y2
          Call ОКНО_АНИ     ;// Возвращает Высоту окна в регистре AX для окна DI
          MOV  DH,AL        ;
          ;------------------  Читаем атрибуты
          Call ОКНО_АТР     ;// Возвращает атрибуты окна в регистре AH для окна DI;
          mov  AH,AL        ;
          mov  AL,' '       ;// Заноим пробел для затирания экрана
          ;------------------

          mov  bl,cl        ;// Запоминаем координату X1

.ЦИКЛ:    ;------------------
          cmp  dl,dh        ;// ПРоверяем не достигли ли нижней границы окна
          JAE .ВЫХОД        ;// Если достигли то очистка закончена
          CMP  CL,CH        ;//
          JAE .СЛЕДСТРО     ;// Если X>=X2 то переходим на след строку для очистки
          mov  esi,edi;
          call ОКНО_ВЫВОД_XY;
          INC  CL           ;// В противном случае сдвигаемся в право X:=X+1;
          JMP .ЦИКЛ         ;
.СЛЕДСТРО:
          MOV  CL,Bl        ;// Перемещаемся к левому краю
          INC  DL           ;// Увеличиваем координату по Y
          jmp .ЦИКЛ         ;
          ;-----------------
.ВЫХОД:



          popad             ;
          ret               ;
          END IF;}
;==============================================================================}

ОКНО_ВЫВОД_XY2:;{ Вывод символа в окно Di-si  Cl-X DL-Y AX-Символ и атрибуты
IF  (ПЛАТФОРМА = ДОС)   ;{
          pushad;

          mov  bx,Ax        ;// Запоминаем Символ и атрибуты
          ;-----------------;
          call ЭТО_ОКНО     ;// Программа стала меньше
          jz  .ДАЛЕЕ        ;// Если элемент не являетсья окном то пропускам проверку пределов
          ;-----------------;

          ;----------------
          call ОКНО_ПРЕДЕЛЫ ;
          jz  .ВЫХОД        ;// ПРоверка предлов
          ;----------------
.ДАЛЕЕ:
          ;----------------
          Call ЭЛЕ_РОДИТЕЛЬ ;// Переходим в родительский элемент
          JZ  .РИСОВАТЬ     ;// Символ рисовать если больше родителей нету
          ;----------------

          ;----------------
          mov  ax,bx        ;
          call ОКНО_ВЫВОД_XY2;
          Jmp .ВЫХОД        ;
          ;----------------
.РИСОВАТЬ:

          ;----------------------
          mov  ax,Bx            ;// Востанавливаем сивмол и атрибуты
          call ЭКРАН_ВЫВОД_AX_CX_DX ;// Выводи символ на экран
          ;----------------------
.ВЫХОД:
         popad;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
          pushad;

          mov  bx,Ax        ;// Запоминаем Символ и атрибуты
          ;-----------------;
          call ЭТО_ОКНО     ;// Программа стала меньше
          jz  .ДАЛЕЕ        ;// Если элемент не являетсья окном то пропускам проверку пределов
          ;-----------------;

          ;----------------
          call ОКНО_ПРЕДЕЛЫ ;
          jz  .ВЫХОД        ;// ПРоверка предлов
          ;----------------
.ДАЛЕЕ:
          ;----------------
          Call ЭЛЕ_РОДИТЕЛЬ ;// Переходим в родительский элемент
          JZ  .РИСОВАТЬ     ;// Символ рисовать если больше родителей нету
          ;----------------

          ;----------------
          mov  ax,bx        ;
          call ОКНО_ВЫВОД_XY2;
          Jmp .ВЫХОД        ;
          ;----------------
.РИСОВАТЬ:

          ;----------------------
          mov  ax,Bx            ;// Востанавливаем сивмол и атрибуты
          call ЭКРАН_ВЫВОД_AX_CX_DX ;// Выводи символ на экран
          ;----------------------
.ВЫХОД:
         popad;
         ret;
         END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
          pushad;

          mov  ebx,eAx        ;// Запоминаем Символ и атрибуты
          ;-----------------;
          call ЭТО_ОКНО     ;// Программа стала меньше
          jz  .ДАЛЕЕ        ;// Если элемент не являетсья окном то пропускам проверку пределов
          ;-----------------;

          ;----------------
          call ОКНО_ПРЕДЕЛЫ ;
          jz  .ВЫХОД        ;// ПРоверка предлов
          ;----------------
.ДАЛЕЕ:
          ;----------------
          Call ЭЛЕ_РОДИТЕЛЬ ;// Переходим в родительский элемент
          JZ  .РИСОВАТЬ     ;// Символ рисовать если больше родителей нету
          ;----------------

          ;----------------
          mov  eax,ebx        ;
          call ОКНО_ВЫВОД_XY2;
          Jmp .ВЫХОД        ;
          ;----------------
.РИСОВАТЬ:

          ;----------------------
          mov  eax,eBx            ;// Востанавливаем сивмол и атрибуты
          call ЭКРАН_ВЫВОД_AX_CX_DX ;// Выводи символ на экран
          ;----------------------
.ВЫХОД:
         popad;
         ret;
         END IF;}

;==============================================================================}
ОКНО_РАМКА    :;{ Очищает участок экрана для рисования окна DI-SI
IF  (ПЛАТФОРМА = ДОС)   ;{
          pushad;

          ;-----------------; // Проверканужно ли рисовать рамку
          Call ОКНО_РАМ     ; // Возвращает Координаты по X абсолютные AX для окна DI X1
          Jz  .ВЫХОД        ; // Если Параметр РАМКА=0 То рисовать ненада
          ;-----------------;

          ;-----------------; Читаем XY
          Call ОКНО_АЛЕ     ;// Возвращает Координаты по X абсолютные AX для окна DI X1
          MOV  CL,AL        ;
          ;------------------
          Call ОКНО_АВЕ     ;// Возвращает Координаты по Y абсолютные AX для окна DI Y1
          MOV  DL,AL        ;
          ;------------------ Расчитываем X2
          Call ОКНО_АПР     ;// Возвращает ширину окна в регистре AX для окна DI
          MOV  CH,AL        ;
          ;------------------ Расчитываем Y2
          Call ОКНО_АНИ     ;// Возвращает Высоту окна в регистре AX для окна DI
          MOV  DH,AL        ;
          ;------------------  Читаем атрибуты
          Call ОКНО_АТР     ;// Возвращает атрибуты окна в регистре AH для окна DI;
          mov  AH,AL        ;
          mov  AL,' '       ;// Заноим пробел для затирания экрана
          ;------------------

          mov  bl,cl        ;// Запоминаем координату X1


          pushad
          mov  al,218;
          call ОКНО_ВЫВОД_XY2;
          popad;

          pushad
          mov  al,192;
          mov  dl,dh;
          dec  dl;
          call ОКНО_ВЫВОД_XY2;
          popad;


          pushad
          mov  cl,ch;
          dec  cl;
          mov  al,191;
          call ОКНО_ВЫВОД_XY2;
          popad

          pushad
          mov  cl,ch;
          dec  cl;
          mov  dl,dh;
          dec  dl;
          mov  al,217;
          call ОКНО_ВЫВОД_XY2;
          popad


          pushad
          mov  al,196;
          inc cl;
          dec ch;
.ЦИКЛ:
          cmp cl,ch;
          jae .КЦИКЛ;
          call ОКНО_ВЫВОД_XY2;
          push dx;
          mov dl,dh;
          dec dl;
          call ОКНО_ВЫВОД_XY2;
          pop dx;
          inc  cl;
          jmp .ЦИКЛ;
.КЦИКЛ:

          popad;

          mov  al,179;
          inc  dl;
          dec  dh;
.ЦИКЛ2:
          cmp  dl,dh;
          jae .КЦИКЛ2;
          call ОКНО_ВЫВОД_XY2;
          push cx;
          mov  cl,ch;
          dec  cl;
          call ОКНО_ВЫВОД_XY2;
          pop  cx;
          inc  dl;
          jmp .ЦИКЛ2;
.КЦИКЛ2:



.ВЫХОД:

          popad             ;
          ret               ;
          END IF            ;}
IF  (ПЛАТФОРМА = T16)   ;{
          pushad;

          ;-----------------; // Проверканужно ли рисовать рамку
          Call ОКНО_РАМ     ; // Возвращает Координаты по X абсолютные AX для окна DI X1
          Jz  .ВЫХОД        ; // Если Параметр РАМКА=0 То рисовать ненада
          ;-----------------;

          ;-----------------; Читаем XY
          Call ОКНО_АЛЕ     ;// Возвращает Координаты по X абсолютные AX для окна DI X1
          MOV  CL,AL        ;
          ;------------------
          Call ОКНО_АВЕ     ;// Возвращает Координаты по Y абсолютные AX для окна DI Y1
          MOV  DL,AL        ;
          ;------------------ Расчитываем X2
          Call ОКНО_АПР     ;// Возвращает ширину окна в регистре AX для окна DI
          MOV  CH,AL        ;
          ;------------------ Расчитываем Y2
          Call ОКНО_АНИ     ;// Возвращает Высоту окна в регистре AX для окна DI
          MOV  DH,AL        ;
          ;------------------  Читаем атрибуты
          Call ОКНО_АТР     ;// Возвращает атрибуты окна в регистре AH для окна DI;
          mov  AH,AL        ;
          mov  AL,' '       ;// Заноим пробел для затирания экрана
          ;------------------

          mov  bl,cl        ;// Запоминаем координату X1


          pushad
          mov  al,218;
          call ОКНО_ВЫВОД_XY2;
          popad;

          pushad
          mov  al,192;
          mov  dl,dh;
          dec  dl;
          call ОКНО_ВЫВОД_XY2;
          popad;


          pushad
          mov  cl,ch;
          dec  cl;
          mov  al,191;
          call ОКНО_ВЫВОД_XY2;
          popad

          pushad
          mov  cl,ch;
          dec  cl;
          mov  dl,dh;
          dec  dl;
          mov  al,217;
          call ОКНО_ВЫВОД_XY2;
          popad


          pushad
          mov  al,196;
          inc cl;
          dec ch;
.ЦИКЛ:
          cmp cl,ch;
          jae .КЦИКЛ;
          call ОКНО_ВЫВОД_XY2;
          push dx;
          mov dl,dh;
          dec dl;
          call ОКНО_ВЫВОД_XY2;
          pop dx;
          inc  cl;
          jmp .ЦИКЛ;
.КЦИКЛ:

          popad;

          mov  al,179;
          inc  dl;
          dec  dh;
.ЦИКЛ2:
          cmp  dl,dh;
          jae .КЦИКЛ2;
          call ОКНО_ВЫВОД_XY2;
          push cx;
          mov  cl,ch;
          dec  cl;
          call ОКНО_ВЫВОД_XY2;
          pop  cx;
          inc  dl;
          jmp .ЦИКЛ2;
.КЦИКЛ2:



.ВЫХОД:

          popad             ;
          ret               ;
          END IF            ;}
IF  (ПЛАТФОРМА = T32)   ;{
          pushad;

          ;-----------------; // Проверканужно ли рисовать рамку
          Call ОКНО_РАМ     ; // Возвращает Координаты по X абсолютные AX для окна DI X1
          Jz  .ВЫХОД        ; // Если Параметр РАМКА=0 То рисовать ненада
          ;-----------------;

          ;-----------------; Читаем XY
          Call ОКНО_АЛЕ     ;// Возвращает Координаты по X абсолютные AX для окна DI X1
          MOV  CL,AL        ;
          ;------------------
          Call ОКНО_АВЕ     ;// Возвращает Координаты по Y абсолютные AX для окна DI Y1
          MOV  DL,AL        ;
          ;------------------ Расчитываем X2
          Call ОКНО_АПР     ;// Возвращает ширину окна в регистре AX для окна DI
          MOV  CH,AL        ;
          ;------------------ Расчитываем Y2
          Call ОКНО_АНИ     ;// Возвращает Высоту окна в регистре AX для окна DI
          MOV  DH,AL        ;
          ;------------------  Читаем атрибуты
          Call ОКНО_АТР     ;// Возвращает атрибуты окна в регистре AH для окна DI;
          mov  AH,AL        ;
          mov  AL,' '       ;// Заноим пробел для затирания экрана
          ;------------------

          mov  bl,cl        ;// Запоминаем координату X1


          pushad
          mov  al,218;
          call ОКНО_ВЫВОД_XY2;
          popad;

          pushad
          mov  al,192;
          mov  dl,dh;
          dec  dl;
          call ОКНО_ВЫВОД_XY2;
          popad;


          pushad
          mov  cl,ch;
          dec  cl;
          mov  al,191;
          call ОКНО_ВЫВОД_XY2;
          popad

          pushad
          mov  cl,ch;
          dec  cl;
          mov  dl,dh;
          dec  dl;
          mov  al,217;
          call ОКНО_ВЫВОД_XY2;
          popad


          pushad
          mov  al,196;
          inc cl;
          dec ch;
.ЦИКЛ:
          cmp cl,ch;
          jae .КЦИКЛ;
          call ОКНО_ВЫВОД_XY2;
          push edx;
          mov dl,dh;
          dec dl;
          call ОКНО_ВЫВОД_XY2;
          pop edx;
          inc  cl;
          jmp .ЦИКЛ;
.КЦИКЛ:

          popad;

          mov  al,179;
          inc  dl;
          dec  dh;
.ЦИКЛ2:
          cmp  dl,dh;
          jae .КЦИКЛ2;
          call ОКНО_ВЫВОД_XY2;
          push cx;
          mov  cl,ch;
          dec  cl;
          call ОКНО_ВЫВОД_XY2;
          pop  cx;
          inc  dl;
          jmp .ЦИКЛ2;
.КЦИКЛ2:



.ВЫХОД:

          popad             ;
          ret               ;
          END IF            ;}

;==============================================================================}

ОКНО_ВЫВОД_ТЕ:;{ Выводит текста окна di
IF  (ПЛАТФОРМА = ДОС)   ;{
        pushad;
        call СБРОС_КЕША
        ;---------------;
        mov  cx,КОД_ПАР_КССК  ;// Указываем количество символов в строке с курсором равно 0
        mov  ax,0         ;
        Call ЭЛЕ_УСТ_ПАР  ;
        ;---------------;
        mov  cx,КОД_ПАР_КОСТ  ;// Указываем количество символов в строке с курсором равно 0
        mov  ax,0         ;
        Call ЭЛЕ_УСТ_ПАР  ;
        ;---------------;
        mov  cx,КОД_ПАР_ПАВС  ;// Указываем предположительный адрес для вставки символа
        call ОКНО_ТЕК     ;// Читаем адрес текста
        Call ЭЛЕ_УСТ_ПАР  ;

        test   ax,ax      ;
        jz    .ВЫХОД      ;// если текст отсуствует тто выход
        ;------------------

        Mov    si,ax      ;// Сохраняем адрес выводимого  текста в регистр SI
        mov    cx,0       ;// Координата в тексте X
        mov    dx,0       ;// Координата в тексте Y

.ЦИКЛ:
        ;-------------------
        call ОКНО_АКY      ;
        cmp  dx,ax         ;
        jae .ДАЛЕЕ2        ;
        mov  bx,cx         ;// Сохраняем содержимое регистра CX - X
        mov  ax,cx         ;
        mov  cx,КОД_ПАР_ДПСТ;
        call ЭЛЕ_УСТ_ПАР   ;
        mov  cx,bx         ;// Востанавливаем содержимое CX
        ;-------------------
.ДАЛЕЕ2:
        ;----------------;
        call ОКНО_АКY      ;// Получаем абсолютные координаты курсора по Y в тексте
        cmp  dx,ax         ;
        jnz .ДАЛЕЕ         ;
        call ОКНО_АКX      ;// Получаем абсолютные координаты курсора по X в тексте
        cmp  cx,ax         ;
        ja  .ДАЛЕЕ         ;

        mov  bx,cx         ;// Сохраняем значение регистра CX

        mov  ax,cx         ;// Сохраняем правый край строки в месте где расположен курсор
        mov  cx,КОД_ПАР_КССК   ;
        Call ЭЛЕ_УСТ_ПАР   ;
        mov  ax,si         ;
        mov  cx,КОД_ПАР_ПАВС   ;// сохраняем адрес символа в тексте окна где расположен правый крвй строки в месте где располен край строки
        Call ЭЛЕ_УСТ_ПАР   ;

        mov cx,bx          ;// Востанавливаем значение регистра CX
        ;----------------;
.ДАЛЕЕ:
        ;----------------;
        mov    al,[si]     ;// Читаем символ из текста
        test   al,al       ;// Проверяем на звершение текста 0
        jz    .ВЫХОД       ;
        ;----------------;

        ;----------------;
        cmp   al,13        ;// ПРоверка на перевод каретки перевод строки
        jZ   .ENTER        ;// Если первод строки то переходим к .ENTER
        ;----------------;
        call .OUTCHA       ;// Вывод символа
        inc   cx           ;// Сдвигаем символ в право
        inc   si           ;
        jmp  .ЦИКЛ         ;
        ;----------------;

.ENTER:

        ;----------------;
        inc   si           ;
        mov   cx,0         ;
        inc   Dx           ;

        ;----------------; Запоминаем количество строк в тексте
        mov   bx,cx        ; Сохраняем значение регистра CX
        mov   cx,КОД_ПАР_КОСТ  ;
        mov   ax,dx        ;
        call  ЭЛЕ_УСТ_ПАР  ;
        mov   cx,bx        ; Востанавливаем значение CX
        JMP  .ЦИКЛ         ;
        ;----------------;

.ВЫХОД:
        popad ;
        ret   ;


.OUTCHA:

        pushad;

        mov   si,ax   ;// Сохраняем выводимый символ d BL
        call  ОКНО_ТСX;// Читаем смещение внтури текста X
        cmp   cx,ax   ;// проверяем что выводимый символ больше либо равно смещения в тексте
        jb   .ВЫХОД2  ;// Если меньше смещения то выход

        mov   bx,ax   ;// Запоминаем смещение внтури текста
        call  ОКНО_ШИР;// Читаем ширину окна
        add   ax,bx   ;// складываем смещенеи внтури текста и ширину окна
        cmp   cx,ax   ;// Сравниаем с X
        JA   .ВЫХОД2  ;// если оказалася больше то выход

        call  ОКНО_ТСY;// Читаем смещение внтури текста Y
        cmp   dx,ax   ;// проверяем что выводимый символ больше либо равно смещения в тексте
        jb   .ВЫХОД2  ;// Если меньше смещения то выход

        mov   bx,ax   ;// Запоминаем смещение внтури текста
        call  ОКНО_ВЫС;// Читаем Dscjnt jryf  окна
        add   ax,bx   ;// складываем смещенеи внтури текста и Высотук  окна
        cmp   dx,ax   ;// Сравниаем с Y
        JA   .ВЫХОД2  ;// если оказалася больше то выход

        call  ОКНО_ТСX;// Вычитаем из координаты символа смещене  внутри текста
        SUB   cx,AX  ;
        call  ОКНО_АЛЕ;// прибавляем абсолютную координату окнга слева
        add   cx,ax;

        call  ОКНО_ТСY;// Вычитаем из координаты символа смещене  внутри текста
        SUB   dx,AX  ;
        call  ОКНО_АВЕ;// прибавляем абсолютную координату окнга слева
        add   Dx,ax;

        call  ОКНО_АТР     ;// читем  атрибуты окна
        mov   bl,al        ;
        mov   ax,si        ;// Востанавлвиаем печатаемый символ
        mov   ah,bl        ;
        mov   si,di;
        call  ОКНО_ВЫВОД_XY;// Выводим символ в окно

.ВЫХОД2:
        popad;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
        pushad;
        call СБРОС_КЕША
        ;---------------;
        mov  cx,КОД_ПАР_КССК  ;// Указываем количество символов в строке с курсором равно 0
        mov  ax,0         ;
        Call ЭЛЕ_УСТ_ПАР  ;
        ;---------------;
        mov  cx,КОД_ПАР_КОСТ  ;// Указываем количество символов в строке с курсором равно 0
        mov  ax,0         ;
        Call ЭЛЕ_УСТ_ПАР  ;
        ;---------------;
        mov  cx,КОД_ПАР_ПАВС  ;// Указываем предположительный адрес для вставки символа
        call ОКНО_ТЕК     ;// Читаем адрес текста
        Call ЭЛЕ_УСТ_ПАР  ;

        test   ax,ax      ;
        jz    .ВЫХОД      ;// если текст отсуствует тто выход
        ;------------------

        Mov    si,ax      ;// Сохраняем адрес выводимого  текста в регистр SI
        mov    cx,0       ;// Координата в тексте X
        mov    dx,0       ;// Координата в тексте Y

.ЦИКЛ:
        ;-------------------
        call ОКНО_АКY      ;
        cmp  dx,ax         ;
        jae .ДАЛЕЕ2        ;
        mov  bx,cx         ;// Сохраняем содержимое регистра CX - X
        mov  ax,cx         ;
        mov  cx,КОД_ПАР_ДПСТ   ;
        call ЭЛЕ_УСТ_ПАР   ;
        mov  cx,bx         ;// Востанавливаем содержимое CX
        ;-------------------
.ДАЛЕЕ2:
        ;----------------;
        call ОКНО_АКY      ;// Получаем абсолютные координаты курсора по Y в тексте
        cmp  dx,ax         ;
        jnz .ДАЛЕЕ         ;
        call ОКНО_АКX      ;// Получаем абсолютные координаты курсора по X в тексте
        cmp  cx,ax         ;
        ja  .ДАЛЕЕ         ;

        mov  bx,cx         ;// Сохраняем значение регистра CX

        mov  ax,cx         ;// Сохраняем правый край строки в месте где расположен курсор
        mov  cx,КОД_ПАР_КССК   ;
        Call ЭЛЕ_УСТ_ПАР   ;
        mov  ax,si         ;
        mov  cx,КОД_ПАР_ПАВС   ;// сохраняем адрес символа в тексте окна где расположен правый крвй строки в месте где располен край строки
        Call ЭЛЕ_УСТ_ПАР   ;

        mov cx,bx          ;// Востанавливаем значение регистра CX
        ;----------------;
.ДАЛЕЕ:
        ;----------------;
        mov    al,[si]     ;// Читаем символ из текста
        test   al,al       ;// Проверяем на звершение текста 0
        jz    .ВЫХОД       ;
        ;----------------;

        ;----------------;
        cmp   al,13        ;// ПРоверка на перевод каретки перевод строки
        jZ   .ENTER        ;// Если первод строки то переходим к .ENTER
        ;----------------;
        call .OUTCHA       ;// Вывод символа
        inc   cx           ;// Сдвигаем символ в право
        inc   si           ;
        jmp  .ЦИКЛ         ;
        ;----------------;

.ENTER:

        ;----------------;
        inc   si           ;
        mov   cx,0         ;
        inc   Dx           ;

        ;----------------; Запоминаем количество строк в тексте
        mov   bx,cx        ; Сохраняем значение регистра CX
        mov   cx,КОД_ПАР_КОСТ  ;
        mov   ax,dx        ;
        call  ЭЛЕ_УСТ_ПАР  ;
        mov   cx,bx        ; Востанавливаем значение CX
        JMP  .ЦИКЛ         ;
        ;----------------;

.ВЫХОД:
        popad ;
        ret   ;


.OUTCHA:

        pushad;

        mov   si,ax   ;// Сохраняем выводимый символ d BL
        call  ОКНО_ТСX;// Читаем смещение внтури текста X
        cmp   cx,ax   ;// проверяем что выводимый символ больше либо равно смещения в тексте
        jb   .ВЫХОД2  ;// Если меньше смещения то выход

        mov   bx,ax   ;// Запоминаем смещение внтури текста
        call  ОКНО_ШИР;// Читаем ширину окна
        add   ax,bx   ;// складываем смещенеи внтури текста и ширину окна
        cmp   cx,ax   ;// Сравниаем с X
        JA   .ВЫХОД2  ;// если оказалася больше то выход

        call  ОКНО_ТСY;// Читаем смещение внтури текста Y
        cmp   dx,ax   ;// проверяем что выводимый символ больше либо равно смещения в тексте
        jb   .ВЫХОД2  ;// Если меньше смещения то выход

        mov   bx,ax   ;// Запоминаем смещение внтури текста
        call  ОКНО_ВЫС;// Читаем Dscjnt jryf  окна
        add   ax,bx   ;// складываем смещенеи внтури текста и Высотук  окна
        cmp   dx,ax   ;// Сравниаем с Y
        JA   .ВЫХОД2  ;// если оказалася больше то выход

        call  ОКНО_ТСX;// Вычитаем из координаты символа смещене  внутри текста
        SUB   cx,AX  ;
        call  ОКНО_АЛЕ;// прибавляем абсолютную координату окнга слева
        add   cx,ax;

        call  ОКНО_ТСY;// Вычитаем из координаты символа смещене  внутри текста
        SUB   dx,AX  ;
        call  ОКНО_АВЕ;// прибавляем абсолютную координату окнга слева
        add   Dx,ax;

        call  ОКНО_АТР     ;// читем  атрибуты окна
        mov   bl,al        ;
        mov   ax,si        ;// Востанавлвиаем печатаемый символ
        mov   ah,bl        ;
        mov   si,di;
        call  ОКНО_ВЫВОД_XY;// Выводим символ в окно

.ВЫХОД2:
        popad;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
        pushad;
        call СБРОС_КЕША
        ;---------------;
        mov  ecx,КОД_ПАР_КССК  ;// Указываем количество символов в строке с курсором равно 0
        mov  eax,0         ;
        Call ЭЛЕ_УСТ_ПАР  ;
        ;---------------;
        mov  ecx,КОД_ПАР_КОСТ  ;// Указываем количество символов в строке с курсором равно 0
        mov  eax,0         ;
        Call ЭЛЕ_УСТ_ПАР  ;
        ;---------------;
        mov  ecx,КОД_ПАР_ПАВС  ;// Указываем предположительный адрес для вставки символа
        call ОКНО_ТЕК     ;// Читаем адрес текста
        Call ЭЛЕ_УСТ_ПАР  ;

        test   eax,eax      ;
        jz    .ВЫХОД      ;// если текст отсуствует тто выход
        ;------------------

        Mov    esi,eax      ;// Сохраняем адрес выводимого  текста в регистр SI
        mov    ecx,0       ;// Координата в тексте X
        mov    edx,0       ;// Координата в тексте Y

.ЦИКЛ:
        ;-------------------
        call ОКНО_АКY      ;
        cmp  edx,eax         ;
        jae .ДАЛЕЕ2        ;
        mov  ebx,ecx         ;// Сохраняем содержимое регистра CX - X
        mov  eax,ecx         ;
        mov  ecx,КОД_ПАР_ДПСТ   ;
        call ЭЛЕ_УСТ_ПАР   ;
        mov  ecx,ebx         ;// Востанавливаем содержимое CX
        ;-------------------
.ДАЛЕЕ2:
        ;----------------;
        call ОКНО_АКY      ;// Получаем абсолютные координаты курсора по Y в тексте
        cmp  edx,eax         ;
        jnz .ДАЛЕЕ         ;
        call ОКНО_АКX      ;// Получаем абсолютные координаты курсора по X в тексте
        cmp  ecx,eax         ;
        ja  .ДАЛЕЕ         ;

        mov  ebx,ecx         ;// Сохраняем значение регистра CX

        mov  eax,ecx         ;// Сохраняем правый край строки в месте где расположен курсор
        mov  ecx,КОД_ПАР_КССК   ;
        Call ЭЛЕ_УСТ_ПАР   ;
        mov  eax,esi         ;
        mov  ecx,КОД_ПАР_ПАВС   ;// сохраняем адрес символа в тексте окна где расположен правый крвй строки в месте где располен край строки
        Call ЭЛЕ_УСТ_ПАР   ;

        mov ecx,ebx          ;// Востанавливаем значение регистра CX
        ;----------------;
.ДАЛЕЕ:
        ;----------------;
        mov    al,[esi]     ;// Читаем символ из текста
        test   al,al       ;// Проверяем на звершение текста 0
        jz    .ВЫХОД       ;
        ;----------------;

        ;----------------;
        cmp   al,13        ;// ПРоверка на перевод каретки перевод строки
        jZ   .ENTER        ;// Если первод строки то переходим к .ENTER
        ;----------------;
        call .OUTCHA       ;// Вывод символа
        inc   ecx           ;// Сдвигаем символ в право
        inc   esi           ;
        jmp  .ЦИКЛ         ;
        ;----------------;

.ENTER:

        ;----------------;
        inc   esi           ;
        mov   ecx,0         ;
        inc   eDx           ;

        ;----------------; Запоминаем количество строк в тексте
        mov   ebx,ecx        ; Сохраняем значение регистра CX
        mov   ecx,КОД_ПАР_КОСТ  ;
        mov   eax,edx        ;
        call  ЭЛЕ_УСТ_ПАР  ;
        mov   ecx,ebx        ; Востанавливаем значение CX
        JMP  .ЦИКЛ         ;
        ;----------------;

.ВЫХОД:
        popad ;
        ret   ;


.OUTCHA:

        pushad;

        mov   esi,eax   ;// Сохраняем выводимый символ d BL
        call  ОКНО_ТСX;// Читаем смещение внтури текста X
        cmp   ecx,eax   ;// проверяем что выводимый символ больше либо равно смещения в тексте
        jb   .ВЫХОД2  ;// Если меньше смещения то выход

        mov   ebx,eax   ;// Запоминаем смещение внтури текста
        call  ОКНО_ШИР;// Читаем ширину окна
        add   eax,ebx   ;// складываем смещенеи внтури текста и ширину окна
        cmp   ecx,eax   ;// Сравниаем с X
        JA   .ВЫХОД2  ;// если оказалася больше то выход

        call  ОКНО_ТСY;// Читаем смещение внтури текста Y
        cmp   edx,eax   ;// проверяем что выводимый символ больше либо равно смещения в тексте
        jb   .ВЫХОД2  ;// Если меньше смещения то выход

        mov   ebx,eax   ;// Запоминаем смещение внтури текста
        call  ОКНО_ВЫС;// Читаем Dscjnt jryf  окна
        add   eax,ebx   ;// складываем смещенеи внтури текста и Высотук  окна
        cmp   edx,eax   ;// Сравниаем с Y
        JA   .ВЫХОД2  ;// если оказалася больше то выход

        call  ОКНО_ТСX;// Вычитаем из координаты символа смещене  внутри текста
        SUB   ecx,eAX  ;
        call  ОКНО_АЛЕ;// прибавляем абсолютную координату окнга слева
        add   ecx,eax;

        call  ОКНО_ТСY;// Вычитаем из координаты символа смещене  внутри текста
        SUB   edx,eAX  ;
        call  ОКНО_АВЕ;// прибавляем абсолютную координату окнга слева
        add   eDx,eax;

        call  ОКНО_АТР     ;// читем  атрибуты окна
        mov   bl,al        ;
        mov   eax,esi        ;// Востанавлвиаем печатаемый символ
        mov   ah,bl        ;
        mov   esi,edi;
        call  ОКНО_ВЫВОД_XY;// Выводим символ в окно

.ВЫХОД2:
        popad;
        ret;
        END IF;}
;==============================================================================}
ОКНО_ВЫВОД_КУ:;{ РИсует курсор Окна Di
IF  (ПЛАТФОРМА = ДОС)   ;{
       pushad
       cmp   di,[МЫШ_ВЫДЕ2];// сравниваем с активным окном
       jnz  .ВЫХОД         ;// Если окно не активно рисовать курсор ненадаь

       ;--------------------
       Call  ОКНО_ТКX      ;// Вычисление абсолютных координат курсора на экране
       mov   CX,ax         ;
       call  ОКНО_АЛЕ      ;
       add   cx,ax         ;
       ;--------------------

       ;--------------------
       Call  ОКНО_ТКY      ;// Вычисление абсолюной коорднаты Y на экране
       mov   DX,ax         ;
       call  ОКНО_АВЕ      ;
       add   dx,ax         ;
       ;--------------------

       call  ОКНО_АКУ
       mov   ah,al;
       mov   al,0;
       mov   si,di;
       Call  ОКНО_ВЫВОД_XY ;
.ВЫХОД:
       popad;
       ret;
       END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
       pushad
       cmp   di,[МЫШ_ВЫДЕ2];// сравниваем с активным окном
       jnz  .ВЫХОД         ;// Если окно не активно рисовать курсор ненадаь

       ;--------------------
       Call  ОКНО_ТКX      ;// Вычисление абсолютных координат курсора на экране
       mov   CX,ax         ;
       call  ОКНО_АЛЕ      ;
       add   cx,ax         ;
       ;--------------------

       ;--------------------
       Call  ОКНО_ТКY      ;// Вычисление абсолюной коорднаты Y на экране
       mov   DX,ax         ;
       call  ОКНО_АВЕ      ;
       add   dx,ax         ;
       ;--------------------

       call  ОКНО_АКУ
       mov   ah,al;
       mov   al,0;
       mov   si,di;
       Call  ОКНО_ВЫВОД_XY ;
.ВЫХОД:
       popad;
       ret;
       END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
       pushad
       cmp   edi,[МЫШ_ВЫДЕ2];// сравниваем с активным окном
       jnz  .ВЫХОД         ;// Если окно не активно рисовать курсор ненадаь

       ;--------------------
       Call  ОКНО_ТКX      ;// Вычисление абсолютных координат курсора на экране
       mov   eCX,eax         ;
       call  ОКНО_АЛЕ      ;
       add   ecx,eax         ;
       ;--------------------

       ;--------------------
       Call  ОКНО_ТКY      ;// Вычисление абсолюной коорднаты Y на экране
       mov   eDX,eax         ;
       call  ОКНО_АВЕ      ;
       add   edx,eax         ;
       ;--------------------

       call  ОКНО_АКУ
       mov   ah,al;
       mov   al,0;
       mov   esi,edi;
       Call  ОКНО_ВЫВОД_XY ;
.ВЫХОД:
       popad;
       ret;
       END IF;}
;==============================================================================}


ОКНО_РИСОВАТЬ:;{ Пытаеться нарисовать Элемент DI как окно
IF  (ПЛАТФОРМА = ДОС)   ;{
        pushad;
        call ЭТО_ОКНО     ; // все понятно вот эта фун не работает толком
        jz  .ВЫХОД        ;


        call ОКНО_ОЧИСТКА ;// ПОдгатавливает место под рисование текста окна
        Call ОКНО_РАМКА   ;
        call ОКНО_ВЫВОД_ТЕ;// Выводит текст окна di
        call ОКНО_ВЫВОД_КУ;// Выводит курсора окна di
.ВЫХОД:
        popad;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
        pushad;

        ;call ОТЛАДЧИК1    ; // Ну хотя бы нашел место где проблемма
        call ЭТО_ОКНО     ; // все понятно вот эта фун не работает толком
        jz  .ВЫХОД        ;


        call ОКНО_ОЧИСТКА ;// ПОдгатавливает место под рисование текста окна
        Call ОКНО_РАМКА   ;
        call ОКНО_ВЫВОД_ТЕ;// Выводит текст окна di
        call ОКНО_ВЫВОД_КУ;// Выводит курсора окна di
.ВЫХОД:
        popad;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
        pushad;

        ;call ОТЛАДЧИК1    ; // Ну хотя бы нашел место где проблемма
        call ЭТО_ОКНО     ; // все понятно вот эта фун не работает толком
        jz  .ВЫХОД        ;


        call ОКНО_ОЧИСТКА ;// ПОдгатавливает место под рисование текста окна
        Call ОКНО_РАМКА   ;
        call ОКНО_ВЫВОД_ТЕ;// Выводит текст окна di
        call ОКНО_ВЫВОД_КУ;// Выводит курсора окна di
.ВЫХОД:
        popad;
        ret;
        END IF;}
;==============================================================================}

ОКНО_РИСО_ВСЕ:;{ РИсует окно DI и все вложеные окна
IF  (ПЛАТФОРМА = ДОС)   ;{
        pushad;
        test di,di        ;
        jz  .ВЫХОД        ;
        call ОКНО_РИСОВАТЬ; // РИсуем коно DI
        Call ЭЛЕ_ВЛО      ; // Перемещаемся к первому вложеному элемнту
.ЦИКЛ:  test ax,ax        ; // ПРоверка на NIL
        jz  .КЦИКЛ        ; // Если окно не существует закончить рисование
        mov  di,ax        ; // Если 0 Выход
        Call ОКНО_РИСО_ВСЕ; // Рисуем окна вложеные в этот элемент рекурсия
        Call ЭЛЕ_СЛЕ      ; // Переходим к следующему окну
        Jmp .ЦИКЛ         ;
.КЦИКЛ:
.ВЫХОД:
        popad;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
        pushad;
        test di,di        ;
        jz  .ВЫХОД        ;
        call ОКНО_РИСОВАТЬ; // РИсуем коно DI
        Call ЭЛЕ_ВЛО      ; // Перемещаемся к первому вложеному элемнту
.ЦИКЛ:  test ax,ax        ; // ПРоверка на NIL
        jz  .КЦИКЛ        ; // Если окно не существует закончить рисование
        mov  di,ax        ; // Если 0 Выход
        Call ОКНО_РИСО_ВСЕ; // Рисуем окна вложеные в этот элемент рекурсия
        Call ЭЛЕ_СЛЕ      ; // Переходим к следующему окну
        Jmp .ЦИКЛ         ;
.КЦИКЛ:
.ВЫХОД:
        popad;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
        pushad;
        test edi,edi        ;
        jz  .ВЫХОД        ;
        call ОКНО_РИСОВАТЬ; // РИсуем коно DI
        Call ЭЛЕ_ВЛО      ; // Перемещаемся к первому вложеному элемнту
.ЦИКЛ:  test eax,eax        ; // ПРоверка на NIL
        jz  .КЦИКЛ        ; // Если окно не существует закончить рисование
        mov  edi,eax        ; // Если 0 Выход
        Call ОКНО_РИСО_ВСЕ; // Рисуем окна вложеные в этот элемент рекурсия
        Call ЭЛЕ_СЛЕ      ; // Переходим к следующему окну
        Jmp .ЦИКЛ         ;
.КЦИКЛ:
.ВЫХОД:
        popad;
        ret;
        END IF;}
;==============================================================================}
ОКНО_ПЕРЕМЕЩЕ:;{ Функция для перемещения окон на экране
IF  (ПЛАТФОРМА = ДОС)   ;{
        pushad;

        ;-------------------
        call МЫШКА_НАЖАТА  ;
        JZ  .ВЫХОД         ;// Если мышка не нажата перемещение не осуществляеться
        ;-------------------

        ;-------------------
        mov  ax,[МЫШ_ВЫДЕ1]; ПРоверяем наличае элемента по котрому была нажата кнопка прошлый раз
        test ax,ax         ;
        JZ  .ВЫХОД         ;
        mov  ax,[МЫШ_ВЫДЕ2]; ПРоверяем наличае элемента по котрому была нажата кнопка щас
        test ax,ax         ;
        JZ  .ВЫХОД         ;
        mov  ax,[МЫШ_ВЫДЕ1];// ПРоверяем что реч идет об одном и том же элементе что и в прошлый рас нажатия кнопки
        cmp  ax,[МЫШ_ВЫДЕ2];
        JNZ .ВЫХОД         ;     Готово осталося порядок навести
        ;-------------------

        mov DI,[МЫШ_ВЫДЕ2] ;// Проверяем что элемент являеться имиено окошком
        call ЭТО_ОКНО      ;
        JZ  .ВЫХОД         ;


        mov  ax,[МЫШ_ТИППЕ];// СМотрим тип перемещения
        cmp  ax,1          ;
        JZ  .ОКПЕР         ;// Просто перемещение окна
        cmp  ax,2          ;
        JZ  .ОКШИР         ;// Изменение ширины окна
        cmp  ax,3          ;
        JZ  .ОКВЫС         ;// Изменение ВЫСОТЫ окна
        cmp  ax,4          ;
        JZ  .ОКРАЗ         ;// Изменеине размера окна
        Jmp .ВЫХОД         ;

.ОКПЕР:;{ НЕпосредственно перемещение
        call ОКНО_АЛЕ       ;// Читаем абсолютные координаты по Х окна котрое нужно подвинуть
        add  ax,[МЫШ_СМЕЩX] ;
        cmp  [МЫШ_КООX2],ax ;// Сравниваем с координатами мышки координату окна по Х
        JA  .XБОЛ           ;// Если координата мышки оказалася больше координаты окна
        JB  .XМЕН           ;// Если координата мышки оказалася Меньше координаты окна
        JMP .ДАЛЕЕ          ;

.XБОЛ:  ;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ЛЕВ       ;// Читаем локальную координату окна
        inc  ax             ;// и увеличиваем её
        mov  CX,КОД_ПАР_ЛЕВО;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР    ;// Устанавливаем значения параметра окна левый край
        JMP .ДАЛЕЕ          ;

.XМЕН:  ;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ЛЕВ       ;// Читаем локальную координату окна
        test ax,ax          ;// Ниже нудя нельзя
        jz  .ДАЛЕЕ          ;
        dec  ax             ;// и увеличиваем её
        mov  CX,КОД_ПАР_ЛЕВО    ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР    ;// Устанавлвиаем значение параметра окна
        JMP .ДАЛЕЕ          ;
.ДАЛЕЕ:
        call ОКНО_АВЕ       ;// Читаем абсолютные координаты по Х окна котрое нужно подвинуть
        add  ax,[МЫШ_СМЕЩY] ;
        cmp  [МЫШ_КООY2],ax ;// Сравниваем с координатами мышки координату окна по Х
        JA  .YБОЛ           ;// Если координата мышки оказалася больше координаты окна
        JB  .YМЕН           ;// Если координата мышки оказалася Меньше координаты окна
        JMP .ВЫХОД          ;

.YБОЛ:  ;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ВЕР   ;// Читаем локальную координату окна
        inc  ax         ;// и увеличиваем её
        mov  CX,КОД_ПАР_ВЕРХ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР;// Элемент сет параметр
        JMP .ВЫХОД      ;

.YМЕН:  ;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ВЕР    ;// Читаем локальную координату окна
        test ax,ax      ;// Ниже нудя нельзя
        jz  .ВЫХОД
        dec  ax         ;// и увеличиваем её
        mov  CX,КОД_ПАР_ВЕРХ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР;// Элемент сет параметр
        JMP .ВЫХОД      ;
        ;}
.ОКШИР:;{ изменение шинрины окна

         push dx
         call ОКНО_АПР      ;// Читаем абсолютные координаты по Х окна котрое нужно подвинуть
         dec  ax;


         mov  dx,[МЫШ_КООX2];
         sub  dx,ax;
         cmp  [МЫШ_КООX2],ax;// Сравниваем с координатами мышки координату окна по Х
         JA  .ПРXБОЛ        ;// Если координата мышки оказалася больше координаты окна
         JB  .ПРXМЕН        ;// Если координата мышки оказалася Меньше координаты окна
         JMP .ПРДАЛЕЕ       ;// Ох ё ничего себе навзвания )))

.ПРXБОЛ: ;// Если координата мышки оказалася больше двигаем окно по х к мышке
         CAll ОКНО_ШИР      ;// Читаем локальную координату окна
         add  ax,dx         ;// и увеличиваем её
         mov  CX,КОД_ПАР_ШИРИ   ;// и сохраняем значение
         call ЭЛЕ_УСТ_ПАР   ;// Элемент сет параметр
         JMP .ПРДАЛЕЕ       ;

.ПРXМЕН: ;// Если координата мышки оказалася больше двигаем окно по х к мышке
         CAll ОКНО_ШИР      ;// Читаем локальную координату окна
         cmp  ax,1          ;// Ниже нудя нельзя
         jbe .ПРДАЛЕЕ       ;
         sub  ax,dx         ;// и увеличиваем её
         mov  CX,КОД_ПАР_ШИРИ   ;// и сохраняем значение
         call ЭЛЕ_УСТ_ПАР   ;// Элемент сет параметр
         JMP .ПРДАЛЕЕ       ;

.ПРДАЛЕЕ:pop dx
         JMP .ВЫХОД         ;




        ;}
.ОКВЫС:;{ изменение Высота окна

        call ОКНО_АНИ     ;// Читаем абсолютные координаты по Х окна котрое нужно подвинуть
        dec  ax;
        cmp  [МЫШ_КООY2],ax;// Сравниваем с координатами мышки координату окна по Х
        JA  .ВЫYБОЛ       ;// Если координата мышки оказалася больше координаты окна
        JB  .ВЫYМЕН       ;// Если координата мышки оказалася Меньше координаты окна
        JMP .ВЫYДАЛЕЕ    ;

.ВЫYБОЛ:  ;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ВЫС     ;// Читаем локальную координату окна
        inc  ax           ;// и увеличиваем её
        mov  CX,КОД_ПАР_ВЫСО  ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР  ;// Элемент сет параметр
        JMP .ВЫYДАЛЕЕ    ;

.ВЫYМЕН:  ;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ВЫС     ;// Читаем локальную координату окна
        cmp  ax,1         ;// Ниже нудя нельзя
        jbe .ВЫYДАЛЕЕ    ;
        dec  ax           ;// и увеличиваем её
        mov  CX,КОД_ПАР_ВЫСО  ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР  ;// Элемент сет параметр
        JMP .ВЫYДАЛЕЕ    ;

.ВЫYДАЛЕЕ:
        JMP .ВЫХОД        ;




        ;}
.ОКРАЗ:;{ Изменение разммера окошка

        call ОКНО_АПР      ;// Читаем абсолютные координаты по Х окна котрое нужно подвинуть
        dec  ax;
        cmp  [МЫШ_КООX2],ax;// Сравниваем с координатами мышки координату окна по Х
        JA  .РАXBOL        ;// Если координата мышки оказалася больше координаты окна
        JB  .РАXMEN        ;// Если координата мышки оказалася Меньше координаты окна
        JMP .РАXДАЛЕЕ      ;

.РАXBOL:;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ШИР      ;// Читаем локальную координату окна
        inc  ax            ;// и увеличиваем её
        mov  CX,КОД_ПАР_ШИРИ   ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР   ;// Элемент сет параметр
        JMP .РАXДАЛЕЕ      ;

.РАXMEN: ;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ШИР      ;// Читаем локальную координату окна
        cmp  ax,1          ;// Ниже нудя нельзя
        jbe .РАXДАЛЕЕ
        dec  ax            ;// и увеличиваем её
        mov  CX,КОД_ПАР_ШИРИ   ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР   ;// Элемент сет параметр
        JMP .РАXДАЛЕЕ      ;

.РАXДАЛЕЕ:

        call ОКНО_АНИ      ;// Читаем абсолютные координаты по Х окна котрое нужно подвинуть
        dec ax;
        cmp  [МЫШ_КООY2],ax;// Сравниваем с координатами мышки координату окна по Х
        JA  .РАYБОЛ        ;// Если координата мышки оказалася больше координаты окна
        JB  .РАYМЕН        ;// Если координата мышки оказалася Меньше координаты окна
        JMP .ВЫХОД         ;

.РАYБОЛ:;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ВЫС      ;// Читаем локальную координату окна
        inc  ax            ;// и увеличиваем её
        mov  CX,КОД_ПАР_ВЫСО   ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР   ;// Элемент сет параметр
        JMP .ВЫХОД         ;

.РАYМЕН:;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll  ОКНО_ВЫС     ;// Читаем локальную координату окна
        cmp   ax,1         ;// Ниже нудя нельзя
        jbe  .ВЫХОД
        dec  ax            ;// и увеличиваем её
        mov  CX,КОД_ПАР_ВЫСО   ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР   ;// Элемент сет параметр
        JMP .ВЫХОД         ;
        ;}


.ВЫХОД:
        popad;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
        pushad;

        ;-------------------
        call МЫШКА_НАЖАТА  ;
        JZ  .ВЫХОД         ;// Если мышка не нажата перемещение не осуществляеться
        ;-------------------

        ;-------------------
        mov  ax,[МЫШ_ВЫДЕ1]; ПРоверяем наличае элемента по котрому была нажата кнопка прошлый раз
        test ax,ax         ;
        JZ  .ВЫХОД         ;
        mov  ax,[МЫШ_ВЫДЕ2]; ПРоверяем наличае элемента по котрому была нажата кнопка щас
        test ax,ax         ;
        JZ  .ВЫХОД         ;
        mov  ax,[МЫШ_ВЫДЕ1];// ПРоверяем что реч идет об одном и том же элементе что и в прошлый рас нажатия кнопки
        cmp  ax,[МЫШ_ВЫДЕ2];
        JNZ .ВЫХОД         ;     Готово осталося порядок навести
        ;-------------------

        mov DI,[МЫШ_ВЫДЕ2] ;// Проверяем что элемент являеться имиено окошком
        call ЭТО_ОКНО      ;
        JZ  .ВЫХОД         ;


        mov  ax,[МЫШ_ТИППЕ];// СМотрим тип перемещения
        cmp  ax,1          ;
        JZ  .ОКПЕР         ;// Просто перемещение окна
        cmp  ax,2          ;
        JZ  .ОКШИР         ;// Изменение ширины окна
        cmp  ax,3          ;
        JZ  .ОКВЫС         ;// Изменение ВЫСОТЫ окна
        cmp  ax,4          ;
        JZ  .ОКРАЗ         ;// Изменеине размера окна
        Jmp .ВЫХОД         ;

.ОКПЕР:;{ НЕпосредственно перемещение

        call ОКНО_АЛЕ       ;// Читаем абсолютные координаты по Х окна котрое нужно подвинуть
        add  ax,[МЫШ_СМЕЩX] ;
        cmp  [МЫШ_КООX2],ax ;// Сравниваем с координатами мышки координату окна по Х
        JA  .XБОЛ           ;// Если координата мышки оказалася больше координаты окна
        JB  .XМЕН           ;// Если координата мышки оказалася Меньше координаты окна
        JMP .ДАЛЕЕ          ;

.XБОЛ:  ;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ЛЕВ       ;// Читаем локальную координату окна
        inc  ax             ;// и увеличиваем её
        mov  CX,КОД_ПАР_ЛЕВО    ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР    ;// Устанавливаем значения параметра окна левый край
        JMP .ДАЛЕЕ          ;

.XМЕН:  ;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ЛЕВ       ;// Читаем локальную координату окна
        test ax,ax          ;// Ниже нудя нельзя
        jz  .ДАЛЕЕ          ;
        dec  ax             ;// и увеличиваем её
        mov  CX,КОД_ПАР_ЛЕВО    ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР    ;// Устанавлвиаем значение параметра окна
        JMP .ДАЛЕЕ          ;
.ДАЛЕЕ:
        call ОКНО_АВЕ       ;// Читаем абсолютные координаты по Х окна котрое нужно подвинуть
        add  ax,[МЫШ_СМЕЩY] ;
        cmp  [МЫШ_КООY2],ax ;// Сравниваем с координатами мышки координату окна по Х
        JA  .YБОЛ           ;// Если координата мышки оказалася больше координаты окна
        JB  .YМЕН           ;// Если координата мышки оказалася Меньше координаты окна
        JMP .ВЫХОД          ;

.YБОЛ:  ;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ВЕР   ;// Читаем локальную координату окна
        inc  ax         ;// и увеличиваем её
        mov  CX,КОД_ПАР_ВЕРХ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР;// Элемент сет параметр
        JMP .ВЫХОД      ;

.YМЕН:  ;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ВЕР    ;// Читаем локальную координату окна
        test ax,ax      ;// Ниже нудя нельзя
        jz  .ВЫХОД
        dec  ax         ;// и увеличиваем её
        mov  CX,КОД_ПАР_ВЕРХ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР;// Элемент сет параметр
        JMP .ВЫХОД      ;
        ;}
.ОКШИР:;{ изменение шинрины окна

         call ОКНО_АПР      ;// Читаем абсолютные координаты по Х окна котрое нужно подвинуть
         dec  ax;
         cmp  [МЫШ_КООX2],ax;// Сравниваем с координатами мышки координату окна по Х
         JA  .ПРXБОЛ        ;// Если координата мышки оказалася больше координаты окна
         JB  .ПРXМЕН        ;// Если координата мышки оказалася Меньше координаты окна
         JMP .ПРДАЛЕЕ       ;// Ох ё ничего себе навзвания )))

.ПРXБОЛ: ;// Если координата мышки оказалася больше двигаем окно по х к мышке
         CAll ОКНО_ШИР      ;// Читаем локальную координату окна
         inc  ax            ;// и увеличиваем её
         mov  CX,КОД_ПАР_ШИРИ   ;// и сохраняем значение
         call ЭЛЕ_УСТ_ПАР   ;// Элемент сет параметр
         JMP .ПРДАЛЕЕ       ;

.ПРXМЕН: ;// Если координата мышки оказалася больше двигаем окно по х к мышке
         CAll ОКНО_ШИР      ;// Читаем локальную координату окна
         cmp  ax,1          ;// Ниже нудя нельзя
         jbe .ПРДАЛЕЕ       ;
         dec  ax            ;// и увеличиваем её
         mov  CX,КОД_ПАР_ШИРИ   ;// и сохраняем значение
         call ЭЛЕ_УСТ_ПАР   ;// Элемент сет параметр
         JMP .ПРДАЛЕЕ       ;

.ПРДАЛЕЕ:
         JMP .ВЫХОД         ;




        ;}
.ОКВЫС:;{ изменение Высота окна

        call ОКНО_АНИ     ;// Читаем абсолютные координаты по Х окна котрое нужно подвинуть
        dec  ax;
        cmp  [МЫШ_КООY2],ax;// Сравниваем с координатами мышки координату окна по Х
        JA  .ВЫYБОЛ       ;// Если координата мышки оказалася больше координаты окна
        JB  .ВЫYМЕН       ;// Если координата мышки оказалася Меньше координаты окна
        JMP .ВЫYДАЛЕЕ    ;

.ВЫYБОЛ:  ;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ВЫС     ;// Читаем локальную координату окна
        inc  ax           ;// и увеличиваем её
        mov  CX,КОД_ПАР_ВЫСО  ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР  ;// Элемент сет параметр
        JMP .ВЫYДАЛЕЕ    ;

.ВЫYМЕН:  ;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ВЫС     ;// Читаем локальную координату окна
        cmp  ax,1         ;// Ниже нудя нельзя
        jbe .ВЫYДАЛЕЕ    ;
        dec  ax           ;// и увеличиваем её
        mov  CX,КОД_ПАР_ВЫСО  ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР  ;// Элемент сет параметр
        JMP .ВЫYДАЛЕЕ    ;

.ВЫYДАЛЕЕ:
        JMP .ВЫХОД        ;




        ;}
.ОКРАЗ:;{ Изменение разммера окошка

        call ОКНО_АПР      ;// Читаем абсолютные координаты по Х окна котрое нужно подвинуть
        dec  ax;
        cmp  [МЫШ_КООX2],ax;// Сравниваем с координатами мышки координату окна по Х
        JA  .РАXBOL        ;// Если координата мышки оказалася больше координаты окна
        JB  .РАXMEN        ;// Если координата мышки оказалася Меньше координаты окна
        JMP .РАXДАЛЕЕ      ;

.РАXBOL:;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ШИР      ;// Читаем локальную координату окна
        inc  ax            ;// и увеличиваем её
        mov  CX,КОД_ПАР_ШИРИ   ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР   ;// Элемент сет параметр
        JMP .РАXДАЛЕЕ      ;

.РАXMEN: ;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ШИР      ;// Читаем локальную координату окна
        cmp  ax,1          ;// Ниже нудя нельзя
        jbe .РАXДАЛЕЕ
        dec  ax            ;// и увеличиваем её
        mov  CX,КОД_ПАР_ШИРИ   ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР   ;// Элемент сет параметр
        JMP .РАXДАЛЕЕ      ;

.РАXДАЛЕЕ:

        call ОКНО_АНИ      ;// Читаем абсолютные координаты по Х окна котрое нужно подвинуть
        dec ax;
        cmp  [МЫШ_КООY2],ax;// Сравниваем с координатами мышки координату окна по Х
        JA  .РАYБОЛ        ;// Если координата мышки оказалася больше координаты окна
        JB  .РАYМЕН        ;// Если координата мышки оказалася Меньше координаты окна
        JMP .ВЫХОД         ;

.РАYБОЛ:;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ВЫС      ;// Читаем локальную координату окна
        inc  ax            ;// и увеличиваем её
        mov  CX,КОД_ПАР_ВЫСО   ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР   ;// Элемент сет параметр
        JMP .ВЫХОД         ;

.РАYМЕН:;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll  ОКНО_ВЫС     ;// Читаем локальную координату окна
        cmp   ax,1         ;// Ниже нудя нельзя
        jbe  .ВЫХОД
        dec  ax            ;// и увеличиваем её
        mov  CX,КОД_ПАР_ВЫСО   ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР   ;// Элемент сет параметр
        JMP .ВЫХОД         ;
        ;}


.ВЫХОД:
        popad;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
        pushad;

        ;-------------------
        call МЫШКА_НАЖАТА  ;
        JZ  .ВЫХОД         ;// Если мышка не нажата перемещение не осуществляеться
        ;-------------------

        ;-------------------
        mov  eax,[МЫШ_ВЫДЕ1]; ПРоверяем наличае элемента по котрому была нажата кнопка прошлый раз
        test ax,ax         ;
        JZ  .ВЫХОД         ;
        mov  eax,[МЫШ_ВЫДЕ2]; ПРоверяем наличае элемента по котрому была нажата кнопка щас
        test eax,eax         ;
        JZ  .ВЫХОД         ;
        mov  eax,[МЫШ_ВЫДЕ1];// ПРоверяем что реч идет об одном и том же элементе что и в прошлый рас нажатия кнопки
        cmp  eax,[МЫШ_ВЫДЕ2];
        JNZ .ВЫХОД         ;     Готово осталося порядок навести
        ;-------------------

        mov eDI,[МЫШ_ВЫДЕ2] ;// Проверяем что элемент являеться имиено окошком
        call ЭТО_ОКНО      ;
        JZ  .ВЫХОД         ;


        mov  Eax,[МЫШ_ТИППЕ];// СМотрим тип перемещения
        cmp  Eax,1          ;
        JZ  .ОКПЕР         ;// Просто перемещение окна
        cmp  Eax,2          ;
        JZ  .ОКШИР         ;// Изменение ширины окна
        cmp  Eax,3          ;
        JZ  .ОКВЫС         ;// Изменение ВЫСОТЫ окна
        cmp  Eax,4          ;
        JZ  .ОКРАЗ         ;// Изменеине размера окна
        Jmp .ВЫХОД         ;

.ОКПЕР:;{ НЕпосредственно перемещение

        push edx
        mov  edx,0;
        call ОКНО_АЛЕ       ;// Читаем абсолютные координаты по Х окна котрое нужно подвинуть
        add  eax,[МЫШ_СМЕЩX] ;
        mov  edx,[МЫШ_КООX2];
        sub  edx,eax;
        cmp  [МЫШ_КООX2],eax ;// Сравниваем с координатами мышки координату окна по Х
        JA  .XБОЛ           ;// Если координата мышки оказалася больше координаты окна
        JB  .XМЕН           ;// Если координата мышки оказалася Меньше координаты окна
        JMP .ДАЛЕЕ          ;

.XБОЛ:  ;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ЛЕВ       ;// Читаем локальную координату окна
        add   ax, dx        ;
        ;inc  eax             ;// и увеличиваем её
        mov  eCX,КОД_ПАР_ЛЕВО    ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР    ;// Устанавливаем значения параметра окна левый край
        JMP .ДАЛЕЕ          ;

.XМЕН:  ;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ЛЕВ       ;// Читаем локальную координату окна
        test eax,eax          ;// Ниже нудя нельзя
        jz  .ДАЛЕЕ          ;
        dec  eax             ;// и увеличиваем её
        mov  eCX,КОД_ПАР_ЛЕВО    ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР    ;// Устанавлвиаем значение параметра окна
        JMP .ДАЛЕЕ          ;
.ДАЛЕЕ:

        pop  edx;



        call ОКНО_АВЕ       ;// Читаем абсолютные координаты по Х окна котрое нужно подвинуть
        add  eax,[МЫШ_СМЕЩY] ;
        cmp  [МЫШ_КООY2],eax ;// Сравниваем с координатами мышки координату окна по Х
        JA  .YБОЛ           ;// Если координата мышки оказалася больше координаты окна
        JB  .YМЕН           ;// Если координата мышки оказалася Меньше координаты окна
        JMP .ВЫХОД          ;

.YБОЛ:  ;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ВЕР   ;// Читаем локальную координату окна
        inc  eax         ;// и увеличиваем её
        mov  CX,КОД_ПАР_ВЕРХ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР;// Элемент сет параметр
        JMP .ВЫХОД      ;

.YМЕН:  ;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ВЕР    ;// Читаем локальную координату окна
        test eax,eax      ;// Ниже нудя нельзя
        jz  .ВЫХОД
        dec  eax         ;// и увеличиваем её
        mov  eCX,КОД_ПАР_ВЕРХ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР;// Элемент сет параметр
        JMP .ВЫХОД      ;
        ;}
.ОКШИР:;{ изменение шинрины окна
         push  edx
         call ОКНО_АПР      ;// Читаем абсолютные координаты по Х окна котрое нужно подвинуть
         dec  eax;
         mov  edx,[МЫШ_КООX2];
         sub  edx,eax;
         cmp  [МЫШ_КООX2],eax;// Сравниваем с координатами мышки координату окна по Х
         JA  .ПРXБОЛ        ;// Если координата мышки оказалася больше координаты окна
         JB  .ПРXМЕН        ;// Если координата мышки оказалася Меньше координаты окна
         JMP .ПРДАЛЕЕ       ;// Ох ё ничего себе навзвания )))

.ПРXБОЛ: ;// Если координата мышки оказалася больше двигаем окно по х к мышке
         CAll ОКНО_ШИР      ;// Читаем локальную координату окна
         add  eax,edx       ;// и увеличиваем её
         mov  eCX,КОД_ПАР_ШИРИ   ;// и сохраняем значение
         call ЭЛЕ_УСТ_ПАР   ;// Элемент сет параметр
         JMP .ПРДАЛЕЕ       ;

.ПРXМЕН: ;// Если координата мышки оказалася больше двигаем окно по х к мышке
         CAll ОКНО_ШИР      ;// Читаем локальную координату окна
         cmp  eax,1          ;// Ниже нудя нельзя
         jbe .ПРДАЛЕЕ       ;
         inc  eax            ;// и увеличиваем её
         mov  CX,КОД_ПАР_ШИРИ   ;// и сохраняем значение
         call ЭЛЕ_УСТ_ПАР   ;// Элемент сет параметр
         JMP .ПРДАЛЕЕ       ;

.ПРДАЛЕЕ:pop  edx
         JMP .ВЫХОД         ;




        ;}
.ОКВЫС:;{ изменение Высота окна

        call ОКНО_АНИ     ;// Читаем абсолютные координаты по Х окна котрое нужно подвинуть
        dec  eax;
        cmp  [МЫШ_КООY2],eax;// Сравниваем с координатами мышки координату окна по Х
        JA  .ВЫYБОЛ       ;// Если координата мышки оказалася больше координаты окна
        JB  .ВЫYМЕН       ;// Если координата мышки оказалася Меньше координаты окна
        JMP .ВЫYДАЛЕЕ    ;

.ВЫYБОЛ:  ;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ВЫС     ;// Читаем локальную координату окна
        inc  eax           ;// и увеличиваем её
        mov  eCX,КОД_ПАР_ВЫСО  ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР  ;// Элемент сет параметр
        JMP .ВЫYДАЛЕЕ    ;

.ВЫYМЕН:  ;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ВЫС     ;// Читаем локальную координату окна
        cmp  eax,1         ;// Ниже нудя нельзя
        jbe .ВЫYДАЛЕЕ    ;
        dec  eax           ;// и увеличиваем её
        mov  CX,КОД_ПАР_ВЫСО  ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР  ;// Элемент сет параметр
        JMP .ВЫYДАЛЕЕ    ;

.ВЫYДАЛЕЕ:
        JMP .ВЫХОД        ;




        ;}
.ОКРАЗ:;{ Изменение разммера окошка

        call ОКНО_АПР      ;// Читаем абсолютные координаты по Х окна котрое нужно подвинуть
        dec  eax;
        cmp  [МЫШ_КООX2],eax;// Сравниваем с координатами мышки координату окна по Х
        JA  .РАXBOL        ;// Если координата мышки оказалася больше координаты окна
        JB  .РАXMEN        ;// Если координата мышки оказалася Меньше координаты окна
        JMP .РАXДАЛЕЕ      ;

.РАXBOL:;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ШИР      ;// Читаем локальную координату окна
        inc  eax            ;// и увеличиваем её
        mov  eCX,КОД_ПАР_ШИРИ   ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР   ;// Элемент сет параметр
        JMP .РАXДАЛЕЕ      ;

.РАXMEN: ;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ШИР      ;// Читаем локальную координату окна
        cmp  eax,1          ;// Ниже нудя нельзя
        jbe .РАXДАЛЕЕ
        dec  eax            ;// и увеличиваем её
        mov  eCX,КОД_ПАР_ШИРИ   ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР   ;// Элемент сет параметр
        JMP .РАXДАЛЕЕ      ;

.РАXДАЛЕЕ:

        call ОКНО_АНИ      ;// Читаем абсолютные координаты по Х окна котрое нужно подвинуть
        dec eax;
        cmp  [МЫШ_КООY2],eax;// Сравниваем с координатами мышки координату окна по Х
        JA  .РАYБОЛ        ;// Если координата мышки оказалася больше координаты окна
        JB  .РАYМЕН        ;// Если координата мышки оказалася Меньше координаты окна
        JMP .ВЫХОД         ;

.РАYБОЛ:;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll ОКНО_ВЫС      ;// Читаем локальную координату окна
        inc  eax            ;// и увеличиваем её
        mov  eCX,КОД_ПАР_ВЫСО   ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР   ;// Элемент сет параметр
        JMP .ВЫХОД         ;

.РАYМЕН:;// Если координата мышки оказалася больше двигаем окно по х к мышке
        CAll  ОКНО_ВЫС     ;// Читаем локальную координату окна
        cmp   eax,1         ;// Ниже нудя нельзя
        jbe  .ВЫХОД
        dec  eax            ;// и увеличиваем её
        mov  CX,КОД_ПАР_ВЫСО   ;// и сохраняем значение
        call ЭЛЕ_УСТ_ПАР   ;// Элемент сет параметр
        JMP .ВЫХОД         ;
        ;}


.ВЫХОД:
        popad;
        ret;
        END IF;}
;==============================================================================}
ОКНО_СОЗДАТЬ :;{ Создает окно с координами Cx-x Ch-Y Ширина Dl - Высота dh с именем SI внутри элемента DI Текст окна BX
IF  (ПЛАТФОРМА = ДОС)   ;{
        pushad;

        ;--------------------;
                               ; // В SI Имя окна
                               ; // В BX значение окна
        mov   al,5             ; // Создаем элемент с именем SI В Элементе DI  в AL тип элемента ТИП_ОКНО
        mov   ah,1             ; // Заполняем поле функция чтор означает что элемент участвует в поиске
        call  ЭЛЕ_СОЗДАТЬ      ; // Создаем элемент получаем его адрес в DI
        ;--------------------; // SI Теперь свободно для использования




        ;--------------------;
        mov   SI,ПАР_ТЕКС      ; // Создаем параметро Смещене текста по Y
        mov   AL,ТИП_СТРО      ; // Тип элемента текст то есть строка заканчивающаяся нулем
        mov   ah,1             ; // Участвует в поиске
                               ; // В BX Содержиться адрес текста окна
        call .ПАР_СОЗДАТЬ      ; //
        ;--------------------; // Регистр BX Свободен для использолвания


        ;-----------------------;
        mov   SI,ПАР_ЛЕВО       ; // Создаем параметро имя=ЛЕВО Координата окна по X
        mov   AL,ТИП_ЧИСЛ       ; // Указываем ТИп Число
        mov   ah,1              ; // Указываем что это функция
        xor   bx,bx             ;
        mov   Bl,Cl             ; // Указываем значение
        call .ПАР_СОЗДАТЬ       ; // Создание эелемнта внутри элемента DI
        ;-----------------------;
        mov   SI,ПАР_ВЕРХ       ; // Создаем параметро ВЕРХ
        mov   AL,ТИП_ЧИСЛ       ; //
        mov   ah,1              ; //
        xor   bx,bx             ;
        mov   Bl,Ch             ; //
        call .ПАР_СОЗДАТЬ       ;
        ;-----------------------
        mov   SI,ПАР_ШИРИ       ; //
        mov   AL,ТИП_ЧИСЛ       ; //
        mov   ah,1              ; //
        xor   bx,bx             ;
        mov   Bl,dl             ; //
        call .ПАР_СОЗДАТЬ       ;
        ;-----------------------
        mov   SI,ПАР_ВЫСО       ; //
        mov   AL,ТИП_ЧИСЛ       ; //
        mov   ah,1              ; //
        xor   bx,bx             ;
        mov   Bl,Dh             ; //
        call .ПАР_СОЗДАТЬ       ;
        ;--------------------;

        ; Смещение окна внутри текста мыже через окно видим только кусочек текста

        ;--------------------;
        mov   SI,ПАР_ТСМX       ; // Создаем параметро Смещене текста по X
        mov   AL,ТИП_ЧИСЛ       ; //
        mov   ah,1              ; //
        mov   Bx,0              ; //
        call .ПАР_СОЗДАТЬ       ; //
        ;-----------------------
        mov   SI,ПАР_ТСМY       ; // Создаем параметро Смещене текста по Y
        mov   AL,ТИП_ЧИСЛ       ; //
        mov   ah,1              ; //
        mov   Bx,0              ; //
        call .ПАР_СОЗДАТЬ       ; //
        ;--------------------;

        ; Координаты курсора внутри текста

        ;-----------------------
        mov   SI,ПАР_ТКУX       ; // Создаем параметро координаат курсора по X в окне
        mov   AL,ТИП_ЧИСЛ       ; //
        mov   ah,1              ; //
        mov   Bx,0              ; //
        call .ПАР_СОЗДАТЬ       ; //
        ;-----------------------
        mov   SI,ПАР_ТКУY       ; // Создаем параметро координаат курсора по Y в окне
        mov   AL,ТИП_ЧИСЛ       ; //
        mov   ah,1              ; //
        mov   Bx,0              ; //
        call .ПАР_СОЗДАТЬ       ; //
        ;---------------------

        ; Параметр Атрибуты Цвет Фона и текста окна и Цвет фона и цвет текста курсора

        ;--------------------;
        mov   SI,ПАР_АТРИ       ;// Атрибуты окна
        mov   AL,ТИП_ЧИСЛ       ;//
        mov   ah,1              ;//
        mov   Bx,01001111b      ;//
        call .ПАР_СОЗДАТЬ       ;//
        ;---------------------
        mov   SI,ПАР_АКУР       ;// Атрибуты курсора
        mov   AL,ТИП_ЧИСЛ       ;//
        mov   ah,1              ;//
        mov   Bx,01111111b      ;//
        call .ПАР_СОЗДАТЬ       ;//
        ;--------------------;

        ; Дополнительные параметры для работы с текстом

        ;------------------------------------------
        mov   SI,ПАР_ДПСТ       ;// Создаем параметро Длина последней строки до курсора по Y длина строки над курсором Количества символов в встроке с курсором
        mov   AL,ТИП_ЧИСЛ       ;// Указываем ТИп Параметр
        mov   ah,1              ;// Указываем что это функция
        mov   Bx,0              ;// Указываем значение
        call .ПАР_СОЗДАТЬ       ;
        ;------------------------------------------
        mov   SI,ПАР_КССК       ;// Создаем параметро Количества символов в встроке с курсором
        mov   AL,ТИП_ЧИСЛ       ;// Указываем ТИп Параметр
        mov   ah,1              ;// Указываем что это функция
        mov   Bx,0              ;// Указываем значение
        call .ПАР_СОЗДАТЬ       ;
        ;------------------------------------------
        mov   SI,ПАР_ПАВС       ;// Создаем параметро Предположительный адрес для вставки символа
        mov   AL,ТИП_ЧИСЛ       ;// Указываем ТИп Параметр
        mov   ah,1              ;// Указываем что это функция
        mov   Bx,0              ;// Указываем значение
        call .ПАР_СОЗДАТЬ       ;
        ;------------------------------------------
        mov   SI,ПАР_КОСТ       ;// Создаем параметро Количество строк в тексте
        mov   AL,ТИП_ЧИСЛ       ;// Указываем ТИп Параметр
        mov   ah,1              ;// Указываем что это функция
        mov   Bx,0              ;// Указываем значение
        call .ПАР_СОЗДАТЬ       ;
        ;-------------------------------------------

        ;----------------------;
        mov   SI,ПАР_ТИП       ; // Создаем параметро Смещене текста по Y
        mov   AL,ТИП_ЧИСЛ      ; // Тип элемента текст то есть строка заканчивающаяся нулем
        mov   ah,1             ; // Участвует в поиске
        mov   bx,1             ; // В BX Содержиться адрес текста окна
        call .ПАР_СОЗДАТЬ      ; //
        ;----------------------; // Регистр BX Свободен для использолвания


        ;----------------------;
        mov   SI,ПАР_БУФЕ      ; // Создаем параметро Последних нажатых символов
        mov   AL,ТИП_СТРО      ; // Тип элемента текст то есть строка заканчивающаяся нулем
        mov   ah,1             ; // Участвует в поиске
        Call  СОЗДАТЬ_СТРОКУ_BX_ДЛИНОЙ_16_БАЙТ;
        call .ПАР_СОЗДАТЬ      ; //
        ;----------------------; // Регистр BX Свободен для использолвания


        pop  si                ;
        Push di                ;
        popad                  ;
        ret                    ;

.ПАР_СОЗДАТЬ:; ДЛя создания параметров
             push di             ;
             call ЭЛЕ_СОЗДАТЬ    ;
             pop  di             ;
             ret                 ;
             END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
        pushad;

        ;--------------------;
                               ; // В SI Имя окна
                               ; // В BX значение окна
        mov   al,5             ; // Создаем элемент с именем SI В Элементе DI  в AL тип элемента ТИП_ОКНО
        mov   ah,1             ; // Заполняем поле функция чтор означает что элемент участвует в поиске
        call  ЭЛЕ_СОЗДАТЬ      ; // Создаем элемент получаем его адрес в DI
        ;--------------------; // SI Теперь свободно для использования




        ;--------------------;
        mov   SI,ПАР_ТЕКС      ; // Создаем параметро Смещене текста по Y
        mov   AL,ТИП_СТРО      ; // Тип элемента текст то есть строка заканчивающаяся нулем
        mov   ah,1             ; // Участвует в поиске
                               ; // В BX Содержиться адрес текста окна
        call .ПАР_СОЗДАТЬ      ; //
        ;--------------------; // Регистр BX Свободен для использолвания


        ;-----------------------;
        mov   SI,ПАР_ЛЕВО       ; // Создаем параметро имя=ЛЕВО Координата окна по X
        mov   AL,ТИП_ЧИСЛ       ; // Указываем ТИп Число
        mov   ah,1              ; // Указываем что это функция
        xor   bx,bx             ;
        mov   Bl,Cl             ; // Указываем значение
        call .ПАР_СОЗДАТЬ       ; // Создание эелемнта внутри элемента DI
        ;-----------------------;
        mov   SI,ПАР_ВЕРХ       ; // Создаем параметро ВЕРХ
        mov   AL,ТИП_ЧИСЛ       ; //
        mov   ah,1              ; //
        xor   bx,bx             ;
        mov   Bl,Ch             ; //
        call .ПАР_СОЗДАТЬ       ;
        ;-----------------------
        mov   SI,ПАР_ШИРИ       ; //
        mov   AL,ТИП_ЧИСЛ       ; //
        mov   ah,1              ; //
        xor   bx,bx             ;
        mov   Bl,dl             ; //
        call .ПАР_СОЗДАТЬ       ;
        ;-----------------------
        mov   SI,ПАР_ВЫСО       ; //
        mov   AL,ТИП_ЧИСЛ       ; //
        mov   ah,1              ; //
        xor   bx,bx             ;
        mov   Bl,Dh             ; //
        call .ПАР_СОЗДАТЬ       ;
        ;--------------------;

        ; Смещение окна внутри текста мыже через окно видим только кусочек текста

        ;--------------------;
        mov   SI,ПАР_ТСМX       ; // Создаем параметро Смещене текста по X
        mov   AL,ТИП_ЧИСЛ       ; //
        mov   ah,1              ; //
        mov   Bx,0              ; //
        call .ПАР_СОЗДАТЬ       ; //
        ;-----------------------
        mov   SI,ПАР_ТСМY       ; // Создаем параметро Смещене текста по Y
        mov   AL,ТИП_ЧИСЛ       ; //
        mov   ah,1              ; //
        mov   Bx,0              ; //
        call .ПАР_СОЗДАТЬ       ; //
        ;--------------------;

        ; Координаты курсора внутри текста

        ;-----------------------
        mov   SI,ПАР_ТКУX       ; // Создаем параметро координаат курсора по X в окне
        mov   AL,ТИП_ЧИСЛ       ; //
        mov   ah,1              ; //
        mov   Bx,0              ; //
        call .ПАР_СОЗДАТЬ       ; //
        ;-----------------------
        mov   SI,ПАР_ТКУY       ; // Создаем параметро координаат курсора по Y в окне
        mov   AL,ТИП_ЧИСЛ       ; //
        mov   ah,1              ; //
        mov   Bx,0              ; //
        call .ПАР_СОЗДАТЬ       ; //
        ;---------------------

        ; Параметр Атрибуты Цвет Фона и текста окна и Цвет фона и цвет текста курсора

        ;--------------------;
        mov   SI,ПАР_АТРИ       ;// Атрибуты окна
        mov   AL,ТИП_ЧИСЛ       ;//
        mov   ah,1              ;//
        mov   Bx,01001111b      ;//
        call .ПАР_СОЗДАТЬ       ;//
        ;---------------------
        mov   SI,ПАР_АКУР       ;// Атрибуты курсора
        mov   AL,ТИП_ЧИСЛ       ;//
        mov   ah,1              ;//
        mov   Bx,01111111b      ;//
        call .ПАР_СОЗДАТЬ       ;//
        ;--------------------;

        ; Дополнительные параметры для работы с текстом

        ;------------------------------------------
        mov   SI,ПАР_ДПСТ       ;// Создаем параметро Длина последней строки до курсора по Y длина строки над курсором Количества символов в встроке с курсором
        mov   AL,ТИП_ЧИСЛ       ;// Указываем ТИп Параметр
        mov   ah,1              ;// Указываем что это функция
        mov   Bx,0              ;// Указываем значение
        call .ПАР_СОЗДАТЬ       ;
        ;------------------------------------------
        mov   SI,ПАР_КССК       ;// Создаем параметро Количества символов в встроке с курсором
        mov   AL,ТИП_ЧИСЛ       ;// Указываем ТИп Параметр
        mov   ah,1              ;// Указываем что это функция
        mov   Bx,0              ;// Указываем значение
        call .ПАР_СОЗДАТЬ       ;
        ;------------------------------------------
        mov   SI,ПАР_ПАВС       ;// Создаем параметро Предположительный адрес для вставки символа
        mov   AL,ТИП_ЧИСЛ       ;// Указываем ТИп Параметр
        mov   ah,1              ;// Указываем что это функция
        mov   Bx,0              ;// Указываем значение
        call .ПАР_СОЗДАТЬ       ;
        ;------------------------------------------
        mov   SI,ПАР_КОСТ       ;// Создаем параметро Количество строк в тексте
        mov   AL,ТИП_ЧИСЛ       ;// Указываем ТИп Параметр
        mov   ah,1              ;// Указываем что это функция
        mov   Bx,0              ;// Указываем значение
        call .ПАР_СОЗДАТЬ       ;
        ;-------------------------------------------

        ;----------------------;
        mov   SI,ПАР_ТИП       ; // Создаем параметро Смещене текста по Y
        mov   AL,ТИП_ЧИСЛ      ; // Тип элемента текст то есть строка заканчивающаяся нулем
        mov   ah,1             ; // Участвует в поиске
        mov   bx,1             ; // В BX Содержиться адрес текста окна
        call .ПАР_СОЗДАТЬ      ; //
        ;----------------------; // Регистр BX Свободен для использолвания


        ;----------------------;
        mov   SI,ПАР_БУФЕ      ; // Создаем параметро Последних нажатых символов
        mov   AL,ТИП_СТРО      ; // Тип элемента текст то есть строка заканчивающаяся нулем
        mov   ah,1             ; // Участвует в поиске
        Call  СОЗДАТЬ_СТРОКУ_BX_ДЛИНОЙ_16_БАЙТ;
        call .ПАР_СОЗДАТЬ      ; //
        ;----------------------; // Регистр BX Свободен для использолвания


        pop  si                ;
        Push di                ;
        popad                  ;
        ret                    ;

.ПАР_СОЗДАТЬ:; ДЛя создания параметров
             push di             ;
             call ЭЛЕ_СОЗДАТЬ    ;
             pop  di             ;
             ret                 ;
             END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
        pushad;

        ;--------------------;
                               ; // В SI Имя окна
                               ; // В BX значение окна
        mov   al,5             ; // Создаем элемент с именем SI В Элементе DI  в AL тип элемента ТИП_ОКНО
        mov   ah,1             ; // Заполняем поле функция чтор означает что элемент участвует в поиске
        call  ЭЛЕ_СОЗДАТЬ      ; // Создаем элемент получаем его адрес в DI
        ;--------------------; // SI Теперь свободно для использования




        ;--------------------;
        mov   ESI,ПАР_ТЕКС      ; // Создаем параметро Смещене текста по Y
        mov   AL,ТИП_СТРО      ; // Тип элемента текст то есть строка заканчивающаяся нулем
        mov   ah,1             ; // Участвует в поиске
                               ; // В BX Содержиться адрес текста окна
        call .ПАР_СОЗДАТЬ      ; //
        ;--------------------; // Регистр BX Свободен для использолвания


        ;-----------------------;
        mov   ESI,ПАР_ЛЕВО       ; // Создаем параметро имя=ЛЕВО Координата окна по X
        mov   AL,ТИП_ЧИСЛ       ; // Указываем ТИп Число
        mov   ah,1              ; // Указываем что это функция
        xor   ebx,ebx             ;
        mov   Bl,Cl             ; // Указываем значение
        call .ПАР_СОЗДАТЬ       ; // Создание эелемнта внутри элемента DI
        ;-----------------------;
        mov   ESI,ПАР_ВЕРХ       ; // Создаем параметро ВЕРХ
        mov   AL,ТИП_ЧИСЛ       ; //
        mov   ah,1              ; //
        xor   Ebx,Ebx            ;
        mov   Bl,Ch             ; //
        call .ПАР_СОЗДАТЬ       ;
        ;-----------------------
        mov   eSI,ПАР_ШИРИ       ; //
        mov   AL,ТИП_ЧИСЛ       ; //
        mov   ah,1              ; //
        xor   ebx,ebx             ;
        mov   Bl,dl             ; //
        call .ПАР_СОЗДАТЬ       ;
        ;-----------------------
        mov   eSI,ПАР_ВЫСО       ; //
        mov   AL,ТИП_ЧИСЛ       ; //
        mov   ah,1              ; //
        xor   ebx,ebx             ;
        mov   Bl,Dh             ; //
        call .ПАР_СОЗДАТЬ       ;
        ;--------------------;

        ; Смещение окна внутри текста мыже через окно видим только кусочек текста

        ;--------------------;
        mov   eSI,ПАР_ТСМX       ; // Создаем параметро Смещене текста по X
        mov   AL,ТИП_ЧИСЛ       ; //
        mov   ah,1              ; //
        mov   eBx,0              ; //
        call .ПАР_СОЗДАТЬ       ; //
        ;-----------------------
        mov   eSI,ПАР_ТСМY       ; // Создаем параметро Смещене текста по Y
        mov   AL,ТИП_ЧИСЛ       ; //
        mov   ah,1              ; //
        mov   eBx,0              ; //
        call .ПАР_СОЗДАТЬ       ; //
        ;--------------------;

        ; Координаты курсора внутри текста

        ;-----------------------
        mov   eSI,ПАР_ТКУX       ; // Создаем параметро координаат курсора по X в окне
        mov   AL,ТИП_ЧИСЛ       ; //
        mov   ah,1              ; //
        mov   eBx,0              ; //
        call .ПАР_СОЗДАТЬ       ; //
        ;-----------------------
        mov   eSI,ПАР_ТКУY       ; // Создаем параметро координаат курсора по Y в окне
        mov   AL,ТИП_ЧИСЛ       ; //
        mov   ah,1              ; //
        mov   eBx,0              ; //
        call .ПАР_СОЗДАТЬ       ; //
        ;---------------------

        ; Параметр Атрибуты Цвет Фона и текста окна и Цвет фона и цвет текста курсора

        ;--------------------;
        mov   eSI,ПАР_АТРИ       ;// Атрибуты окна
        mov   AL,ТИП_ЧИСЛ       ;//
        mov   ah,1              ;//
        mov   eBx,01001111b      ;//
        call .ПАР_СОЗДАТЬ       ;//
        ;---------------------
        mov   eSI,ПАР_АКУР       ;// Атрибуты курсора
        mov   AL,ТИП_ЧИСЛ       ;//
        mov   ah,1              ;//
        mov   eBx,01111111b      ;//
        call .ПАР_СОЗДАТЬ       ;//
        ;--------------------;

        ; Дополнительные параметры для работы с текстом

        ;------------------------------------------
        mov   eSI,ПАР_ДПСТ       ;// Создаем параметро Длина последней строки до курсора по Y длина строки над курсором Количества символов в встроке с курсором
        mov   AL,ТИП_ЧИСЛ       ;// Указываем ТИп Параметр
        mov   ah,1              ;// Указываем что это функция
        mov   eBx,0              ;// Указываем значение
        call .ПАР_СОЗДАТЬ       ;
        ;------------------------------------------
        mov   eSI,ПАР_КССК       ;// Создаем параметро Количества символов в встроке с курсором
        mov   AL,ТИП_ЧИСЛ       ;// Указываем ТИп Параметр
        mov   ah,1              ;// Указываем что это функция
        mov   eBx,0              ;// Указываем значение
        call .ПАР_СОЗДАТЬ       ;
        ;------------------------------------------
        mov   eSI,ПАР_ПАВС       ;// Создаем параметро Предположительный адрес для вставки символа
        mov   AL,ТИП_ЧИСЛ       ;// Указываем ТИп Параметр
        mov   ah,1              ;// Указываем что это функция
        mov   eBx,0              ;// Указываем значение
        call .ПАР_СОЗДАТЬ       ;
        ;------------------------------------------
        mov   eSI,ПАР_КОСТ       ;// Создаем параметро Количество строк в тексте
        mov   AL,ТИП_ЧИСЛ       ;// Указываем ТИп Параметр
        mov   ah,1              ;// Указываем что это функция
        mov   eBx,0              ;// Указываем значение
        call .ПАР_СОЗДАТЬ       ;
        ;-------------------------------------------

        ;----------------------;
        mov   eSI,ПАР_ТИП       ; // Создаем параметро Смещене текста по Y
        mov   AL,ТИП_ЧИСЛ      ; // Тип элемента текст то есть строка заканчивающаяся нулем
        mov   ah,1             ; // Участвует в поиске
        mov   ebx,1             ; // В BX Содержиться адрес текста окна
        call .ПАР_СОЗДАТЬ      ; //
        ;----------------------; // Регистр BX Свободен для использолвания


        ;----------------------;
        mov   eSI,ПАР_БУФЕ      ; // Создаем параметро Последних нажатых символов
        mov   AL,ТИП_СТРО      ; // Тип элемента текст то есть строка заканчивающаяся нулем
        mov   ah,1             ; // Участвует в поиске
        Call  СОЗДАТЬ_СТРОКУ_BX_ДЛИНОЙ_16_БАЙТ;
        call .ПАР_СОЗДАТЬ      ; //
        ;----------------------; // Регистр BX Свободен для использолвания


        pop  esi                ;
        Push edi                ;
        popad                  ;
        ret                    ;

.ПАР_СОЗДАТЬ:; ДЛя создания параметров
             push edi             ;
             call ЭЛЕ_СОЗДАТЬ    ;
             pop  edi             ;
             ret                 ;
             END IF;}
;}


;==============================================================================}
;{ ФУНКЦИИ ДЛЯ РАБОТЫ C СЛОВАРЕМ                                        .

СЛО_В_КОД          :;{ ПРеаобразует слово DI в уникальный код DI если слова нету то присваевает ему код BX если BX=0 ТО генериует код сама
IF  (ПЛАТФОРМА = ДОС)   ;{
          pushad;
          call СОЗДАТЬ_СТРОКУ_SI_ДЛИНОЙ_16_БАЙТ ;
          call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI;
          call ПЕРЕВОДИТ_СТРОКУ_SI_В_БОЛЬШИЕ_БУКВЫ;

          mov  cx,0              ;
          mov  di,[СЛОВАРЬ]      ;

.ЦИКЛ:    mov  al,[di]           ;
          test al,al             ;
          jz  .ДОБАВИТЬ          ;
          call СРАВНИТЬ_СТРОКИ_SI_DI;
          JNZ .НАШОЛ             ;
          add  di,16             ;
          inc  cx                ;
          jmp .ЦИКЛ              ;

.ДОБАВИТЬ:
          mov  ax,cx;
          mov  dx,si             ;
          mov  cx,di             ;
          call ЗАПИСАТЬ_СТРОКУ_DX_В_СТРОКУ_CX;
          mov  cx,ax;
          add  di,14             ;
          test bx,bx             ;
          jnz .ЗАПКОД            ;
          mov [di],cx            ;
          jmp .ВЫХОД             ;
.ЗАПКОД:  mov [di],bx            ;
          mov  cx,bx             ;
          jmp .ВЫХОД             ;
.НАШОЛ:
          add  di,14             ;
          mov  cx,[di]           ;
.ВЫХОД:
          mov  di,si;
          call УДАЛИТЬ_СТРОКУ_DI;
          pop  si;
          push cx;
          popad;
          ret
          END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
          pushad;
          call СОЗДАТЬ_СТРОКУ_SI_ДЛИНОЙ_16_БАЙТ ;
          call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI;
          call ПЕРЕВОДИТ_СТРОКУ_SI_В_БОЛЬШИЕ_БУКВЫ;

          mov  cx,0              ;
          mov  di,[СЛОВАРЬ]      ;

.ЦИКЛ:    mov  al,[di]           ;
          test al,al             ;
          jz  .ДОБАВИТЬ          ;
          call СРАВНИТЬ_СТРОКИ_SI_DI;
          JNZ .НАШОЛ             ;
          add  di,16             ;
          inc  cx                ;
          jmp .ЦИКЛ              ;

.ДОБАВИТЬ:
          mov  ax,cx;
          mov  dx,si             ;
          mov  cx,di             ;
          call ЗАПИСАТЬ_СТРОКУ_DX_В_СТРОКУ_CX;
          mov  cx,ax;
          add  di,14             ;
          test bx,bx             ;
          jnz .ЗАПКОД            ;
          mov [di],cx            ;
          jmp .ВЫХОД             ;
.ЗАПКОД:  mov [di],bx            ;
          mov  cx,bx             ;
          jmp .ВЫХОД             ;
.НАШОЛ:
          add  di,14             ;
          mov  cx,[di]           ;
.ВЫХОД:
          mov  di,si;
          call УДАЛИТЬ_СТРОКУ_DI;
          pop  si;
          push cx;
          popad;
          ret
          END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
          pushad;
          call СОЗДАТЬ_СТРОКУ_SI_ДЛИНОЙ_16_БАЙТ ;
          call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI;
          call ПЕРЕВОДИТ_СТРОКУ_SI_В_БОЛЬШИЕ_БУКВЫ;

          mov  Ecx,0              ;
          mov  Edi,[СЛОВАРЬ]      ;

.ЦИКЛ:    mov  al,[Edi]           ;
          test al,al             ;
          jz  .ДОБАВИТЬ          ;
          call СРАВНИТЬ_СТРОКИ_SI_DI;
          JNZ .НАШОЛ             ;
          add  edi,16             ;
          inc  ecx                ;
          jmp .ЦИКЛ              ;

.ДОБАВИТЬ:
          mov  eax,ecx;
          mov  edx,esi             ;
          mov  ecx,edi             ;
          call ЗАПИСАТЬ_СТРОКУ_DX_В_СТРОКУ_CX;
          mov  ecx,eax;
          add  edi,14             ;
          test ebx,ebx             ;
          jnz .ЗАПКОД            ;
          mov [edi],cx            ;
          jmp .ВЫХОД             ;
.ЗАПКОД:  mov [edi],bx            ;
          mov  ecx,ebx             ;
          jmp .ВЫХОД             ;
.НАШОЛ:
          add  edi,14             ;
          mov  cx,[edi]           ;
.ВЫХОД:
          mov  edi,esi;
          call УДАЛИТЬ_СТРОКУ_DI;
          pop  esi;
          push ecx;
          popad;
          ret
          END IF;}
;==============================================================================}
СЛО_В_КОДCX        :;{ ПРеаобразует слово CX в уникальный код CX
IF  (ПЛАТФОРМА = ДОС)   ;{
           push di          ;
           push bx          ;
           mov  bx,0        ;
           mov  di,cx       ;
           call СЛО_В_КОД   ;
           mov  cx,di       ;
           pop  bx          ;
           pop  di          ;
           ret              ;
           END iF           ;}
IF  (ПЛАТФОРМА = T16)   ;{
           push di          ;
           push bx          ;
           mov  bx,0        ;
           mov  di,cx       ;
           call СЛО_В_КОД   ;
           mov  cx,di       ;
           pop  bx          ;
           pop  di          ;
           ret              ;
           END iF           ;}
IF  (ПЛАТФОРМА = T32)   ;{
           push Edi          ;
           push Ebx          ;
           mov  Ebx,0        ;
           mov  Edi,Ecx       ;
           call СЛО_В_КОД   ;
           mov  Ecx,Edi       ;
           pop  Ebx          ;
           pop  Edi          ;
           ret              ;
           END iF           ;}
;==============================================================================}
ДОБАВИТЬ_СЛОВО     :;{ Добавляет слово SI назначает код CX возвращает длину добавленого слова в DX
IF  (ПЛАТФОРМА = ДОС)   ;{
           push di;
           push bx;
           mov  di,si;
           mov  bx,cx;
           call СЛО_В_КОД;
           mov  di,si;
           call ВОЗАРАЩАЕТ_В_DI_ДЛИНУ_СТРОКИ_DI;
           mov  dx,di;
           pop  bx;
           pop  di;
           ret;
           END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
           push di;
           push bx;
           mov  di,si;
           mov  bx,cx;
           call СЛО_В_КОД;
           mov  di,si;
           call ВОЗАРАЩАЕТ_В_DI_ДЛИНУ_СТРОКИ_DI;
           mov  dx,di;
           pop  bx;
           pop  di;
           ret;
           END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
           push Edi;
           push Ebx;
           mov  Edi,Esi;
           mov  Ebx,Ecx;
           call СЛО_В_КОД;
           mov  Edi,Esi;
           call ВОЗАРАЩАЕТ_В_DI_ДЛИНУ_СТРОКИ_DI;
           mov  Edx,Edi;
           pop  Ebx;
           pop  Edi;
           ret;
           END IF;}
;==============================================================================}
ПОДГОТОВКА_СЛОВАРЯ :;{ подготавливает словарь для работы
IF  (ПЛАТФОРМА = ДОС)   ;{
                   pushad;
                   mov  DI,4096        ;// Указываем размер запрашиваемого участка памяти для буфера экрана
                   call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;// Выделяем участок
                   mov [СЛОВАРЬ],di;

                   mov   si,СПИСОК_СЛОВ;
                   mov   cx,1;
.ЦИКЛ:
                   mov   al,[si];
                   test  al,al  ;
                   jz   .КЦИКЛ  ;
                   Call  ДОБАВИТЬ_СЛОВО ; // Добавляет слово SI в словарь назначает номер CX в DX возвращает длину добавленого слова
                   add   si,dx  ;
                   inc   si;
                   mov   al,[si];
                   cmp   al,1   ;
                   jnz  .ДАЛЕЕ ;
                   inc   cx     ;
                   inc   si     ;
.ДАЛЕЕ:
                   jmp   .ЦИКЛ  ;
.КЦИКЛ:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                   pushad;
                   mov  DI,4096        ;// Указываем размер запрашиваемого участка памяти для буфера экрана
                   call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;// Выделяем участок
                   mov [СЛОВАРЬ],di;

                   mov   si,СПИСОК_СЛОВ;
                   mov   cx,1;
.ЦИКЛ:
                   mov   al,[si];
                   test  al,al  ;
                   jz   .КЦИКЛ  ;
                   Call  ДОБАВИТЬ_СЛОВО ; // Добавляет слово SI в словарь назначает номер CX в DX возвращает длину добавленого слова
                   add   si,dx  ;
                   inc   si;
                   mov   al,[si];
                   cmp   al,1   ;
                   jnz  .ДАЛЕЕ ;
                   inc   cx     ;
                   inc   si     ;
.ДАЛЕЕ:
                   jmp   .ЦИКЛ  ;
.КЦИКЛ:
                   popad;
                   ret;
                   END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                   pushad;
                   mov  EDI,4096        ;// Указываем размер запрашиваемого участка памяти для буфера экрана
                   call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;// Выделяем участок
                   mov [СЛОВАРЬ],Edi;

                   mov   Esi,СПИСОК_СЛОВ;
                   mov   Ecx,1;
.ЦИКЛ:
                   mov   al,[Esi];
                   test  al,al  ;
                   jz   .КЦИКЛ  ;
                   Call  ДОБАВИТЬ_СЛОВО ; // Добавляет слово SI в словарь назначает номер CX в DX возвращает длину добавленого слова
                   add   Esi,Edx  ;
                   inc   Esi;
                   mov   al,[Esi];
                   cmp   al,1   ;
                   jnz  .ДАЛЕЕ ;
                   inc   Ecx     ;
                   inc   Esi     ;
.ДАЛЕЕ:
                   jmp   .ЦИКЛ  ;
.КЦИКЛ:
                   popad;
                   ret;
                   END IF;}
;==============================================================================}
;Переменные {
IF  (ПЛАТФОРМА = ДОС)   ;{
СЛОВАРЬ: DW 0 ; // Адрес участка в памяти выделеного под словарь
END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
СЛОВАРЬ: DW 0 ; // Адрес участка в памяти выделеного под словарь
END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
СЛОВАРЬ: DD 0 ; // Адрес участка в памяти выделеного под словарь
END IF;}
;}
;==============================================================================}
;{ ПЕРЕМЕННЫЕ                                                           .

МЫШ_ВЫДЕ1: DD 0 ;// Адрес елемнта по котрому нажата предыдущий раз мышка
МЫШ_ВЫДЕ2: DD 0 ;// Адрес елемнта по котрому нажата последний раз кнопка
МЫШ_СМЕЩX: DD 0 ;// Координаты смещения мышки внтри окна принажатии абсолютная коордиана окна + смещение = кооордината нажатия мышки
МЫШ_СМЕЩY: DD 0 ;// Координаты смещения внтри окна по  y
МЫШ_ТИППЕ: DD 0 ;// 1 пермещение 2 изменение ширины 3 изменение высоты и 4 изменение размера окошка
ЭКР_ЦВЕТ : DD 0 ;// Цветовая гамма экрана
РАС_КЛАВ : DD 0 ;// Раскладка клавиатуры

КОРНЕВОЙ_ЭЛЕМЕНТ:;{
IF  (ПЛАТФОРМА = ДОС)   ;{
mov di,[КОР_ЭЛЕМ];
ret;
END IF;
;==============================================================================}
IF  (ПЛАТФОРМА = T16)   ;{
mov di,[КОР_ЭЛЕМ];
ret;
END IF;
;==============================================================================}
IF  (ПЛАТФОРМА = T32)   ;{
mov edi,[КОР_ЭЛЕМ];
ret;
END IF;
;==============================================================================}
;}
КОР_ЭЛЕМ :;{ Адрес корневого элемента
IF  (ПЛАТФОРМА = ДОС)   ;{
DW 0
END IF;
;==============================================================================}
IF  (ПЛАТФОРМА = T16)   ;{
DW 0
END IF;
;==============================================================================}
IF  (ПЛАТФОРМА = T32)   ;{
DD 0
END IF;
;==============================================================================}
;}


СПИСОК_СЛОВ        :
КОД_ТЕК_СЛОЖЕНИЕ   : DB '+'         ,0,'ПРИБАВИТЬ'  ,0,1;
КОД_ТЕК_ВЫЧИТАНИЕ  : DB '-'         ,0,'ОТНЯТЬ'     ,0,1;
КОД_ТЕК_УМНОЖЕНИЕ  : DB '*'         ,0,'УМНОЖИТЬ'   ,0,1;
КОД_ТЕК_ДЕЛЕНИЕ    : DB '/'         ,0,'ПОДЕЛИТЬ'   ,0,1;
КОД_ТЕК_ОСТАТОК    : DB 'MOD'       ,0,'ОСТАТОК'    ,0,1;
КОД_ТЕК_ПРИСВОЕНИЕ : DB ':='        ,0,'ПРИСВОИТЬ'  ,0,1;
КОД_ТЕК_РАВНО      : DB '='         ,0,'РАВНО'      ,0,'=='       ,0,1;
КОД_ТЕК_НЕРАВНО    : DB '<>'        ,0,'!='         ,0,1;
КОД_ТЕК_БОЛЬШЕ     : DB '>'         ,0,'БОЛЬШЕ'     ,0,1;
КОД_ТЕК_МЕНЬШЕ     : DB '<'         ,0,'МЕНЬШЕ'      ,0,1;
КОД_ТЕК_МЕНРА      : DB '<='        ,0,1;
КОД_ТЕК_БОЛРА      : DB '>='        ,0,1;
КОД_ТЕК_ЛОГИ       : DB 'И'         ,0,'AND'        ,0,'&&'       ,0,1;
КОД_ТЕК_ЛОГИЛИ     : DB 'ИЛИ'       ,0,'OR'         ,0,'||'       ,0,1;
КОД_ТЕК_ОСКОБ      : DB '('         ,0,1;
КОД_ТЕК_ЗСКОБ      : DB ')'         ,0,1;
КОД_ТЕК_НАЧАЛО     : DB 'НАЧАЛО'    ,0,'BEGIN'      ,0,'{'        ,0,1;
КОД_ТЕК_КОНЕЦ      : DB 'КОНЕЦ'     ,0,'END'        ,0,'}'        ,0,1;
; Внимание вложеные скобочки сворачиваються при просмотре сиходника )
; Все что выше в них не вкладываються скобки котрые идут следющими в тексте
КОД_ТЕК_ЕСЛИ       : DB 'ЕСЛИ'      ,0,'IF'         ,0,1;
КОД_ТЕК_ПОКА       : DB 'ПОКА'      ,0,'WHILE'      ,0,1;
КОД_ТЕК_ВЫВОД      : DB 'ВЫВОД'     ,0,'PRINT'      ,0,'WRITE'    ,0,1;
КОД_ТЕК_ВЫВОДСТ    : DB 'ВЫВОДСТ'   ,0,'PRINTLN'    ,0,'WRITELN'  ,0,1;
КОД_ТЕК_ЦИКЛ       : DB 'ЦИКЛ'      ,0,'ПОВТОРЯТЬ'  ,0,'FOR'      ,0,1;
КОД_ТЕК_ВВОД       : DB 'ВВОД'      ,0,'INPUT'      ,0,'READ'     ,0,1;
КОД_ТЕК_ВВОДСТ     : DB 'ВВОДСТ'    ,0,'INPUTLN'    ,0,'READLN'   ,0,1;

КОД_ТЕК_ЧПОРТ      : DB 'ЧПОРТ'     ,0,'IN'         ,0,1;
КОД_ТЕК_ЧПАМЯТЬ    : DB 'ЧПАМЯТЬ'   ,0,'PEEK'       ,0,1;

КОД_ТЕК_ЗПОРТ      : DB 'ЗПОРТ'     ,0,'OUT'        ,0,1;
КОД_ТЕК_ЗПАМЯТЬ    : DB 'ЗПАМЯТЬ'   ,0,'POKE'       ,0,1;

КОД_ТЕК_ВЗЯТЬ      : DB 'ВЗЯТЬ'     ,0,'GET'        ,0,1;
ТЕК_ОСВОБОДИТЬ     : db 'ОСВОБОДИТЬ',0,'FREE'       ,0,1; // Освободить
ТЕК_РОДИТЕЛЬ       : db 'РОДИТЕЛЬ'  ,0,'PARENT'     ,0,1; // Родитель


КОД_ТЕК_РЕЗЕРВ1    : DB 'УДА_СТР'   ,0,'РЕЗЕРВ11'   ,0,1;
КОД_ТЕК_РЕЗЕРВ2    : DB 'РЕЗЕРВ2'   ,0,'РЕЗЕРВ12'   ,0,1;
КОД_ТЕК_РЕЗЕРВ3    : DB 'РЕЗЕРВ3'   ,0,'РЕЗЕРВ13'   ,0,1;
КОД_ТЕК_РЕЗЕРВ4    : DB 'РЕЗЕРВ4'   ,0,'РЕЗЕРВ14'   ,0,1;
КОД_ТЕК_РЕЗЕРВ5    : DB 'РЕЗЕРВ5'   ,0,'РЕЗЕРВ15'   ,0,1;
КОД_ТЕК_РЕЗЕРВ6    : DB 'РЕЗЕРВ6'   ,0,'РЕЗЕРВ16'   ,0,1;
КОД_ТЕК_РЕЗЕРВ7    : DB 'РЕЗЕРВ7'   ,0,'РЕЗЕРВ17'   ,0,1;
КОД_ТЕК_РАЗРЕШИТЬ  : DB 'РАЗРЕШИТЬ' ,0,'РЕЗЕРВ18'   ,0,1;
КОД_ТЕК_ЗАПРЕТИТЬ  : DB 'ЗАПРЕТИТЬ' ,0,'РЕЗЕРВ19'   ,0,1;


КОД_ТЕК_ПРАВДА     : DB 'ПРАВДА'    ,0,'TRUE'       ,0,1;
КОД_ТЕК_ЛОЖ        : DB 'ЛОЖ'       ,0,'FALSE'      ,0,1;
ПАР_ЛЕВО           : db 'ПАР_ЛЕВО'  ,0,'ЛЕВО'       ,0,1; // Left координата по X отображемого окна
ПАР_ВЕРХ           : db 'ПАР_ВЕРХ'  ,0,'ВЕРХ'       ,0,1; // Top координата по Y отображемого окна
ПАР_ШИРИ           : db 'ПАР_ШИРИ'  ,0,'ШИРИНА'     ,0,1; // Width Ширина отображемого окна
ПАР_ВЫСО           : db 'ПАР_ВЫСО'  ,0,'ВЫСОТА'     ,0,1; // HEight Высота  отображемого окна
ПАР_АТРИ           : db 'ПАР_АТРИ'  ,0,'ФОН'        ,0,1; // Атрибуты окна
ПАР_АКУР           : db 'ПАР_АКУР'  ,0,'КУРСОР'     ,0,1; // Атрибуты Курсора
ПАР_ТСМX           : db 'ПАР_ТСМX'  ,0,'СМЕЩЕНИЕ_X' ,0,1; // Смещение видимого текста внтури текста по X
ПАР_ТСМY           : db 'ПАР_ТСМY'  ,0,'СМЕЩЕНИЕ_Y' ,0,1; // Смещение видимого текста внтури текста по Y
ПАР_ТКУX           : db 'ПАР_ТКУX'  ,0,'КУРСОР_X'   ,0,1; // координаты  текстового курсора по X
ПАР_ТКУY           : db 'ПАР_ТКУY'  ,0,'КУРСОР_Y'   ,0,1; // координаты  текстового курсора по Y
ПАР_ТЕКС           : db 'ПАР_ТЕКС'  ,0,'ТЕКСТ'      ,0,1; // Текст окна для редактирования
ПАР_КССК           : db 'ПАР_КССК'  ,0,1                ; // Количество символов  в строке с курсором
ПАР_КОСТ           : db 'ПАР_КОСТ'  ,0,'КОЛ_СТРОК'  ,0,1; // Реальное количество строк в тексте окна
ПАР_ПАВС           : db 'ПАР_ПАВС'  ,0,1                ; // Предположительный адрес для вставки символа
ПАР_ДПСТ           : db 'ПАР_ДПСТ'  ,0,1                ; // Длина предыдущей строки до курсора

ПАР_НАЖА           : db 'ПАР_НАЖА'  ,0,1                ; // Так называеться событие наж кнопки мыш
ПАР_РЕДА           : db 'ПАР_РЕДА'  ,0,1                ; // Разрешает или запре Редакт текст вну
ПАР_РАМК           : db 'ПАР_РАМК'  ,0,1                ; // Рисовать рамку или не рисовать
ПАР_ВИДИ           : db 'ПАР_ВИДИ'  ,0,1                ; // Видимость элемента
ПАР_ПЕРЕ           : db 'ПАР_ПЕРЕ'  ,0,1                ; // Разрешает или запрещает перемесчение окна
ПАР_БУФЕ           : db 'ПАР_БУФЕ'  ,0,1                ; // Буфер последних нажатых символов

МОНИТОР            : db 'МОНИТОР'   ,0,1                ; // Окно монитора
КОД_ТЕК_НА         : db 'НА'        ,0,1                ; // Пустое слово
ТЕК_ПОМОЩЬ         : db 'ПОМОЩЬ'    ,0,1                ; // ПОМОЩЬ
ПАР_ТИП            : db 'ТИП'       ,0,0                ; // параметр ТИП

NOM=1;
КОД_КОМ_СЛОЖЕНИЕ   = 1 ;
КОД_КОМ_ВЫЧИТАНИЕ  = 2 ;
КОД_КОМ_УМНОЖЕНИЕ  = 3 ;
КОД_КОМ_ДЕЛЕНИЕ    = 4 ;
КОД_КОМ_ОСТАТОК    = 5 ;
КОД_КОМ_ПРИСВОЕНИЕ = 6 ;
КОД_КОМ_РАВНО      = 7 ;
КОД_КОМ_НЕРАВНО    = 8 ;
КОД_КОМ_БОЛЬШЕ     = 9 ;
КОД_КОМ_МЕНЬШЕ     = 10;
КОД_КОМ_МЕНРА      = 11;
КОД_КОМ_БОЛРА      = 12;
КОД_КОМ_ЛОГИ       = 13;
КОД_КОМ_ЛОГИЛИ     = 14;
КОД_КОМ_ОСКОБКА    = 15; // Внимание скобки должны идти подряд
КОД_КОМ_ЗСКОБКА    = 16; // Внимание скобки должны идти подряд
КОД_КОМ_НАЧАЛО     = 17; // Внимание скобки должны идти подряд
КОД_КОМ_КОНЕЦ      = 18; // Внимание скобки должны идти подряд
КОД_КОМ_ЕСЛИ       = 19;
КОД_КОМ_ПОКА       = 20;
КОД_КОМ_ВЫВОД      = 21;
КОД_КОМ_ВЫВОДСТ    = 22;
КОД_КОМ_ЦИКЛ       = 23;
КОД_КОМ_ВВОД       = 24;
КОД_КОМ_ВВОДСТ     = 25;

КОД_КОМ_ЧПОРТ      = 26;
КОД_КОМ_ЧПАМЯТЬ    = 27;

КОД_КОМ_ЗПОРТ      = 28;
КОД_КОМ_ЗПАМЯТЬ    = 29;

КОД_КОМ_ВЗЯТЬ      = 30;
КОД_ОСВОБОДИТЬ     = 31;
КОД_РОДИТЕЛЬ       = 32;


КОД_КОМ_РЕЗЕРВ1    = 33;
КОД_КОМ_РЕЗЕРВ2    = 34;
КОД_КОМ_РЕЗЕРВ3    = 35;
КОД_КОМ_РЕЗЕРВ4    = 36;
КОД_КОМ_РЕЗЕРВ5    = 37;
КОД_КОМ_РЕЗЕРВ6    = 38;
КОД_КОМ_РЕЗЕРВ7    = 39;
КОД_КОМ_РАЗРЕШИТЬ  = 40;
КОД_КОМ_ЗАПРЕТИТЬ  = 41;


КОД_КОМ_ПРАВДА     = 42;
КОД_КОМ_ЛОЖ        = 43;

КОД_ПАР_ЛЕВО       = 44; // Вот блин вот от сюда
КОД_ПАР_ВЕРХ       = 45;
КОД_ПАР_ШИРИ       = 46;
КОД_ПАР_ВЫСО       = 47;
КОД_ПАР_АТРИ       = 48;
КОД_ПАР_АКУР       = 49;
КОД_ПАР_ТСМX       = 50;
КОД_ПАР_ТСМY       = 51;
КОД_ПАР_ТКУX       = 52;
КОД_ПАР_ТКУY       = 53;
КОД_ПАР_ТЕКС       = 54;
КОД_ПАР_КССК       = 55;
КОД_ПАР_КОСТ       = 56;
КОД_ПАР_ПАВС       = 57;
КОД_ПАР_ДПСТ       = 58;
КОД_ПАР_НАЖА       = 59;
КОД_ПАР_РЕДА       = 60;
КОД_ПАР_РАМК       = 61;
КОД_ПАР_ВИДИ       = 62;
КОД_ПАР_ПЕРЕ       = 63;
КОД_ПАР_БУФЕ       = 64;
КОД_ОКН_МОНИТОР    = 65;
КОД_КОМ_НА         = 66;
КОД_ПОМОЩЬ         = 67;
КОД_ТИП            = 68;

;Все что выше в них не вкладываються скобки котрые идут следющими в тексте

МАКС_РЕЗЕРВ_СЛОВО  = 18;

;==============================================================================}
;{ СТРУКТУРА ЭЛЕМЕНТА                                                   .
IF  (ПЛАТФОРМА = ДОС)   ;{
ЭЛ_ТИП = 0 ;// ТИп элементы
ЭЛ_ФУН = 1 ;// Если это функция Участвует ли в поиске
ЭЛ_ИМЯ = 2 ;// Название элемента
ЭЛ_ЗНА = 4 ;// Адрес значения
ЭЛ_КОД = 6 ;// Код  имени элемента
ЭЛ_РОД = 8 ;// Адрес родительского элемента
ЭЛ_ПРЕ = 10;// Адрес предыдущего элемента
ЭЛ_СЛЕ = 12;// Адрес Следующего элемента
ЭЛ_ВЛО = 14;// Адрес первого элемента вложеного списка
END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
ЭЛ_ТИП = 0 ;// ТИп элементы
ЭЛ_ФУН = 1 ;// Если это функция Участвует ли в поиске
ЭЛ_ИМЯ = 2 ;// Название элемента
ЭЛ_ЗНА = 4 ;// Адрес значения
ЭЛ_КОД = 6 ;// Код  имени элемента
ЭЛ_РОД = 8 ;// Адрес родительского элемента
ЭЛ_ПРЕ = 10;// Адрес предыдущего элемента
ЭЛ_СЛЕ = 12;// Адрес Следующего элемента
ЭЛ_ВЛО = 14;// Адрес первого элемента вложеного списка
END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
ЭЛ_ТИП = 0 ;// ТИп элементы
ЭЛ_ФУН = 1 ;// Если это функция Участвует ли в поиске
ЭЛ_ИМЯ = 2 ;// Название элемента
ЭЛ_ЗНА = 4 ;// Адрес значения
ЭЛ_КОД = 8 ;// Код  имени элемента
ЭЛ_РОД = 12 ;// Адрес родительского элемента
ЭЛ_ПРЕ = 16;// Адрес предыдущего элемента
ЭЛ_СЛЕ = 20;// Адрес Следующего элемента
ЭЛ_ВЛО = 24;// Адрес первого элемента вложеного списка
END IF;}
;==============================================================================}
;{ ТИПЫ ЭЛЕМЕНТОВ                                                       .

                                 ; Типы элемнтов
   ТИП_ПУСТ  = 0                 ; // ТИП Корневой элемент всего 1 во всей системе
   ТИП_ЧИСЛ  = 1                 ; // Число 2 байтовое
   ТИП_СТРО  = 2                 ; // Адрес короткой строки заканчиваеющейся нулем
   ТИП_КАВЫ  = 3                 ; // Адрес строки в кавычках

   ЧИС_ЧИС = ТИП_ЧИСЛ*10+ТИП_ЧИСЛ;
   ЧИС_СТР = ТИП_ЧИСЛ*10+ТИП_СТРО;
   СТР_ЧИС = ТИП_СТРО*10+ТИП_ЧИСЛ;
   СТР_СТР = ТИП_СТРО*10+ТИП_СТРО;


   КОМ_ЧИС_ЧИС = ТИП_ЧИСЛ*10+ТИП_ЧИСЛ;
   КОМ_ЧИС_СТР = ТИП_ЧИСЛ*10+ТИП_СТРО;
   КОМ_ЧИС_КАВ = ТИП_ЧИСЛ*10+ТИП_КАВЫ;

   КОМ_СТР_ЧИС = ТИП_СТРО*10+ТИП_ЧИСЛ;
   КОМ_СТР_СТР = ТИП_СТРО*10+ТИП_СТРО;
   КОМ_СТР_КАВ = ТИП_СТРО*10+ТИП_КАВЫ;

   КОМ_КАВ_ЧИС = ТИП_КАВЫ*10+ТИП_ЧИСЛ;
   КОМ_КАВ_СТР = ТИП_КАВЫ*10+ТИП_СТРО;
   КОМ_КАВ_КАВ = ТИП_КАВЫ*10+ТИП_КАВЫ;

;  КОМ_СТР_ЧИС_ЧИС = ТИП_СТРО*100+ТИП_ЧИСЛ*10+ТИП_ЧИСЛ;
;  КОМ_СТР_ЧИС_СТР = ТИП_СТРО*100+ТИП_ЧИСЛ*10+ТИП_СТРО;
;  КОМ_СТР_ЧИС_КАВ = ТИП_СТРО*100+ТИП_ЧИСЛ*10+ТИП_КАВЫ;

;  КОМ_СТР_СТР_ЧИС = ТИП_СТРО*100+ТИП_СТРО*10+ТИП_ЧИСЛ;
;  КОМ_СТР_СТР_СТР = ТИП_СТРО*100+ТИП_СТРО*10+ТИП_СТРО;
;  КОМ_СТР_СТР_КАВ = ТИП_СТРО*100+ТИП_СТРО*10+ТИП_КАВЫ;

;==============================================================================}
;{ Tim-Pascal-Lib БИБЛИОТЕКА                                            .

;---{ ФУНКЦИИ ДЛЯ РАБОТЫ С СТРОКАМИ         .

ЗАПИСАТЬ_ЧИСЛО_AX_В_СТРОКУ_DX       :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
pushad                  ;
mov  si,dx              ;
mov  [si],byte 0        ;
call ДОБАВИТЬ_ЧИСЛО_AX_В_КОНЕЦ_СТРОКИ_SI;
popad                   ;
ret                     ;
END IF                  ;}
IF  (ПЛАТФОРМА = T16)   ;{
pushad                  ;
mov  si,dx              ;
mov  [si],byte 0        ;
call ДОБАВИТЬ_ЧИСЛО_AX_В_КОНЕЦ_СТРОКИ_SI;
popad                   ;
ret                     ;
END IF                  ;}
IF  (ПЛАТФОРМА = T32)   ;{
pushad                  ;
mov  Esi,Edx            ;
mov  [Esi],byte 0       ;
call ДОБАВИТЬ_ЧИСЛО_AX_В_КОНЕЦ_СТРОКИ_SI;
popad                   ;
ret                     ;
END IF                  ;}
;==============================================================================}
ДОБАВИТЬ_ЧИСЛО_AX_В_КОНЕЦ_СТРОКИ_SI :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
         pushad
         MOV  BX,10    ;// 10 система счисления
         xor  cx,cx    ;

.ЦИКЛ1:  ;-------------;
         xor  DX,DX    ;
         DIV  BX       ;
         push dx       ;// Сохраняем остаток от деления в стек
         inc  cx       ;
         test ax,ax    ;
         jnz .ЦИКЛ1    ;
         ;-------------;


.ЦИКЛ2:  ;-------------;
         pop  dx       ;
         add  dl,'0'   ;
         mov  al,dl    ;
         call ДОБАВИТЬ_БУКВУ_AL_В_КОНЕЦ_СТРОКИ_SI;
         dec  cx       ;
         test cx,cx    ;
         jnz .ЦИКЛ2    ;
         ;-------------;

         popad         ;
         ret           ;
         END IF        ;}
IF  (ПЛАТФОРМА = T16)   ;{
         pushad
         MOV  BX,10    ;// 10 система счисления
         xor  cx,cx    ;

.ЦИКЛ1:  ;-------------;
         xor  DX,DX    ;
         DIV  BX       ;
         push dx       ;// Сохраняем остаток от деления в стек
         inc  cx       ;
         test ax,ax    ;
         jnz .ЦИКЛ1    ;
         ;-------------;


.ЦИКЛ2:  ;-------------;
         pop  dx       ;
         add  dl,'0'   ;
         mov  al,dl    ;
         call ДОБАВИТЬ_БУКВУ_AL_В_КОНЕЦ_СТРОКИ_SI;
         dec  cx       ;
         test cx,cx    ;
         jnz .ЦИКЛ2    ;
         ;-------------;

         popad         ;
         ret           ;
         END IF        ;}
IF  (ПЛАТФОРМА = T32)   ;{
         pushad
         MOV  EBX,10   ;// 10 система счисления
         xor  Ecx,Ecx  ;

.ЦИКЛ1:  ;-------------;
         xor  EDX,EDX  ;
         DIV  EBX      ;
         push Edx      ;// Сохраняем остаток от деления в стек
         inc  Ecx      ;
         test Eax,Eax  ;
         jnz .ЦИКЛ1    ;
         ;-------------;


.ЦИКЛ2:  ;-------------;
         pop  Edx      ;
         add  dl,'0'   ;
         mov  al,dl    ;
         call ДОБАВИТЬ_БУКВУ_AL_В_КОНЕЦ_СТРОКИ_SI;
         dec  Ecx      ;
         test Ecx,Ecx  ;
         jnz .ЦИКЛ2    ;
         ;-------------;

         popad         ;
         ret           ;
         END IF        ;}
;==============================================================================}
ДОБАВИТЬ_ЧИСЛО_CX_В_КОНЕЦ_СТРОКИ_BX :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
         pushad         ;
         mov  si,bx     ;
         mov  ax,cx     ;
         call ДОБАВИТЬ_ЧИСЛО_AX_В_КОНЕЦ_СТРОКИ_SI;
         popad          ;
         ret            ;
         END IF         ;}
IF  (ПЛАТФОРМА = T16)   ;{
         pushad         ;
         mov  si,bx     ;
         mov  ax,cx     ;
         call ДОБАВИТЬ_ЧИСЛО_AX_В_КОНЕЦ_СТРОКИ_SI;
         popad          ;
         ret            ;
         END IF         ;}
IF  (ПЛАТФОРМА = T32)   ;{
         pushad         ;
         mov  Esi,Ebx   ;
         mov  Eax,Ecx   ;
         call ДОБАВИТЬ_ЧИСЛО_AX_В_КОНЕЦ_СТРОКИ_SI;
         popad          ;
         ret            ;
         END IF         ;}
;==============================================================================}
ДОБАВИТЬ_ЧИСЛО_DX_В_КОНЕЦ_СТРОКИ_BX :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
         pushad         ;
         mov  si,bx     ;
         mov  ax,dx     ;
         call ДОБАВИТЬ_ЧИСЛО_AX_В_КОНЕЦ_СТРОКИ_SI;
         popad          ;
         ret            ;
         END IF         ;}
IF  (ПЛАТФОРМА = T16)   ;{
         pushad         ;
         mov  si,bx     ;
         mov  ax,dx     ;
         call ДОБАВИТЬ_ЧИСЛО_AX_В_КОНЕЦ_СТРОКИ_SI;
         popad          ;
         ret            ;
         END IF         ;}
IF  (ПЛАТФОРМА = T32)   ;{
         pushad         ;
         mov  esi,ebx   ;
         mov  eax,edx   ;
         call ДОБАВИТЬ_ЧИСЛО_AX_В_КОНЕЦ_СТРОКИ_SI;
         popad          ;
         ret            ;
         END IF         ;}
;==============================================================================}

ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_CX_СТРОКУ_DX:;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  pushad               ;
                  mov si,dx            ;
                  mov di,cx            ;
.ЦИКЛ:
                  mov  al,[si]         ;
                  test al,al           ;
                  jz  .КЦИКЛ           ;
                  call ДОБАВИТЬ_БУКВУ_AL_В_КОНЕЦ_СТРОКИ_DI;
                  inc  sI              ;
                  jmp .ЦИКЛ            ;
.КЦИКЛ:
                  popad                ;
                  ret                  ;
                  END IF               ;}
IF  (ПЛАТФОРМА = T16)   ;{
                  pushad               ;
                  mov si,dx            ;
                  mov di,cx            ;
.ЦИКЛ:
                  mov  al,[si]         ;
                  test al,al           ;
                  jz  .КЦИКЛ           ;
                  call ДОБАВИТЬ_БУКВУ_AL_В_КОНЕЦ_СТРОКИ_DI;
                  inc  sI              ;
                  jmp .ЦИКЛ            ;
.КЦИКЛ:
                  popad                ;
                  ret                  ;
                  END IF               ;}
IF  (ПЛАТФОРМА = T32)   ;{
                  pushad               ;
                  mov esi,edx          ;
                  mov edi,ecx          ;
.ЦИКЛ:
                  mov  al,[esi]        ;
                  test al,al           ;
                  jz  .КЦИКЛ           ;
                  call ДОБАВИТЬ_БУКВУ_AL_В_КОНЕЦ_СТРОКИ_DI;
                  inc  esI             ;
                  jmp .ЦИКЛ            ;
.КЦИКЛ:
                  popad                ;
                  ret                  ;
                  END IF               ;}
;==============================================================================}
ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_DX_СТРОКУ_CX:;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  pushad    ;
                  mov  bx,cx;
                  mov  cx,dx;
                  mov  dx,bx;
                  call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_CX_СТРОКУ_DX;
                  popad     ;
                  ret       ;
                  END IF    ;}
IF  (ПЛАТФОРМА = T16)   ;{
                  pushad    ;
                  mov  bx,cx;
                  mov  cx,dx;
                  mov  dx,bx;
                  call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_CX_СТРОКУ_DX;
                  popad     ;
                  ret       ;
                  END IF    ;}
IF  (ПЛАТФОРМА = T32)   ;{
                  pushad      ;
                  mov  ebx,ecx;
                  mov  ecx,edx;
                  mov  edx,ebx;
                  call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_CX_СТРОКУ_DX;
                  popad       ;
                  ret         ;
                  END IF     ;}
;}
ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_SI_СТРОКУ_AX:;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  pushad    ;
                  mov  cx,SI;
                  mov  dx,ax;
                  call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_CX_СТРОКУ_DX;
                  popad     ;
                  ret       ;
                  END IF    ;}
IF  (ПЛАТФОРМА = T16)   ;{
                  pushad    ;
                  mov  cx,SI;
                  mov  dx,ax;
                  call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_CX_СТРОКУ_DX;
                  popad     ;
                  ret       ;
                  END IF    ;}
IF  (ПЛАТФОРМА = T32)   ;{
                  pushad      ;
                  mov  ecx,eSI;
                  mov  edx,eax;
                  call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_CX_СТРОКУ_DX;
                  popad       ;
                  ret         ;
                  END IF      ;}
;}
ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_BX_СТРОКУ_DX:;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  pushad    ;
                  mov  cx,bx;
                  call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_CX_СТРОКУ_DX;
                  popad     ;
                  ret       ;
                  END IF    ;}
IF  (ПЛАТФОРМА = T16)   ;{
                  pushad    ;
                  mov  cx,bx;
                  call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_CX_СТРОКУ_DX;
                  popad     ;
                  ret       ;
                  END IF    ;}
IF  (ПЛАТФОРМА = T32)   ;{
                  pushad    ;
                  mov  ecx,ebx;
                  call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_CX_СТРОКУ_DX;
                  popad     ;
                  ret       ;
                  END IF    ;}

;}
ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_BX_СТРОКУ_CX:;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  pushad    ;
                  mov  dx,bx;
                  call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_DX_СТРОКУ_CX;
                  popad     ;
                  ret       ;
                  END IF    ;}
IF  (ПЛАТФОРМА = T16)   ;{
                  pushad    ;
                  mov  dx,bx;
                  call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_DX_СТРОКУ_CX;
                  popad     ;
                  ret       ;
                  END IF    ;}
IF  (ПЛАТФОРМА = T32)   ;{
                  pushad    ;
                  mov  edx,ebx;
                  call ДОБАВИТЬ_В_КОНЕЦ_СТРОКИ_DX_СТРОКУ_CX;
                  popad     ;
                  ret       ;
                  END IF    ;}
;}


СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI  :;{    1 МЕНЬШЕ 0 РАВНЫ 2 БОЛЬШЕ
IF  (ПЛАТФОРМА = ДОС)   ;{
                pushad;
                mov  si,cx;
                mov  di,dx;

                xor  cx,cx;
                xor  dx,dx;

.ЦИКЛ:
                mov  cl,[si];
                mov  dl,[di];


                mov  ax,cx;
                add  ax,dx;
                test ax,ax;
                jz  .РАВНЫ;

                test cx,cx;
                jz  .МЕНЬШЕ;
                test dx,dx;
                jz  .БОЛЬШЕ;

                cmp  cx,dx;             // НЕ смешно ! )))))))
                jb  .МЕНЬШЕ ;
                ja  .БОЛЬШЕ ;


                inc  si;
                inc  di;
                jmp .ЦИКЛ;
.КЦИКЛА:

.БОЛЬШЕ:
                mov  ax,2;
                jmp  .ВЫХОД;
.МЕНЬШЕ:
                mov  ax,1;
                jmp  .ВЫХОД;
.РАВНЫ:
                mov  ax,0;
                jmp  .ВЫХОД;
.ВЫХОД:
                pop  si;
                push ax;
                popad;
                ret;
                END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                pushad;
                mov  si,cx;
                mov  di,dx;

                xor  cx,cx;
                xor  dx,dx;

.ЦИКЛ:
                mov  cl,[si];
                mov  dl,[di];


                mov  ax,cx;
                add  ax,dx;
                test ax,ax;
                jz  .РАВНЫ;

                test cx,cx;
                jz  .МЕНЬШЕ;
                test dx,dx;
                jz  .БОЛЬШЕ;

                cmp  cx,dx;             // НЕ смешно ! )))))))
                jb  .МЕНЬШЕ ;
                ja  .БОЛЬШЕ ;


                inc  si;
                inc  di;
                jmp .ЦИКЛ;
.КЦИКЛА:

.БОЛЬШЕ:
                mov  ax,2;
                jmp  .ВЫХОД;
.МЕНЬШЕ:
                mov  ax,1;
                jmp  .ВЫХОД;
.РАВНЫ:
                mov  ax,0;
                jmp  .ВЫХОД;
.ВЫХОД:
                pop  si;
                push ax;
                popad;
                ret;
                END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                pushad;
                mov  esi,ecx;
                mov  edi,edx;

                xor  ecx,ecx;
                xor  edx,edx;

.ЦИКЛ:
                mov  cl,[esi];
                mov  dl,[edi];


                mov  eax,ecx;
                add  eax,edx;
                test eax,eax;
                jz  .РАВНЫ;

                test ecx,ecx;
                jz  .МЕНЬШЕ;
                test edx,edx;
                jz  .БОЛЬШЕ;

                cmp  ecx,edx;             // НЕ смешно ! )))))))
                jb  .МЕНЬШЕ ;
                ja  .БОЛЬШЕ ;


                inc  esi;
                inc  edi;
                jmp .ЦИКЛ;
.КЦИКЛА:

.БОЛЬШЕ:
                mov  eax,2;
                jmp  .ВЫХОД;
.МЕНЬШЕ:
                mov  eax,1;
                jmp  .ВЫХОД;
.РАВНЫ:
                mov  eax,0;
                jmp  .ВЫХОД;
.ВЫХОД:
                pop  esi;
                push eax;
                popad;
                ret;
                END IF;}
;==============================================================================}

СТРОКА_CX_БОЛЬШЕ_СТРОКИ_DX_ФЛАГ_Z_1 :;{ Если строка CX Больще СТРОКИ DX
IF  (ПЛАТФОРМА = ДОС)   ;{
                 pushad;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 cmp  di,2     ;
                 jnz .НЕ_БОЛЬШЕ;
                 mov  al,1     ;
                 test al,al    ;
                 jmp .ВЫХОД    ;
.НЕ_БОЛЬШЕ:      mov  al,0     ;
                 test al,al    ;
.ВЫХОД:
                 popad;
                 ret
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 pushad;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 cmp  di,2     ;
                 jnz .НЕ_БОЛЬШЕ;
                 mov  al,1     ;
                 test al,al    ;
                 jmp .ВЫХОД    ;
.НЕ_БОЛЬШЕ:      mov  al,0     ;
                 test al,al    ;
.ВЫХОД:
                 popad;
                 ret
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 pushad;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 cmp  edi,2    ;
                 jnz .НЕ_БОЛЬШЕ;
                 mov  al,1     ;
                 test al,al    ;
                 jmp .ВЫХОД    ;
.НЕ_БОЛЬШЕ:      mov  al,0     ;
                 test al,al    ;
.ВЫХОД:
                 popad;
                 ret
                 END IF;}
;==============================================================================}
СТРОКА_CX_БОЛЬШЕР_СТРОКИ_DX_ФЛАГ_Z_1:;{ Если строка CX Больще либо равно СТРОКИ DX
IF  (ПЛАТФОРМА = ДОС)   ;{
                 pushad        ;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 cmp  di,1     ;
                 jz  .НЕ_БОЛЬШЕ;
                 mov  al,1     ;
                 test al,al    ;
                 jmp .ВЫХОД    ;
.НЕ_БОЛЬШЕ:      mov  al,0     ;
                 test al,al    ;
.ВЫХОД:
                 popad         ;
                 ret           ;
                 END IF        ;}
IF  (ПЛАТФОРМА = T16)   ;{
                 pushad        ;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 cmp  di,1     ;
                 jz  .НЕ_БОЛЬШЕ;
                 mov  al,1     ;
                 test al,al    ;
                 jmp .ВЫХОД    ;
.НЕ_БОЛЬШЕ:      mov  al,0     ;
                 test al,al    ;
.ВЫХОД:
                 popad         ;
                 ret           ;
                 END IF        ;}
IF  (ПЛАТФОРМА = T32)   ;{
                 pushad        ;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 cmp  edi,1    ;
                 jz  .НЕ_БОЛЬШЕ;
                 mov  al,1     ;
                 test al,al    ;
                 jmp .ВЫХОД    ;
.НЕ_БОЛЬШЕ:      mov  al,0     ;
                 test al,al    ;
.ВЫХОД:
                 popad         ;
                 ret           ;
                 END IF        ;}
;==============================================================================}
СТРОКА_CX_МЕНЬШЕ_СТРОКИ_DX_ФЛАГ_Z_1 :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 pushad;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 cmp  di,1     ;
                 jnz .НЕ_МЕНЬШЕ;
                 mov  al,1     ;
                 test al,al    ;
                 jmp .ВЫХОД    ;
.НЕ_МЕНЬШЕ:      mov  al,0     ;
                 test al,al    ;
.ВЫХОД:
                 popad         ;
                 ret           ;
                 END IF        ;}
IF  (ПЛАТФОРМА = T16)   ;{
                 pushad;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 cmp  di,1     ;
                 jnz .НЕ_МЕНЬШЕ;
                 mov  al,1     ;
                 test al,al    ;
                 jmp .ВЫХОД    ;
.НЕ_МЕНЬШЕ:      mov  al,0     ;
                 test al,al    ;
.ВЫХОД:
                 popad         ;
                 ret           ;
                 END IF        ;}
IF  (ПЛАТФОРМА = T32)   ;{
                 pushad;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 cmp  edi,1    ;
                 jnz .НЕ_МЕНЬШЕ;
                 mov  al,1     ;
                 test al,al    ;
                 jmp .ВЫХОД    ;
.НЕ_МЕНЬШЕ:      mov  al,0     ;
                 test al,al    ;
.ВЫХОД:
                 popad         ;
                 ret           ;
                 END IF        ;}
;==============================================================================}
СТРОКА_CX_МЕНЬШЕР_СТРОКИ_DX_ФЛАГ_Z_1:;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 pushad        ;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 cmp  di,2     ;
                 jz  .НЕ_МЕНЬШЕ;
                 mov  al,1     ;
                 test al,al    ;
                 jmp .ВЫХОД    ;
.НЕ_МЕНЬШЕ:      mov  al,0     ;
                 test al,al    ;
.ВЫХОД:
                 popad         ;
                 ret           ;
                 END IF        ;}
IF  (ПЛАТФОРМА = T16)   ;{
                 pushad        ;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 cmp  di,2     ;
                 jz  .НЕ_МЕНЬШЕ;
                 mov  al,1     ;
                 test al,al    ;
                 jmp .ВЫХОД    ;
.НЕ_МЕНЬШЕ:      mov  al,0     ;
                 test al,al    ;
.ВЫХОД:
                 popad         ;
                 ret           ;
                 END IF        ;}
IF  (ПЛАТФОРМА = T32)   ;{
                 pushad        ;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 cmp  edi,2    ;
                 jz  .НЕ_МЕНЬШЕ;
                 mov  al,1     ;
                 test al,al    ;
                 jmp .ВЫХОД    ;
.НЕ_МЕНЬШЕ:      mov  al,0     ;
                 test al,al    ;
.ВЫХОД:
                 popad         ;
                 ret           ;
                 END IF        ;}
;==============================================================================}
СТРОКА_CX_РАВНА_СТРОКИ_DX_ФЛАГ_Z_1  :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 pushad;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 cmp  di,0     ;
                 jnz .НЕ_РАВНО ;
                 mov  al,1     ;
                 test al,al    ;
                 jmp .ВЫХОД    ;
.НЕ_РАВНО:       mov  al,0     ;
                 test al,al    ;
.ВЫХОД:
                 popad         ;
                 ret           ;
                 END IF        ;}
IF  (ПЛАТФОРМА = T16)   ;{
                 pushad;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 cmp  di,0     ;
                 jnz .НЕ_РАВНО ;
                 mov  al,1     ;
                 test al,al    ;
                 jmp .ВЫХОД    ;
.НЕ_РАВНО:       mov  al,0     ;
                 test al,al    ;
.ВЫХОД:
                 popad         ;
                 ret           ;
                 END IF        ;}
IF  (ПЛАТФОРМА = T32)   ;{
                 pushad;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 cmp  edi,0    ;
                 jnz .НЕ_РАВНО ;
                 mov  al,1     ;
                 test al,al    ;
                 jmp .ВЫХОД    ;
.НЕ_РАВНО:       mov  al,0     ;
                 test al,al    ;
.ВЫХОД:
                 popad         ;
                 ret           ;
                 END IF        ;}
;==============================================================================}

СТРОКА_CX_БОЛЬШЕ_ЧИСЛА_DX_ФЛАГ_Z_1  :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 pushad;
                 ;--------------------------------------;
                 call ЕСЛИ_СТРОКА_CX_ЧИСЛО_ФЛАГ_Z_1    ;
                 jz  .СТР_ЧИС                           ;
                 ;--------------------------------------;
                 call ПЕРЕВОДИТ_СТРОКУ_CX_В_ЧИСЛО_CX    ;
                 cmp  cx,dx                             ;
                 ja  .БОЛЬШЕ                            ;
                 jmp .НЕ_БОЛЬШЕ                         ;
                 ;--------------------------------------;
.СТР_ЧИС:
                 ;--------------------------------------;
                 mov  ax,dx                             ;
                 call СОЗДАТЬ_СТРОКУ_DX_ДЛИНОЙ_16_БАЙТ  ;
                 call ЗАПИСАТЬ_ЧИСЛО_AX_В_СТРОКУ_DX  ;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 call УДАЛИТЬ_СТРОКУ_DX                 ;
                 ;--------------------------------------;

                 cmp  di,2                              ;
                 jnz  .НЕ_БОЛЬШЕ                        ;
.БОЛЬШЕ:         mov  al,1                              ;
                 test al,al                             ;
                 jmp .ВЫХОД                             ;
.НЕ_БОЛЬШЕ:      mov  al,0                              ;
                 test al,al                             ;
.ВЫХОД:
                 popad;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 pushad;
                 ;--------------------------------------;
                 call ЕСЛИ_СТРОКА_CX_ЧИСЛО_ФЛАГ_Z_1    ;
                 jz  .СТР_ЧИС                           ;
                 ;--------------------------------------;
                 call ПЕРЕВОДИТ_СТРОКУ_CX_В_ЧИСЛО_CX    ;
                 cmp  cx,dx                             ;
                 ja  .БОЛЬШЕ                            ;
                 jmp .НЕ_БОЛЬШЕ                         ;
                 ;--------------------------------------;
.СТР_ЧИС:
                 ;--------------------------------------;
                 mov  ax,dx                             ;
                 call СОЗДАТЬ_СТРОКУ_DX_ДЛИНОЙ_16_БАЙТ  ;
                 call ЗАПИСАТЬ_ЧИСЛО_AX_В_СТРОКУ_DX  ;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 call УДАЛИТЬ_СТРОКУ_DX                 ;
                 ;--------------------------------------;

                 cmp  di,2                              ;
                 jnz  .НЕ_БОЛЬШЕ                        ;
.БОЛЬШЕ:         mov  al,1                              ;
                 test al,al                             ;
                 jmp .ВЫХОД                             ;
.НЕ_БОЛЬШЕ:      mov  al,0                              ;
                 test al,al                             ;
.ВЫХОД:
                 popad;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 pushad;
                 ;--------------------------------------;
                 call ЕСЛИ_СТРОКА_CX_ЧИСЛО_ФЛАГ_Z_1     ;
                 jz  .СТР_ЧИС                           ;
                 ;--------------------------------------;
                 call ПЕРЕВОДИТ_СТРОКУ_CX_В_ЧИСЛО_CX    ;
                 cmp  ecx,edx                           ;
                 ja  .БОЛЬШЕ                            ;
                 jmp .НЕ_БОЛЬШЕ                         ;
                 ;--------------------------------------;
.СТР_ЧИС:
                 ;--------------------------------------;
                 mov  eax,edx                           ;
                 call СОЗДАТЬ_СТРОКУ_DX_ДЛИНОЙ_16_БАЙТ  ;
                 call ЗАПИСАТЬ_ЧИСЛО_AX_В_СТРОКУ_DX     ;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 call УДАЛИТЬ_СТРОКУ_DX                 ;
                 ;--------------------------------------;

                 cmp  edi,2                             ;
                 jnz  .НЕ_БОЛЬШЕ                        ;
.БОЛЬШЕ:         mov  al,1                              ;
                 test al,al                             ;
                 jmp .ВЫХОД                             ;
.НЕ_БОЛЬШЕ:      mov  al,0                              ;
                 test al,al                             ;
.ВЫХОД:
                 popad;
                 ret;
                 END IF;}
;==============================================================================}
СТРОКА_CX_БОЛЬШЕР_ЧИСЛА_DX_ФЛАГ_Z_1 :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 pushad;
                 ;--------------------------------------;
                 call ЕСЛИ_СТРОКА_CX_ЧИСЛО_ФЛАГ_Z_1    ;
                 jz  .СТР_ЧИС                           ;
                 ;--------------------------------------;
                 call ПЕРЕВОДИТ_СТРОКУ_CX_В_ЧИСЛО_CX    ;
                 cmp  cx,dx                             ;
                 ja  .БОЛЬШЕ                            ;
                 jmp .НЕ_БОЛЬШЕ                         ;
                 ;--------------------------------------;
.СТР_ЧИС:
                 ;--------------------------------------;
                 mov  ax,dx                             ;
                 call СОЗДАТЬ_СТРОКУ_DX_ДЛИНОЙ_16_БАЙТ  ;
                 call ЗАПИСАТЬ_ЧИСЛО_AX_В_СТРОКУ_DX  ;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 call УДАЛИТЬ_СТРОКУ_DX                 ;
                 ;--------------------------------------;

                 cmp  di,2                              ;
                 jnz  .НЕ_БОЛЬШЕ                        ;
.БОЛЬШЕ:         mov  al,1                              ;
                 test al,al                             ;
                 jmp .ВЫХОД                             ;
.НЕ_БОЛЬШЕ:      mov  al,0                              ;
                 test al,al                             ;
.ВЫХОД:
                 popad;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 pushad;
                 ;--------------------------------------;
                 call ЕСЛИ_СТРОКА_CX_ЧИСЛО_ФЛАГ_Z_1    ;
                 jz  .СТР_ЧИС                           ;
                 ;--------------------------------------;
                 call ПЕРЕВОДИТ_СТРОКУ_CX_В_ЧИСЛО_CX    ;
                 cmp  cx,dx                             ;
                 ja  .БОЛЬШЕ                            ;
                 jmp .НЕ_БОЛЬШЕ                         ;
                 ;--------------------------------------;
.СТР_ЧИС:
                 ;--------------------------------------;
                 mov  ax,dx                             ;
                 call СОЗДАТЬ_СТРОКУ_DX_ДЛИНОЙ_16_БАЙТ  ;
                 call ЗАПИСАТЬ_ЧИСЛО_AX_В_СТРОКУ_DX  ;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 call УДАЛИТЬ_СТРОКУ_DX                 ;
                 ;--------------------------------------;

                 cmp  di,2                              ;
                 jnz  .НЕ_БОЛЬШЕ                        ;
.БОЛЬШЕ:         mov  al,1                              ;
                 test al,al                             ;
                 jmp .ВЫХОД                             ;
.НЕ_БОЛЬШЕ:      mov  al,0                              ;
                 test al,al                             ;
.ВЫХОД:
                 popad;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 pushad;
                 ;--------------------------------------;
                 call ЕСЛИ_СТРОКА_CX_ЧИСЛО_ФЛАГ_Z_1    ;
                 jz  .СТР_ЧИС                           ;
                 ;--------------------------------------;
                 call ПЕРЕВОДИТ_СТРОКУ_CX_В_ЧИСЛО_CX    ;
                 cmp  ecx,edx                           ;
                 ja  .БОЛЬШЕ                            ;
                 jmp .НЕ_БОЛЬШЕ                         ;
                 ;--------------------------------------;
.СТР_ЧИС:
                 ;--------------------------------------;
                 mov  eax,edx                           ;
                 call СОЗДАТЬ_СТРОКУ_DX_ДЛИНОЙ_16_БАЙТ  ;
                 call ЗАПИСАТЬ_ЧИСЛО_AX_В_СТРОКУ_DX     ;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 call УДАЛИТЬ_СТРОКУ_DX                 ;
                 ;--------------------------------------;

                 cmp  edi,2                             ;
                 jnz  .НЕ_БОЛЬШЕ                        ;
.БОЛЬШЕ:         mov  al,1                              ;
                 test al,al                             ;
                 jmp .ВЫХОД                             ;
.НЕ_БОЛЬШЕ:      mov  al,0                              ;
                 test al,al                             ;
.ВЫХОД:
                 popad;
                 ret;
                 END IF;}
;==============================================================================}
СТРОКА_CX_МЕНЬШЕ_ЧИСЛА_DX_ФЛАГ_Z_1  :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 pushad;
                 ;--------------------------------------;
                 call ЕСЛИ_СТРОКА_CX_ЧИСЛО_ФЛАГ_Z_1     ;
                 jz  .СТР_ЧИС                           ;
                 ;--------------------------------------;
                 call ПЕРЕВОДИТ_СТРОКУ_CX_В_ЧИСЛО_CX    ;
                 cmp  cx,dx                             ;
                 jb  .МЕНЬШЕ                            ;
                 jmp .НЕ_МЕНЬШЕ                         ;
                 ;--------------------------------------;
.СТР_ЧИС:
                 ;--------------------------------------;
                 mov  ax,dx                             ;
                 call СОЗДАТЬ_СТРОКУ_DX_ДЛИНОЙ_16_БАЙТ  ;
                 call ЗАПИСАТЬ_ЧИСЛО_AX_В_СТРОКУ_DX   ;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 call УДАЛИТЬ_СТРОКУ_DX                 ;
                 ;--------------------------------------;
                 cmp   di,1                             ;
                 jnz  .НЕ_МЕНЬШЕ                        ;
.МЕНЬШЕ:         mov  al,1                              ;
                 test al,al                             ;
                 jmp .ВЫХОД                             ;
.НЕ_МЕНЬШЕ:      mov  al,0                              ;
                 test al,al                             ;
.ВЫХОД:
                 popad;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 pushad;
                 ;--------------------------------------;
                 call ЕСЛИ_СТРОКА_CX_ЧИСЛО_ФЛАГ_Z_1     ;
                 jz  .СТР_ЧИС                           ;
                 ;--------------------------------------;
                 call ПЕРЕВОДИТ_СТРОКУ_CX_В_ЧИСЛО_CX    ;
                 cmp  cx,dx                             ;
                 jb  .МЕНЬШЕ                            ;
                 jmp .НЕ_МЕНЬШЕ                         ;
                 ;--------------------------------------;
.СТР_ЧИС:
                 ;--------------------------------------;
                 mov  ax,dx                             ;
                 call СОЗДАТЬ_СТРОКУ_DX_ДЛИНОЙ_16_БАЙТ  ;
                 call ЗАПИСАТЬ_ЧИСЛО_AX_В_СТРОКУ_DX   ;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 call УДАЛИТЬ_СТРОКУ_DX                 ;
                 ;--------------------------------------;
                 cmp   di,1                             ;
                 jnz  .НЕ_МЕНЬШЕ                        ;
.МЕНЬШЕ:         mov  al,1                              ;
                 test al,al                             ;
                 jmp .ВЫХОД                             ;
.НЕ_МЕНЬШЕ:      mov  al,0                              ;
                 test al,al                             ;
.ВЫХОД:
                 popad;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 pushad;
                 ;--------------------------------------;
                 call ЕСЛИ_СТРОКА_CX_ЧИСЛО_ФЛАГ_Z_1     ;
                 jz  .СТР_ЧИС                           ;
                 ;--------------------------------------;
                 call ПЕРЕВОДИТ_СТРОКУ_CX_В_ЧИСЛО_CX    ;
                 cmp  ecx,edx                           ;
                 jb  .МЕНЬШЕ                            ;
                 jmp .НЕ_МЕНЬШЕ                         ;
                 ;--------------------------------------;
.СТР_ЧИС:
                 ;--------------------------------------;
                 mov  eax,edx                           ;
                 call СОЗДАТЬ_СТРОКУ_DX_ДЛИНОЙ_16_БАЙТ  ;
                 call ЗАПИСАТЬ_ЧИСЛО_AX_В_СТРОКУ_DX   ;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 call УДАЛИТЬ_СТРОКУ_DX                 ;
                 ;--------------------------------------;
                 cmp  edi,1                             ;
                 jnz  .НЕ_МЕНЬШЕ                        ;
.МЕНЬШЕ:         mov  al,1                              ;
                 test al,al                             ;
                 jmp .ВЫХОД                             ;
.НЕ_МЕНЬШЕ:      mov  al,0                              ;
                 test al,al                             ;
.ВЫХОД:
                 popad;
                 ret;
                 END IF;}
;==============================================================================}
СТРОКА_CX_МЕНЬШЕР_ЧИСЛА_DX_ФЛАГ_Z_1 :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 pushad;
                 ;--------------------------------------;
                 call ЕСЛИ_СТРОКА_CX_ЧИСЛО_ФЛАГ_Z_1     ;
                 jz  .СТР_ЧИС                           ;
                 ;--------------------------------------;
                 call ПЕРЕВОДИТ_СТРОКУ_CX_В_ЧИСЛО_CX    ;
                 cmp  cx,dx                             ;
                 jb  .МЕНЬШЕ                            ;
                 jmp .НЕ_МЕНЬШЕ                         ;
                 ;--------------------------------------;
.СТР_ЧИС:
                 ;--------------------------------------;
                 mov  ax,dx                             ;
                 call СОЗДАТЬ_СТРОКУ_DX_ДЛИНОЙ_16_БАЙТ  ;
                 call ЗАПИСАТЬ_ЧИСЛО_AX_В_СТРОКУ_DX   ;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 call УДАЛИТЬ_СТРОКУ_DX                 ;
                 ;--------------------------------------;
                 cmp   di,1                             ;
                 jnz  .НЕ_МЕНЬШЕ                        ;
.МЕНЬШЕ:         mov  al,1                              ;
                 test al,al                             ;
                 jmp .ВЫХОД                             ;
.НЕ_МЕНЬШЕ:      mov  al,0                              ;
                 test al,al                             ;
.ВЫХОД:
                 popad;
                 ret;
                 END IF ;}
IF  (ПЛАТФОРМА = T16)   ;{
                 pushad;
                 ;--------------------------------------;
                 call ЕСЛИ_СТРОКА_CX_ЧИСЛО_ФЛАГ_Z_1     ;
                 jz  .СТР_ЧИС                           ;
                 ;--------------------------------------;
                 call ПЕРЕВОДИТ_СТРОКУ_CX_В_ЧИСЛО_CX    ;
                 cmp  cx,dx                             ;
                 jb  .МЕНЬШЕ                            ;
                 jmp .НЕ_МЕНЬШЕ                         ;
                 ;--------------------------------------;
.СТР_ЧИС:
                 ;--------------------------------------;
                 mov  ax,dx                             ;
                 call СОЗДАТЬ_СТРОКУ_DX_ДЛИНОЙ_16_БАЙТ  ;
                 call ЗАПИСАТЬ_ЧИСЛО_AX_В_СТРОКУ_DX   ;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 call УДАЛИТЬ_СТРОКУ_DX                 ;
                 ;--------------------------------------;
                 cmp   di,1                             ;
                 jnz  .НЕ_МЕНЬШЕ                        ;
.МЕНЬШЕ:         mov  al,1                              ;
                 test al,al                             ;
                 jmp .ВЫХОД                             ;
.НЕ_МЕНЬШЕ:      mov  al,0                              ;
                 test al,al                             ;
.ВЫХОД:
                 popad;
                 ret;
                 END IF ;}
IF  (ПЛАТФОРМА = T32)   ;{
                 pushad;
                 ;--------------------------------------;
                 call ЕСЛИ_СТРОКА_CX_ЧИСЛО_ФЛАГ_Z_1     ;
                 jz  .СТР_ЧИС                           ;
                 ;--------------------------------------;
                 call ПЕРЕВОДИТ_СТРОКУ_CX_В_ЧИСЛО_CX    ;
                 cmp  ecx,edx                           ;
                 jb  .МЕНЬШЕ                            ;
                 jmp .НЕ_МЕНЬШЕ                         ;
                 ;--------------------------------------;
.СТР_ЧИС:
                 ;--------------------------------------;
                 mov  eax,edx                           ;
                 call СОЗДАТЬ_СТРОКУ_DX_ДЛИНОЙ_16_БАЙТ  ;
                 call ЗАПИСАТЬ_ЧИСЛО_AX_В_СТРОКУ_DX   ;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 call УДАЛИТЬ_СТРОКУ_DX                 ;
                 ;--------------------------------------;
                 cmp  edi,1                             ;
                 jnz  .НЕ_МЕНЬШЕ                        ;
.МЕНЬШЕ:         mov  al,1                              ;
                 test al,al                             ;
                 jmp .ВЫХОД                             ;
.НЕ_МЕНЬШЕ:      mov  al,0                              ;
                 test al,al                             ;
.ВЫХОД:
                 popad;
                 ret;
                 END IF ;}
;==============================================================================}
СТРОКА_CX_РАВНА_ЧИСЛУ_DX_ФЛАГ_Z_1   :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 pushad;
                 ;--------------------------------------;
                 call ЕСЛИ_СТРОКА_CX_ЧИСЛО_ФЛАГ_Z_1     ;
                 jz  .СТР_ЧИС                           ;
                 ;--------------------------------------;
                 call ПЕРЕВОДИТ_СТРОКУ_CX_В_ЧИСЛО_CX    ;
                 cmp  cx,dx                             ;
                 jz  .РАВНО                             ;
                 jmp .НЕ_РАВНО                          ;
                 ;--------------------------------------;
.СТР_ЧИС:
                 ;--------------------------------------;
                 mov  ax,dx                             ;
                 call СОЗДАТЬ_СТРОКУ_DX_ДЛИНОЙ_16_БАЙТ  ;
                 call ЗАПИСАТЬ_ЧИСЛО_AX_В_СТРОКУ_DX   ;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 call УДАЛИТЬ_СТРОКУ_DX                 ;
                 ;--------------------------------------;

                 cmp  di,0                              ;
                 jnz .НЕ_РАВНО                          ;
.РАВНО:          mov  al,1                              ;
                 test al,al                             ;
                 jmp .ВЫХОД                             ;
.НЕ_РАВНО:       mov  al,0                              ;
                 test al,al                             ;
.ВЫХОД:
                 popad;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 pushad;
                 ;--------------------------------------;
                 call ЕСЛИ_СТРОКА_CX_ЧИСЛО_ФЛАГ_Z_1     ;
                 jz  .СТР_ЧИС                           ;
                 ;--------------------------------------;
                 call ПЕРЕВОДИТ_СТРОКУ_CX_В_ЧИСЛО_CX    ;
                 cmp  cx,dx                             ;
                 jz  .РАВНО                             ;
                 jmp .НЕ_РАВНО                          ;
                 ;--------------------------------------;
.СТР_ЧИС:
                 ;--------------------------------------;
                 mov  ax,dx                             ;
                 call СОЗДАТЬ_СТРОКУ_DX_ДЛИНОЙ_16_БАЙТ  ;
                 call ЗАПИСАТЬ_ЧИСЛО_AX_В_СТРОКУ_DX   ;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 call УДАЛИТЬ_СТРОКУ_DX                 ;
                 ;--------------------------------------;

                 cmp  di,0                              ;
                 jnz .НЕ_РАВНО                          ;
.РАВНО:          mov  al,1                              ;
                 test al,al                             ;
                 jmp .ВЫХОД                             ;
.НЕ_РАВНО:       mov  al,0                              ;
                 test al,al                             ;
.ВЫХОД:
                 popad;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 pushad;
                 ;--------------------------------------;
                 call ЕСЛИ_СТРОКА_CX_ЧИСЛО_ФЛАГ_Z_1     ;
                 jz  .СТР_ЧИС                           ;
                 ;--------------------------------------;
                 call ПЕРЕВОДИТ_СТРОКУ_CX_В_ЧИСЛО_CX    ;
                 cmp  Ecx,Edx                           ;
                 jz  .РАВНО                             ;
                 jmp .НЕ_РАВНО                          ;
                 ;--------------------------------------;
.СТР_ЧИС:
                 ;--------------------------------------;
                 mov  Eax,Edx                           ;
                 call СОЗДАТЬ_СТРОКУ_DX_ДЛИНОЙ_16_БАЙТ  ;
                 call ЗАПИСАТЬ_ЧИСЛО_AX_В_СТРОКУ_DX   ;
                 call СРАВНИТЬ_СТРОКИ_CX_DX_РЕЗУЛЬТАТ_DI;
                 call УДАЛИТЬ_СТРОКУ_DX                 ;
                 ;--------------------------------------;

                 cmp  Edi,0                              ;
                 jnz .НЕ_РАВНО                          ;
.РАВНО:          mov  al,1                              ;
                 test al,al                             ;
                 jmp .ВЫХОД                             ;
.НЕ_РАВНО:       mov  al,0                              ;
                 test al,al                             ;
.ВЫХОД:
                 popad;
                 ret;
                 END IF;}
;==============================================================================}

ЧИСЛО_CX_БОЛЬШЕ_СТРОКИ_DX_ФЛАГ_Z_1  :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
               pushad    ;
               mov  bx,cx;
               moV  cx,dx;
               mov  dx,bx;
               call СТРОКА_CX_МЕНЬШЕ_ЧИСЛА_DX_ФЛАГ_Z_1;
               mov  ax,0 ;
               jz  .МЕНЬШЕ;
               mov  ax,1;
.МЕНЬШЕ:
               test ax,ax;
               popad;
               ret;
               END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
               pushad    ;
               mov  bx,cx;
               moV  cx,dx;
               mov  dx,bx;
               call СТРОКА_CX_МЕНЬШЕ_ЧИСЛА_DX_ФЛАГ_Z_1;
               mov  ax,0 ;
               jz  .МЕНЬШЕ;
               mov  ax,1;
.МЕНЬШЕ:
               test ax,ax;
               popad;
               ret;
               END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
               pushad    ;
               mov  ebx,ecx;
               moV  ecx,edx;
               mov  edx,ebx;
               call СТРОКА_CX_МЕНЬШЕ_ЧИСЛА_DX_ФЛАГ_Z_1;
               mov  eax,0 ;
               jz  .МЕНЬШЕ;
               mov  eax,1;
.МЕНЬШЕ:
               test eax,eax;
               popad;
               ret;
               END IF;}
;==============================================================================}
ЧИСЛО_CX_БОЛЬШЕР_СТРОКИ_DX_ФЛАГ_Z_1 :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
               pushad;
               mov  bx,cx;
               moV  cx,dx;
               mov  dx,bx;
               call СТРОКА_CX_МЕНЬШЕ_ЧИСЛА_DX_ФЛАГ_Z_1;
               mov  ax,0;
               jz  .МЕНЬШЕ;
               mov  ax,1;
.МЕНЬШЕ:
               test ax,ax;
               popad;
               ret;
               END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
               pushad;
               mov  bx,cx;
               moV  cx,dx;
               mov  dx,bx;
               call СТРОКА_CX_МЕНЬШЕ_ЧИСЛА_DX_ФЛАГ_Z_1;
               mov  ax,0;
               jz  .МЕНЬШЕ;
               mov  ax,1;
.МЕНЬШЕ:
               test ax,ax;
               popad;
               ret;
               END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
               pushad;
               mov  ebx,ecx;
               moV  ecx,edx;
               mov  edx,ebx;
               call СТРОКА_CX_МЕНЬШЕ_ЧИСЛА_DX_ФЛАГ_Z_1;
               mov  eax,0;
               jz  .МЕНЬШЕ;
               mov  eax,1;
.МЕНЬШЕ:
               test eax,eax;
               popad;
               ret;
               END IF;}
;==============================================================================}
ЧИСЛО_CX_МЕНЬШЕ_СТРОКИ_DX_ФЛАГ_Z_1  :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
               pushad;
               mov  bx,cx;
               mov  cx,dx;
               mov  dx,bx;
               call СТРОКА_CX_БОЛЬШЕ_ЧИСЛА_DX_ФЛАГ_Z_1;// СТРОКА DX>ЧИС CX
               mov  ax,0;
               jz .БОЛЬШЕ;
               mov  ax,1;
.БОЛЬШЕ:
               test ax,ax;
               popad;
               ret;
               END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
               pushad;
               mov  bx,cx;
               mov  cx,dx;
               mov  dx,bx;
               call СТРОКА_CX_БОЛЬШЕ_ЧИСЛА_DX_ФЛАГ_Z_1;// СТРОКА DX>ЧИС CX
               mov  ax,0;
               jz .БОЛЬШЕ;
               mov  ax,1;
.БОЛЬШЕ:
               test ax,ax;
               popad;
               ret;
               END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
               pushad;
               mov  ebx,ecx;
               mov  ecx,edx;
               mov  edx,ebx;
               call СТРОКА_CX_БОЛЬШЕ_ЧИСЛА_DX_ФЛАГ_Z_1;// СТРОКА DX>ЧИС CX
               mov  eax,0;
               jz .БОЛЬШЕ;
               mov  eax,1;
.БОЛЬШЕ:
               test eax,eax;
               popad;
               ret;
               END IF;}

;==============================================================================}
ЧИСЛО_CX_МЕНЬШЕР_СТРОКИ_DX_ФЛАГ_Z_1 :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
               pushad;
               mov  bx,cx;
               mov  cx,dx;
               mov  dx,bx;
               call СТРОКА_CX_БОЛЬШЕ_ЧИСЛА_DX_ФЛАГ_Z_1;// СТРОКА DX>ЧИС CX
               mov  ax,0;
               jz .БОЛЬШЕ;
               mov  ax,1;
.БОЛЬШЕ:
               test ax,ax;
               popad;
               ret;
               END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
               pushad;
               mov  bx,cx;
               mov  cx,dx;
               mov  dx,bx;
               call СТРОКА_CX_БОЛЬШЕ_ЧИСЛА_DX_ФЛАГ_Z_1;// СТРОКА DX>ЧИС CX
               mov  ax,0;
               jz .БОЛЬШЕ;
               mov  ax,1;
.БОЛЬШЕ:
               test ax,ax;
               popad;
               ret;
               END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
               pushad;
               mov  ebx,ecx;
               mov  ecx,edx;
               mov  edx,ebx;
               call СТРОКА_CX_БОЛЬШЕ_ЧИСЛА_DX_ФЛАГ_Z_1;// СТРОКА DX>ЧИС CX
               mov  eax,0;
               jz .БОЛЬШЕ;
               mov  eax,1;
.БОЛЬШЕ:
               test eax,eax;
               popad;
               ret;
               END IF;}
;==============================================================================}
ЧИСЛО_CX_РАВНО_СТРОКИ_DX_ФЛАГ_Z_1   :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
               pushad;
               mov  bx,cx;
               mov  cx,dx;
               mov  dx,bx;
               call СТРОКА_CX_РАВНА_ЧИСЛУ_DX_ФЛАГ_Z_1;
               mov  ax,0;
               jz  .НЕ_РАВНО;
               mov  ax,1;
.НЕ_РАВНО:
               test ax,ax;
               popad;
               ret;
               END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
               pushad;
               mov  bx,cx;
               mov  cx,dx;
               mov  dx,bx;
               call СТРОКА_CX_РАВНА_ЧИСЛУ_DX_ФЛАГ_Z_1;
               mov  ax,0;
               jz  .НЕ_РАВНО;
               mov  ax,1;
.НЕ_РАВНО:
               test ax,ax;
               popad;
               ret;
               END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
               pushad;
               mov  ebx,ecx;
               mov  ecx,edx;
               mov  edx,ebx;
               call СТРОКА_CX_РАВНА_ЧИСЛУ_DX_ФЛАГ_Z_1;
               mov  eax,0;
               jz  .НЕ_РАВНО;
               mov  eax,1;
.НЕ_РАВНО:
               test eax,eax;
               popad;
               ret;
               END IF;}
;==============================================================================}

СТРО_BX_В_ЧИСЛ_BX                   :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
     pushad;
     mov  di,bx;
     call ПЕРЕВОДИТ_СТРОКУ_DI_В_ЧИСЛО_BX;
     call ВОЗВРАТИТЬ_BX;
     popad;
     ret;
     END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
     pushad;
     mov  di,bx;
     call ПЕРЕВОДИТ_СТРОКУ_DI_В_ЧИСЛО_BX;
     call ВОЗВРАТИТЬ_BX;
     popad;
     ret;
     END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
     pushad;
     mov  edi,ebx;
     call ПЕРЕВОДИТ_СТРОКУ_DI_В_ЧИСЛО_BX;
     call ВОЗВРАТИТЬ_BX;
     popad;
     ret;
     END IF;}
;}
ПЕРЕВОДИТ_СТРОКУ_DI_В_ЧИСЛО_BX      :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  push ax;
                  push si;
                  mov  si,di;
                  call ПЕРЕВОДИТ_СТРОКУ_SI_В_ЧИСЛО_AX;
                  mov  bx,ax;
                  pop  si;
                  pop  ax;
                  ret;
                  END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                  push ax;
                  push si;
                  mov  si,di;
                  call ПЕРЕВОДИТ_СТРОКУ_SI_В_ЧИСЛО_AX;
                  mov  bx,ax;
                  pop  si;
                  pop  ax;
                  ret;
                  END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                  push eax;
                  push esi;
                  mov  esi,edi;
                  call ПЕРЕВОДИТ_СТРОКУ_SI_В_ЧИСЛО_AX;
                  mov  ebx,eax;
                  pop  esi;
                  pop  eax;
                  ret;
                  END IF;}
;==============================================================================}
ПЕРЕВОДИТ_СТРОКУ_SI_В_ЧИСЛО_AX      :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 push dx;
                 push si;
                 xor dx,dx
.ЦИКЛ:	         xor ax,ax
                 mov al,[si];;lodsb
                 inc si;
                 test al,al
                 jz .КЦИКЛ
                 sub ax,'0'
                 shl dx,1
                 add ax,dx
                 shl dx,2
                 add dx,ax
                 jmp .ЦИКЛ
.КЦИКЛ:	         mov ax,dx;
                 pop si;
                 pop dx;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 push dx;
                 push si;
                 xor dx,dx
.ЦИКЛ:	         xor ax,ax
                 mov al,[si];;lodsb
                 inc si;
                 test al,al
                 jz .КЦИКЛ
                 sub ax,'0'
                 shl dx,1
                 add ax,dx
                 shl dx,2
                 add dx,ax
                 jmp .ЦИКЛ
.КЦИКЛ:	         mov ax,dx;
                 pop si;
                 pop dx;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 push edx;
                 push esi;
                 xor edx,edx
.ЦИКЛ:	         xor eax,eax
                 mov al,[esi];
                 inc esi;
                 test al,al
                 jz .КЦИКЛ
                 sub eax,'0'
                 shl edx,1
                 add eax,edx
                 shl edx,2
                 add edx,eax
                 jmp .ЦИКЛ
.КЦИКЛ:	         mov eax,edx;
                 pop esi;
                 pop edx;
                 ret;
                 END IF;}
;==============================================================================}
ПЕРЕВОДИТ_СТРОКУ_AX_В_ЧИСЛО_DX      :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  push ax;
                  push si;
                  mov  si,ax;
                  call ПЕРЕВОДИТ_СТРОКУ_SI_В_ЧИСЛО_AX;
                  mov  dx,ax;
                  pop  si;
                  pop  ax;
                  ret;
                  END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                  push ax;
                  push si;
                  mov  si,ax;
                  call ПЕРЕВОДИТ_СТРОКУ_SI_В_ЧИСЛО_AX;
                  mov  dx,ax;
                  pop  si;
                  pop  ax;
                  ret;
                  END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                  push eax;
                  push esi;
                  mov  esi,eax;
                  call ПЕРЕВОДИТ_СТРОКУ_SI_В_ЧИСЛО_AX;
                  mov  edx,eax;
                  pop  esi;
                  pop  eax;
                  ret;
                  END IF;}
;==============================================================================}
ПЕРЕВОДИТ_СТРОКУ_AX_В_ЧИСЛО_BX      :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  push ax;
                  push si;
                  mov  si,ax;
                  call ПЕРЕВОДИТ_СТРОКУ_SI_В_ЧИСЛО_AX;
                  mov  bx,ax;
                  pop  si;
                  pop  ax;
                  ret;
                  END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                  push ax;
                  push si;
                  mov  si,ax;
                  call ПЕРЕВОДИТ_СТРОКУ_SI_В_ЧИСЛО_AX;
                  mov  bx,ax;
                  pop  si;
                  pop  ax;
                  ret;
                  END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                  push eax;
                  push esi;
                  mov  esi,eax;
                  call ПЕРЕВОДИТ_СТРОКУ_SI_В_ЧИСЛО_AX;
                  mov  ebx,eax;
                  pop  esi;
                  pop  eax;
                  ret;
                  END IF;}
;==============================================================================}
ПЕРЕВОДИТ_СТРОКУ_SI_В_ЧИСЛО_BX      :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  push ax;
                  call ПЕРЕВОДИТ_СТРОКУ_SI_В_ЧИСЛО_AX;
                  mov  bx,ax;
                  pop  ax;
                  ret;
                  END IF ;}
IF  (ПЛАТФОРМА = T16)   ;{
                  push ax;
                  call ПЕРЕВОДИТ_СТРОКУ_SI_В_ЧИСЛО_AX;
                  mov  bx,ax;
                  pop  ax;
                  ret;
                  END IF ;}
IF  (ПЛАТФОРМА = T32)   ;{
                  push eax;
                  call ПЕРЕВОДИТ_СТРОКУ_SI_В_ЧИСЛО_AX;
                  mov  ebx,eax;
                  pop  eax;
                  ret;
                  END IF ;}
;==============================================================================}
ПЕРЕВОДИТ_СТРОКУ_CX_В_ЧИСЛО_CX      :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  push ax;
                  push si;
                  mov  si,cx;
                  call ПЕРЕВОДИТ_СТРОКУ_SI_В_ЧИСЛО_AX;
                  mov  cx,ax;
                  pop  si;
                  pop  ax;
                  ret;
                  END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                  push ax;
                  push si;
                  mov  si,cx;
                  call ПЕРЕВОДИТ_СТРОКУ_SI_В_ЧИСЛО_AX;
                  mov  cx,ax;
                  pop  si;
                  pop  ax;
                  ret;
                  END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                  push eax;
                  push esi;
                  mov  esi,ecx;
                  call ПЕРЕВОДИТ_СТРОКУ_SI_В_ЧИСЛО_AX;
                  mov  ecx,eax;
                  pop  esi;
                  pop  eax;
                  ret;
                  END IF;}
;==============================================================================}
ПЕРЕВОДИТ_СТРОКУ_DX_В_ЧИСЛО_DX      :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  push ax;
                  push si;
                  mov  si,dx;
                  call ПЕРЕВОДИТ_СТРОКУ_SI_В_ЧИСЛО_AX;
                  mov  dx,ax;
                  pop  si;
                  pop  ax;
                  ret;
                  END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                  push ax;
                  push si;
                  mov  si,dx;
                  call ПЕРЕВОДИТ_СТРОКУ_SI_В_ЧИСЛО_AX;
                  mov  dx,ax;
                  pop  si;
                  pop  ax;
                  ret;
                  END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                  push eax;
                  push esi;
                  mov  esi,edx;
                  call ПЕРЕВОДИТ_СТРОКУ_SI_В_ЧИСЛО_AX;
                  mov  edx,eax;
                  pop  esi;
                  pop  eax;
                  ret;
                  END IF;}
;==============================================================================}

ПЕРЕВОДИТ_СТРОКУ_DI_В_БОЛЬШИЕ_БУКВЫ :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 pushad;
.ЦИКЛ:           mov  al,[di];
                 test al,al  ;// Если конец строки то выход
                 JZ  .КЦИКЛ  ;
                 call ПРЕОБРАЗУЕТ_МАЛ_БУК_AL_В_БОЛ;
                 mov  [di],al;
                 inc  DI     ;// Увеличиывкем указатель на читаемый символ
                 Jmp .ЦИКЛ   ;
.КЦИКЛ:
                 popad ;
                 ret   ;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 pushad;
.ЦИКЛ:           mov  al,[di];
                 test al,al  ;// Если конец строки то выход
                 JZ  .КЦИКЛ  ;
                 call ПРЕОБРАЗУЕТ_МАЛ_БУК_AL_В_БОЛ;
                 mov  [di],al;
                 inc  DI     ;// Увеличиывкем указатель на читаемый символ
                 Jmp .ЦИКЛ   ;
.КЦИКЛ:
                 popad ;
                 ret   ;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 pushad;
.ЦИКЛ:           mov  al,[edi];
                 test al,al  ;// Если конец строки то выход
                 JZ  .КЦИКЛ  ;
                 call ПРЕОБРАЗУЕТ_МАЛ_БУК_AL_В_БОЛ;
                 mov  [edi],al;
                 inc  eDI     ;// Увеличиывкем указатель на читаемый символ
                 Jmp .ЦИКЛ   ;
.КЦИКЛ:
                 popad ;
                 ret   ;
                 END IF;}
;==============================================================================}
ПЕРЕВОДИТ_СТРОКУ_SI_В_БОЛЬШИЕ_БУКВЫ :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  push di;
                  mov  di,SI
                  call ПЕРЕВОДИТ_СТРОКУ_DI_В_БОЛЬШИЕ_БУКВЫ;
                  pop  di;
                  ret;
                  END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                  push di;
                  mov  di,SI
                  call ПЕРЕВОДИТ_СТРОКУ_DI_В_БОЛЬШИЕ_БУКВЫ;
                  pop  di;
                  ret;
                  END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                  push edi;
                  mov  edi,eSI
                  call ПЕРЕВОДИТ_СТРОКУ_DI_В_БОЛЬШИЕ_БУКВЫ;
                  pop  edi;
                  ret;
                  END IF;}
;==============================================================================}

ДОБ_AL_В_СТРО_DI:;---------------------
ДОБАВИТЬ_БУКВУ_AL_В_КОНЕЦ_СТРОКИ_DI :;{    // тут нужны переделки глобальные
IF  (ПЛАТФОРМА = ДОС)   ;{
                 pushad          ;
                 ;----------------;
                 call РАЗМЕР_DX_УЧАСТКА_ПАМЯТИ_DI; // Рассчитываем Максимальный адрес
                 add  Dx,di       ;
                 ;----------------;
                 Call ВОЗВРАЩАЕТ_АДРЕС_DI_0БАЙТА_СТРОКИ_DI;// Перемещаемся в конец строки
                 cmp  Dx,di       ; // Можно ли дописать ?
                 JBE .НЕЛЬЗЯ      ; // Если больше допустимого нельзя
                 ;----------------;
.МОЖНО:
                 ;----------------;
                 mov [DI],AL      ; // Записываем символ  вместо 0 конца строки
                 inc  DI          ; // Увеличиваем указатель на читаемый символ
                 mov  byte [DI],0 ; // Дописываем ноль в конец строки
                 mov  al,1        ;
                 test al,al       ; // JNZ Значит добавилося
                 jmp .ВЫХОД       ; // Поф на Скорость ПОтом понятность вжнее
                 ;----------------;
.НЕЛЬЗЯ:
                 ;----------------;
                 mov  al,0        ;
                 test al,al       ; // JZ Значит НЕ добавилося
                 ;----------------;
.ВЫХОД:
                 popad
                 ret              ;
                 END IF           ;}
IF  (ПЛАТФОРМА = T16)   ;{
                 pushad
                 ;----------------;
                 call РАЗМЕР_DX_УЧАСТКА_ПАМЯТИ_DI; // Рассчитываем Максимальный адрес
                 add  Dx,di       ;
                 ;----------------;
                 Call ВОЗВРАЩАЕТ_АДРЕС_DI_0БАЙТА_СТРОКИ_DI;// Перемещаемся в конец строки
                 cmp  Dx,di       ; // Можно ли дописать ?
                 JBE .НЕЛЬЗЯ      ; // Если больше допустимого нельзя
                 ;----------------;
.МОЖНО:
                 ;----------------;
                 mov [DI],AL      ; // Записываем символ  вместо 0 конца строки
                 inc  DI          ; // Увеличиваем указатель на читаемый символ
                 mov  byte [DI],0 ; // Дописываем ноль в конец строки
                 mov  al,1        ;
                 test al,al       ; // JNZ Значит добавилося
                 jmp .ВЫХОД       ; // Поф на Скорость ПОтом понятность вжнее
                 ;----------------;
.НЕЛЬЗЯ:
                 ;----------------;
                 mov  al,0        ;
                 test al,al       ; // JZ Значит НЕ добавилося
                 ;----------------;
.ВЫХОД:
                 popad            ;
                 ret              ;
                 END IF           ;}
IF  (ПЛАТФОРМА = T32)   ;{
                 pushad;
                 ;----------------;
                 call РАЗМЕР_DX_УЧАСТКА_ПАМЯТИ_DI; // Рассчитываем Максимальный адрес
                 add  eDx,edi       ;
                 ;----------------;
                 Call ВОЗВРАЩАЕТ_АДРЕС_DI_0БАЙТА_СТРОКИ_DI;// Перемещаемся в конец строки
                 cmp  eDx,edi       ; // Можно ли дописать ?
                 JBE .НЕЛЬЗЯ      ; // Если больше допустимого нельзя
                 ;----------------;
.МОЖНО:
                 ;----------------;
                 mov [eDI],AL      ; // Записываем символ  вместо 0 конца строки
                 inc  eDI          ; // Увеличиваем указатель на читаемый символ
                 mov [eDI],byte  0 ; // Дописываем ноль в конец строки
                 mov  al,1        ;
                 test al,al       ; // JNZ Значит добавилося
                 jmp .ВЫХОД       ; // Поф на Скорость ПОтом понятность вжнее
                 ;----------------;
.НЕЛЬЗЯ:
                 ;----------------;
                 mov  al,0        ;
                 test al,al       ; // JZ Значит НЕ добавилося
                 ;----------------;
.ВЫХОД:
                 popad            ;
                 ret              ;
                 END IF           ;}
;==============================================================================}



ДОБ_AL_В_СТРО_SI:;---------------------
ДОБАВИТЬ_БУКВУ_AL_В_КОНЕЦ_СТРОКИ_SI :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 push di;
                 mov  Di,Si;
                 call ДОБАВИТЬ_БУКВУ_AL_В_КОНЕЦ_СТРОКИ_DI
                 pop  di;
                 ret              ;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 push di;
                 mov  Di,Si;
                 call ДОБАВИТЬ_БУКВУ_AL_В_КОНЕЦ_СТРОКИ_DI
                 pop  di;
                 ret              ;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 push edi;
                 mov  eDi,eSi;
                 call ДОБАВИТЬ_БУКВУ_AL_В_КОНЕЦ_СТРОКИ_DI
                 pop  edi;
                 ret              ;
                 END IF;}
;==============================================================================}


СОЗДАТЬ_CX_КОПИЮ_СТРОКИ_DX          :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
        push di;
        push ax;
        mov  di,dx;
        call РАЗМЕР_AX_УЧАСТКА_ПАМЯТИ_DI
        call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_AX_БАЙТ;
        mov  cx,di;
        call ЗАПИСАТЬ_СТРОКУ_DX_В_СТРОКУ_CX
        pop  ax;
        pop  di;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
        push di;
        push ax;
        mov  di,dx;
        call РАЗМЕР_AX_УЧАСТКА_ПАМЯТИ_DI
        call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_AX_БАЙТ;
        mov  cx,di;
        call ЗАПИСАТЬ_СТРОКУ_DX_В_СТРОКУ_CX
        pop  ax;
        pop  di;
        ret;
        END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
        push edi;
        push eax;
        mov  edi,edx;
        call РАЗМЕР_AX_УЧАСТКА_ПАМЯТИ_DI
        call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_AX_БАЙТ;
        mov  ecx,edi;
        call ЗАПИСАТЬ_СТРОКУ_DX_В_СТРОКУ_CX
        pop  eax;
        pop  edi;
        ret;
        END IF;}
;}
СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_AX_БАЙТ    :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 mov  di,ax;
                 call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;
                 ret;
                 END IF ;}
IF  (ПЛАТФОРМА = T16)   ;{
                 mov  di,ax;
                 call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;
                 ret;
                 END IF ;}
IF  (ПЛАТФОРМА = T32)   ;{
                 mov  edi,eax;
                 call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;
                 ret;
                 END IF ;}
;==============================================================================}
СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_DI_БАЙТ    :;{
                 call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;
                 ret;
;==============================================================================}
СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_1024_БАЙТ  :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 mov  di,1024;
                 call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 mov  di,1024;
                 call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 mov  edi,1024;
                 call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;
                 ret;
                 END IF;}
;==============================================================================}
СОЗДАТЬ_СТРОКУ_BX_ДЛИНОЙ_1024_БАЙТ  :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 push di
                 mov  di,1024;
                 call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;
                 mov  BX,DI;
                 pop  di;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 push di
                 mov  di,1024;
                 call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;
                 mov  BX,DI;
                 pop  di;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 push edi
                 mov  edi,1024;
                 call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;
                 mov  eBX,eDI;
                 pop  edi;
                 ret;
                 END IF;}
;==============================================================================}
СОЗДАТЬ_СТРОКУ_SI_ДЛИНОЙ_1024_БАЙТ  :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 push di;
                 call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_16_БАЙТ;
                 mov  si,di;
                 pop  di;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 push di;
                 call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_16_БАЙТ;
                 mov  si,di;
                 pop  di;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 push edi;
                 call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_16_БАЙТ;
                 mov  esi,edi;
                 pop  edi;
                 ret;
                 END IF;}
;==============================================================================}
СОЗ_СТР_DI_16:;------------------------
СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_16_БАЙТ    :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 mov  di,16;
                 call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;
                 test di,di;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 mov  di,16;
                 call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;
                 test di,di;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 mov  edi,16;
                 call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;
                 test edi,edi;
                 ret;
                 END IF;}
;==============================================================================}
СОЗДАТЬ_СТРОКУ_DX_ДЛИНОЙ_16_БАЙТ    :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 push di;
                 call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_16_БАЙТ;
                 mov  DX,di;
                 pop  di;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 push di;
                 call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_16_БАЙТ;
                 mov  DX,di;
                 pop  di;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 push edi;
                 call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_16_БАЙТ;
                 mov  eDX,edi;
                 pop  edi;
                 ret;
                 END IF;}
;==============================================================================}
СОЗДАТЬ_СТРОКУ_BX_ДЛИНОЙ_16_БАЙТ    :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 push di;
                 call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_16_БАЙТ;
                 mov  BX,di;
                 pop  di;
                 ret;
                 End IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 push di;
                 call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_16_БАЙТ;
                 mov  BX,di;
                 pop  di;
                 ret;
                 End IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 push edi;
                 call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_16_БАЙТ;
                 mov  eBX,edi;
                 pop  edi;
                 ret;
                 End IF;}
;==============================================================================}
СОЗДАТЬ_СТРОКУ_SI_ДЛИНОЙ_16_БАЙТ    :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 push di;
                 call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_16_БАЙТ;
                 mov  SI,di;
                 pop  di;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 push di;
                 call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_16_БАЙТ;
                 mov  SI,di;
                 pop  di;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 push edi;
                 call СОЗДАТЬ_СТРОКУ_DI_ДЛИНОЙ_16_БАЙТ;
                 mov  eSI,edi;
                 pop  edi;
                 ret;
                 END IF;}
;==============================================================================}

УДАЛИТЬ_СТРОКУ_DI                   :;{
                 call ОСВОБОЖДЕНИЕ_УЧАСТКА_ПАМЯТИ_DI;
                 ret;
;==============================================================================}
УДАЛИТЬ_СТРОКУ_SI                   :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 pushad;
                 mov  di,SI;
                 call УДАЛИТЬ_СТРОКУ_DI;
                 popad;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 pushad;
                 mov  di,SI;
                 call УДАЛИТЬ_СТРОКУ_DI;
                 popad;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 pushad;
                 mov  edi,eSI;
                 call УДАЛИТЬ_СТРОКУ_DI;
                 popad;
                 ret;
                 END IF;}
;==============================================================================}
УДАЛИТЬ_СТРОКУ_AX                   :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 pushad;
                 mov  di,ax;
                 call УДАЛИТЬ_СТРОКУ_DI;
                 popad;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 pushad;
                 mov  di,ax;
                 call УДАЛИТЬ_СТРОКУ_DI;
                 popad;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 pushad;
                 mov  edi,eax;
                 call УДАЛИТЬ_СТРОКУ_DI;
                 popad;
                 ret;
                 END IF;}
;==============================================================================}
УДАЛИТЬ_СТРОКУ_DX                   :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 pushad;
                 mov  di,Dx;
                 call УДАЛИТЬ_СТРОКУ_DI;
                 popad;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 pushad;
                 mov  di,Dx;
                 call УДАЛИТЬ_СТРОКУ_DI;
                 popad;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 pushad;
                 mov  edi,eDx;
                 call УДАЛИТЬ_СТРОКУ_DI;
                 popad;
                 ret;
                 END IF;}
;==============================================================================}
УДАЛИТЬ_СТРОКУ_CX                   :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 pushad;
                 mov  di,Cx;
                 call УДАЛИТЬ_СТРОКУ_DI;
                 popad;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 pushad;
                 mov  di,Cx;
                 call УДАЛИТЬ_СТРОКУ_DI;
                 popad;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 pushad;
                 mov  edi,eCx;
                 call УДАЛИТЬ_СТРОКУ_DI;
                 popad;
                 ret;
                 END IF;}
;==============================================================================}
УДАЛИТЬ_СТРОКУ_BX                   :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 pushad;
                 mov  di,bx;
                 call УДАЛИТЬ_СТРОКУ_DI;
                 popad;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 pushad;
                 mov  di,bx;
                 call УДАЛИТЬ_СТРОКУ_DI;
                 popad;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 pushad;
                 mov  edi,ebx;
                 call УДАЛИТЬ_СТРОКУ_DI;
                 popad;
                 ret;
                 END IF;}

;==============================================================================}


ЗАПИСАТЬ_СТРОКУ_AX_В_СТРОКУ_SI        :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  pushad;
                  mov  di,ax;
                  call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI;
                  popad;
                  ret;
                  END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                  pushad;
                  mov  di,ax;
                  call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI;
                  popad;
                  ret;
                  END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                  pushad;
                  mov  edi,eax;
                  call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI;
                  popad;
                  ret;
                  END IF;}
;==============================================================================}

ЗАПИСАТЬ_СТРОКУ_CX_В_СТРОКУ_DX        :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  pushad;
                  mov di,Cx;
                  mov si,Dx;
                  call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI;
                  popad;
                  ret;
                  END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                  pushad;
                  mov di,Cx;
                  mov si,Dx;
                  call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI;
                  popad;
                  ret;
                  END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                  pushad;
                  mov edi,eCx;
                  mov esi,eDx;
                  call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI;
                  popad;
                  ret;
                  END IF;}
;==============================================================================}
ЗАПИСАТЬ_СТРОКУ_CX_В_СТРОКУ_AX        :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  pushad;
                  mov di,Cx;
                  mov si,ax;
                  call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI;
                  popad;
                  ret;
                  END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                  pushad;
                  mov di,Cx;
                  mov si,ax;
                  call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI;
                  popad;
                  ret;
                  END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                  pushad;
                  mov edi,eCx;
                  mov esi,eax;
                  call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI;
                  popad;
                  ret;
                  END IF;}
;==============================================================================}
ЗАПИСАТЬ_СТРОКУ_DX_В_СТРОКУ_CX        :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  pushad;
                  mov di,dx;
                  mov si,cx;
                  call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI;
                  popad;
                  ret;
                  END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                  pushad;
                  mov di,dx;
                  mov si,cx;
                  call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI;
                  popad;
                  ret;
                  END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                  pushad;
                  mov edi,edx;
                  mov esi,ecx;
                  call ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI;
                  popad;
                  ret;
                  END IF;}
;==============================================================================}
ЗАПИСАТЬ_СТРОКУ_DI_В_СТРОКУ_SI        :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  pushad;

                  ;-----------------
                  mov  CX,DI       ;// Запоминаем адрес строки DI в CX
                  CALL ВОЗАРАЩАЕТ_В_DI_ДЛИНУ_СТРОКИ_DI;// ПОлучаем длину строки DI
                  mov  AX,DI       ;// Записываем длину строки DI В AX
                  mov  DI,CX       ;// Востаналвиаем адерс строки DI
                  ;-----------------
.ЦИКЛ:
                  test ax,ax       ;// Проверяем длину строки
                  JZ  .КЦИКЛ       ;// Если счетчик равн нулю выход;
                  mov  CL,[DI]     ;// Читаем символ из строки DI
                  mov  [SI],CL     ;// Записываем символ в строку SI
                  inc  DI          ;// Увеличиваем указатель строки DI
                  INC  SI          ;// Увеличиваем указатель строки SI
                  DEC  AX          ;// Уменьшаем счетчик количества скопированых букв
                  JMP .ЦИКЛ        ;
.КЦИКЛ:
                  mov  Byte [SI],0 ;
                  popad ;
                  ret   ;
                  END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                  pushad;

                  ;-----------------
                  mov  CX,DI       ;// Запоминаем адрес строки DI в CX
                  CALL ВОЗАРАЩАЕТ_В_DI_ДЛИНУ_СТРОКИ_DI;// ПОлучаем длину строки DI
                  mov  AX,DI       ;// Записываем длину строки DI В AX
                  mov  DI,CX       ;// Востаналвиаем адерс строки DI
                  ;-----------------
.ЦИКЛ:
                  test ax,ax       ;// Проверяем длину строки
                  JZ  .КЦИКЛ       ;// Если счетчик равн нулю выход;
                  mov  CL,[DI]     ;// Читаем символ из строки DI
                  mov  [SI],CL     ;// Записываем символ в строку SI
                  inc  DI          ;// Увеличиваем указатель строки DI
                  INC  SI          ;// Увеличиваем указатель строки SI
                  DEC  AX          ;// Уменьшаем счетчик количества скопированых букв
                  JMP .ЦИКЛ        ;
.КЦИКЛ:
                  mov  Byte [SI],0 ;
                  popad ;
                  ret   ;
                  END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                  pushad;

                  ;-----------------
                  mov  ECX,EDI       ;// Запоминаем адрес строки DI в CX
                  CALL ВОЗАРАЩАЕТ_В_DI_ДЛИНУ_СТРОКИ_DI;// ПОлучаем длину строки DI
                  mov  EAX,EDI       ;// Записываем длину строки DI В AX
                  mov  EDI,ECX       ;// Востаналвиаем адерс строки DI
                  ;-----------------
.ЦИКЛ:
                  test eax,eax       ;// Проверяем длину строки
                  JZ  .КЦИКЛ       ;// Если счетчик равн нулю выход;
                  mov  CL,[eDI]     ;// Читаем символ из строки DI
                  mov  [eSI],CL     ;// Записываем символ в строку SI
                  inc  eDI          ;// Увеличиваем указатель строки DI
                  INC  eSI          ;// Увеличиваем указатель строки SI
                  DEC  eAX          ;// Уменьшаем счетчик количества скопированых букв
                  JMP .ЦИКЛ        ;
.КЦИКЛ:
                  mov  Byte [eSI],0 ;
                  popad ;
                  ret   ;
                  END IF;}
;==============================================================================}


ЕСЛИ_СТРОКА_AX_ЧИСЛО_ФЛАГ_Z_1      :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                push si;
                mov  si,ax;
                call ЕСЛИ_СТРОКА_SI_ЧИСЛО_ФЛАГ_Z_1;
                pop  si;
                ret    ;
                END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                push si;
                mov  si,ax;
                call ЕСЛИ_СТРОКА_SI_ЧИСЛО_ФЛАГ_Z_1;
                pop  si;
                ret    ;
                END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                push esi;
                mov  esi,eax;
                call ЕСЛИ_СТРОКА_SI_ЧИСЛО_ФЛАГ_Z_1;
                pop  esi;
                ret    ;
                END IF;}
;==============================================================================}
ЕСЛИ_СТРОКА_CX_ЧИСЛО_ФЛАГ_Z_1      :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                push si;
                mov  si,Cx;
                call ЕСЛИ_СТРОКА_SI_ЧИСЛО_ФЛАГ_Z_1;
                pop  si;
                ret    ;
                END IF ;}
IF  (ПЛАТФОРМА = T16)   ;{
                push si;
                mov  si,Cx;
                call ЕСЛИ_СТРОКА_SI_ЧИСЛО_ФЛАГ_Z_1;
                pop  si;
                ret    ;
                END IF ;}
IF  (ПЛАТФОРМА = T32)   ;{
                push esi;
                mov  esi,eCx;
                call ЕСЛИ_СТРОКА_SI_ЧИСЛО_ФЛАГ_Z_1;
                pop  esi;
                ret    ;
                END IF ;}
;==============================================================================}
ЕСЛИ_СТРОКА_DX_ЧИСЛО_ФЛАГ_Z_1      :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                push si;
                mov  si,Dx;
                call ЕСЛИ_СТРОКА_SI_ЧИСЛО_ФЛАГ_Z_1;
                pop  si;
                ret    ;
                END IF ;}
IF  (ПЛАТФОРМА = T16)   ;{
                push si;
                mov  si,Dx;
                call ЕСЛИ_СТРОКА_SI_ЧИСЛО_ФЛАГ_Z_1;
                pop  si;
                ret    ;
                END IF ;}
IF  (ПЛАТФОРМА = T32)   ;{
                push esi;
                mov  esi,eDx;
                call ЕСЛИ_СТРОКА_SI_ЧИСЛО_ФЛАГ_Z_1;
                pop  esi;
                ret    ;
                END IF ;}
;==============================================================================}
ЕСЛИ_СТРОКА_SI_ЧИСЛО_ФЛАГ_Z_1      :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 pushad;
.ЦИКЛ:
                 mov  al,[si];
                 test al,al  ;
                 jz  .ЧИСЛО;
                 call ЕСЛИ_В_AL_ЦИФРА_ФЛАГ_Z_1
                 jz  .НЕ_ЧИСЛО;
                 inc  si;
                 jmp .ЦИКЛ;
.НЕ_ЧИСЛО:
                 mov  al,0;
                 test al,al;
                 jmp .ВЫХОД;
.ЧИСЛО:
                 mov al,1;
                 test al,al;
.ВЫХОД:
                 popad;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 pushad;
.ЦИКЛ:
                 mov  al,[si];
                 test al,al  ;
                 jz  .ЧИСЛО;
                 call ЕСЛИ_В_AL_ЦИФРА_ФЛАГ_Z_1
                 jz  .НЕ_ЧИСЛО;
                 inc  si;
                 jmp .ЦИКЛ;
.НЕ_ЧИСЛО:
                 mov  al,0;
                 test al,al;
                 jmp .ВЫХОД;
.ЧИСЛО:
                 mov al,1;
                 test al,al;
.ВЫХОД:
                 popad;
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 pushad;
.ЦИКЛ:
                 mov  al,[esi];
                 test al,al  ;
                 jz  .ЧИСЛО;
                 call ЕСЛИ_В_AL_ЦИФРА_ФЛАГ_Z_1
                 jz  .НЕ_ЧИСЛО;
                 inc  esi;
                 jmp .ЦИКЛ;
.НЕ_ЧИСЛО:
                 mov  al,0;
                 test al,al;
                 jmp .ВЫХОД;
.ЧИСЛО:
                 mov  al,1;
                 test al,al;
.ВЫХОД:
                 popad;
                 ret;
                 END IF;}
;==============================================================================}


УДАЛИТЬ_БУКВУ_В_НАЧАЛЕ_СТРОКИ       :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  pushad           ;
                  mov  si,di       ;
                  inc  di          ;
                  mov  al,[si]     ;
                  test al,al       ;
                  jz  .КЦИКЛ       ;

.ЦИКЛ:            mov  al,[di]     ;
                  mov  [SI],Al     ;
                  test al,al       ;
                  jz  .КЦИКЛ       ;
                  inc  di          ;
                  inc  si          ;
                  jmp .ЦИКЛ        ;
.КЦИКЛ:

                  popad            ;
                  ret              ;
                  END IF           ;}
IF  (ПЛАТФОРМА = T16)   ;{
                  pushad           ;
                  mov  si,di       ;
                  inc  di          ;
                  mov  al,[si]     ;
                  jz  .КЦИКЛ       ;

.ЦИКЛ:            mov  al,[di]     ;
                  mov  [SI],Al     ;
                  test al,al       ;
                  jz  .КЦИКЛ       ;
                  inc  di          ;
                  inc  si          ;
                  jmp .ЦИКЛ        ;
.КЦИКЛ:

                  popad            ;
                  ret              ;
                  END IF           ;}
IF  (ПЛАТФОРМА = T32)   ;{
                  pushad           ;
                  mov  esi,edi     ;
                  inc  edi         ;
                  mov  al,[esi]    ;
                  jz  .КЦИКЛ       ;

.ЦИКЛ:            mov  al,[edi]    ;
                  mov  [eSI],Al    ;
                  test al,al       ;
                  jz  .КЦИКЛ       ;
                  inc  edi         ;
                  inc  esi         ;
                  jmp .ЦИКЛ        ;
.КЦИКЛ:

                  popad            ;
                  ret              ;
                  END IF           ;}
;}
УДАЛИТЬ_БУКВУ_В_КОНЦЕ_СТРОКИ_AX     :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  push di          ;
                  mov  di,ax;
                  Call УДАЛИТЬ_БУКВУ_В_КОНЦЕ_СТРОКИ;// Перемещаемся в конец строки
                  pop  di          ;
                  ret              ;
                  END IF           ;}
IF  (ПЛАТФОРМА = T16)   ;{
                  push di          ;
                  mov  di,ax;
                  Call УДАЛИТЬ_БУКВУ_В_КОНЦЕ_СТРОКИ;// Перемещаемся в конец строки
                  pop  di          ;
                  ret              ;
                  END IF           ;}
IF  (ПЛАТФОРМА = T32)   ;{
                  push edi          ;
                  mov  edi,eax;
                  Call УДАЛИТЬ_БУКВУ_В_КОНЦЕ_СТРОКИ;// Перемещаемся в конец строки
                  pop  edi          ;
                  ret              ;
                  END IF           ;}
;==============================================================================}
УДАЛИТЬ_БУКВУ_В_КОНЦЕ_СТРОКИ_SI     :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  push di          ;
                  mov  di,si;
                  Call УДАЛИТЬ_БУКВУ_В_КОНЦЕ_СТРОКИ;// Перемещаемся в конец строки
                  pop  di          ;
                  ret              ;
                  END IF           ;}
IF  (ПЛАТФОРМА = T16)   ;{
                  push di          ;
                  mov  di,si;
                  Call УДАЛИТЬ_БУКВУ_В_КОНЦЕ_СТРОКИ;// Перемещаемся в конец строки
                  pop  di          ;
                  ret              ;
                  END IF           ;}
IF  (ПЛАТФОРМА = T32)   ;{
                  push edi          ;
                  mov  edi,esi      ;
                  Call УДАЛИТЬ_БУКВУ_В_КОНЦЕ_СТРОКИ;// Перемещаемся в конец строки
                  pop  edi         ;
                  ret              ;
                  END IF           ;}
;==============================================================================}
УДАЛИТЬ_БУКВУ_В_КОНЦЕ_СТРОКИ        :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  push di          ;
                  Call ВОЗВРАЩАЕТ_АДРЕС_DI_0БАЙТА_СТРОКИ_DI;// Перемещаемся в конец строки
                  dec  DI          ;// перемещаемся на 1 символ назад
                  mov  byte [DI],0 ;// Записываем символ  0 вместо последней буквы в строке
                  pop  di          ;
                  ret              ;
                  END IF           ;}
IF  (ПЛАТФОРМА = T16)   ;{
                  push di          ;
                  Call ВОЗВРАЩАЕТ_АДРЕС_DI_0БАЙТА_СТРОКИ_DI;// Перемещаемся в конец строки
                  dec  DI          ;// перемещаемся на 1 символ назад
                  mov  byte [DI],0 ;// Записываем символ  0 вместо последней буквы в строке
                  pop  di          ;
                  ret              ;
                  END IF           ;}
IF  (ПЛАТФОРМА = T32)   ;{
                  push edi          ;
                  Call ВОЗВРАЩАЕТ_АДРЕС_DI_0БАЙТА_СТРОКИ_DI;// Перемещаемся в конец строки
                  dec  eDI          ;// перемещаемся на 1 символ назад
                  mov  byte [eDI],0 ;// Записываем символ  0 вместо последней буквы в строке
                  pop  edi          ;
                  ret              ;
                  END IF           ;}
;==============================================================================}
ВЕРНУТЬ_КОНЕЦ_СТРОКИ_SI_В_SI        :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 push cx     ;
.ЦИКЛ:           mov  cl,[si];
                 test cl,cl  ;// Если конец строки то выход
                 JZ  .КЦИКЛ  ;
                 inc  sI     ;// Увеличиывкем указатель на читаемый символ
                 Jmp .ЦИКЛ   ;
.КЦИКЛ:
                 pop cx      ;
                 ret         ;
                 END IF      ;}
IF  (ПЛАТФОРМА = T16)   ;{
                 push cx     ;
.ЦИКЛ:           mov  cl,[si];
                 test cl,cl  ;// Если конец строки то выход
                 JZ  .КЦИКЛ  ;
                 inc  sI     ;// Увеличиывкем указатель на читаемый символ
                 Jmp .ЦИКЛ   ;
.КЦИКЛ:
                 pop cx      ;
                 ret         ;
                 END IF      ;}
IF  (ПЛАТФОРМА = T32)   ;{
                 push ecx     ;
.ЦИКЛ:           mov  cl,[esi];
                 test cl,cl   ;// Если конец строки то выход
                 JZ  .КЦИКЛ   ;
                 inc  esI     ;// Увеличиывкем указатель на читаемый символ
                 Jmp .ЦИКЛ    ;
.КЦИКЛ:
                 pop ecx      ;
                 ret          ;
                 END IF       ;}
;==============================================================================}
СРАВНИТЬ_СТРОКИ_SI_DI               :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  pushad;

.ЦИКЛ:            mov  al,[di]     ;
                  mov  ah,[si]     ;
                  cmp  al,ah       ;
                  jnz .НЕРАВНО     ;
                  TEST al,al       ;
                  JZ  .РАВНО       ;

                  INC  SI          ;
                  INC  DI          ;
                  JMP .ЦИКЛ        ;
.РАВНО:
                  mov  al,1        ;
                  test al,al       ;
                  jmp .ВЫХОД       ;

.НЕРАВНО:
                  mov  al,0        ;
                  test al,al       ;
                  jmp .ВЫХОД       ;
.ВЫХОД:
                  popad            ;
                  ret              ;
                  END IF           ;}
IF  (ПЛАТФОРМА = T16)   ;{
                  pushad;

.ЦИКЛ:            mov  al,[di]     ;
                  mov  ah,[si]     ;
                  cmp  al,ah       ;
                  jnz .НЕРАВНО     ;
                  TEST al,al       ;
                  JZ  .РАВНО       ;

                  INC  SI          ;
                  INC  DI          ;
                  JMP .ЦИКЛ        ;
.РАВНО:
                  mov  al,1        ;
                  test al,al       ;
                  jmp .ВЫХОД       ;

.НЕРАВНО:
                  mov  al,0        ;
                  test al,al       ;
                  jmp .ВЫХОД       ;
.ВЫХОД:
                  popad            ;
                  ret              ;
                  END IF           ;}
IF  (ПЛАТФОРМА = T32)   ;{
                  pushad;

.ЦИКЛ:            mov  al,[edi]     ;
                  mov  ah,[esi]     ;
                  cmp  al,ah       ;
                  jnz .НЕРАВНО     ;
                  TEST al,al       ;
                  JZ  .РАВНО       ;

                  INC  eSI          ;
                  INC  eDI          ;
                  JMP .ЦИКЛ        ;
.РАВНО:
                  mov  al,1        ;
                  test al,al       ;
                  jmp .ВЫХОД       ;

.НЕРАВНО:
                  mov  al,0        ;
                  test al,al       ;
                  jmp .ВЫХОД       ;
.ВЫХОД:
                  popad            ;
                  ret              ;
                  END IF           ;}
;{ ОПИСАНИЕ
;}
;==============================================================================}
ВСТАВКА_СИМВОЛА_AL_ПО_АДРЕСУ_SI_ДО_0:;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  pushad	   ; Вставляет  символ в строку позиция
                  mov  cl,[si]	   ;
                  mov  [si],al	   ;

.ЦИКЛ:	          inc   si          ;
                  mov   al,[si]	   ;
                  mov   [si],cl	   ;
                  mov   cl,al	   ;
                  test  cl,cl	   ;
                  jz   .КЦИКЛА	   ;
                  jmp  .ЦИКЛ	   ;
.КЦИКЛА:          inc   si	   ;
                  mov   byte[si],0  ;
.ВЫХОД:
                  popad	   ;
                  ret	   ;
                  END IF   ;}
IF  (ПЛАТФОРМА = T16)   ;{
                  pushad	   ; Вставляет  символ в строку позиция
                  mov  cl,[si]	   ;
                  mov  [si],al	   ;

.ЦИКЛ:	          inc   si          ;
                  mov   al,[si]	   ;
                  mov   [si],cl	   ;
                  mov   cl,al	   ;
                  test  cl,cl	   ;
                  jz   .КЦИКЛА	   ;
                  jmp  .ЦИКЛ	   ;
.КЦИКЛА:          inc   si	   ;
                  mov   byte[si],0  ;
.ВЫХОД:
                  popad	   ;
                  ret	   ;
                  END IF   ;}
IF  (ПЛАТФОРМА = T32)   ;{
                  pushad	   ; Вставляет  символ в строку позиция
                  mov  cl,[esi]	   ;
                  mov  [esi],al	   ;

.ЦИКЛ:	          inc   esi          ;
                  mov   al,[esi]	   ;
                  mov   [esi],cl	   ;
                  mov   cl,al	   ;
                  test  cl,cl	   ;
                  jz   .КЦИКЛА	   ;
                  jmp  .ЦИКЛ	   ;
.КЦИКЛА:          inc   esi	   ;
                  mov   byte[esi],0  ;
.ВЫХОД:
                  popad	   ;
                  ret	   ;
                  END IF   ;}
;==============================================================================}
УДАЛЕНИЕ_ИЗ_АДРЕСА_SI_СИМВОЛА_ДО_0  :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                pushad    	; Удаляет символ из строки указатель на удаляемый символ SI
                mov  al,[si]    ;
                test al,al      ;
                JZ  .КЦИКЛ	;
                dec  si	        ;
                mov  di,si	;
                inc  si	        ;
.ЦИКЛ:          mov  al,[si]	;
                mov  [di],al	;
                inc  si	        ;
                inc  di	        ;
                test al,al	;
                jnz .ЦИКЛ	;
.КЦИКЛ:
                popad	;
                ret	;
                END IF  ;}
IF  (ПЛАТФОРМА = T16)   ;{
                pushad    	; Удаляет символ из строки указатель на удаляемый символ SI
                mov  al,[si]    ;
                test al,al      ;
                JZ  .КЦИКЛ	;
                dec  si	        ;
                mov  di,si	;
                inc  si	        ;
.ЦИКЛ:          mov  al,[si]	;
                mov  [di],al	;
                inc  si	        ;
                inc  di	        ;
                test al,al	;
                jnz .ЦИКЛ	;
.КЦИКЛ:
                popad	;
                ret	;
                END IF  ;}
IF  (ПЛАТФОРМА = T32)   ;{
                pushad    	; Удаляет символ из строки указатель на удаляемый символ SI
                mov  al,[esi]   ;
                test al,al      ;
                JZ  .КЦИКЛ	;
                dec  esi	;
                mov  edi,esi	;
                inc  esi	;
.ЦИКЛ:          mov  al,[esi]	;
                mov  [edi],al	;
                inc  esi	;
                inc  edi	;
                test al,al	;
                jnz .ЦИКЛ	;
.КЦИКЛ:
                popad	;
                ret	;
                END IF  ;}
;==============================================================================}
НАЙТИ_КОНЕЦ_СТРОКИ_С_АДРЕСА_SI      :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 push cx;
.ЦИКЛ:           mov  cl,[si];
                 test cl,cl  ;// Если конец строки то выход
                 JZ  .КЦИКЛ  ;
                 inc  sI     ;// Увеличиывкем указатель на читаемый символ
                 Jmp .ЦИКЛ   ;
.КЦИКЛ:
                 pop cx;
                 ret   ;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 push cx;
.ЦИКЛ:           mov  cl,[si];
                 test cl,cl  ;// Если конец строки то выход
                 JZ  .КЦИКЛ  ;
                 inc  sI     ;// Увеличиывкем указатель на читаемый символ
                 Jmp .ЦИКЛ   ;
.КЦИКЛ:
                 pop cx;
                 ret   ;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 push ecx;
.ЦИКЛ:           mov  cl,[esi];
                 test cl,cl  ;// Если конец строки то выход
                 JZ  .КЦИКЛ  ;
                 inc  esI     ;// Увеличиывкем указатель на читаемый символ
                 Jmp .ЦИКЛ   ;
.КЦИКЛ:
                 pop ecx;
                 ret   ;
                 END IF;}
;==============================================================================}
ПОИСК_БУКВЫ_AL_В_СТРОКЕ_SI          :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  pushad;
.ЦИКЛ:            mov  ah,[si];
                  test ah,ah  ;
                  jz  .КЦИКЛ  ;
                  cmp  al,ah  ;
                  jz .ЕСТЬ    ;
                  inc  SI     ;
                  jmp .ЦИКЛ   ;
.КЦИКЛ:
                  mov  al,0   ;
                  test al,al  ;
                  jmp .ВЫХОД  ;

.ЕСТЬ:
                  mov  al,1   ;
                  test al,al  ;
.ВЫХОД:
                  popad       ;
                  ret         ;
                  END IF      ;}
IF  (ПЛАТФОРМА = T16)   ;{
                  pushad;
.ЦИКЛ:            mov  ah,[si];
                  test ah,ah  ;
                  jz  .КЦИКЛ  ;
                  cmp  al,ah  ;
                  jz .ЕСТЬ    ;
                  inc  SI     ;
                  jmp .ЦИКЛ   ;
.КЦИКЛ:
                  mov  al,0   ;
                  test al,al  ;
                  jmp .ВЫХОД  ;

.ЕСТЬ:
                  mov  al,1   ;
                  test al,al  ;
.ВЫХОД:
                  popad       ;
                  ret         ;
                  END IF      ;}
IF  (ПЛАТФОРМА = T32)   ;{
                  pushad;
.ЦИКЛ:            mov  ah,[esi];
                  test ah,ah  ;
                  jz  .КЦИКЛ  ;
                  cmp  al,ah  ;
                  jz .ЕСТЬ    ;
                  inc  eSI     ;
                  jmp .ЦИКЛ   ;
.КЦИКЛ:
                  mov  al,0   ;
                  test al,al  ;
                  jmp .ВЫХОД  ;

.ЕСТЬ:
                  mov  al,1   ;
                  test al,al  ;
.ВЫХОД:
                  popad       ;
                  ret         ;
                  END IF      ;}
;==============================================================================}
ПОИСК_ДВОЙНОЙ_БУКВЫ_AX_В_СТРОКЕ_SI  :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  pushad;
.ЦИКЛ:            mov  cx,[si];
                  test cx,cx ;
                  jz  .КЦИКЛ ;
                  test ch,ch ;
                  jz  .КЦИКЛ ;
                  cmp  ax,cx ;
                  jz  .ЕСТЬ  ;
                  inc  SI    ;
                  inc  SI    ;
                  jmp .ЦИКЛ  ;
.КЦИКЛ:
                  mov  al,0  ;
                  test al,al ;
                  jmp .ВЫХОД ;

.ЕСТЬ:
                  mov  al,1  ;
                  test al,al ;
.ВЫХОД:
                  popad      ;
                  ret        ;
                  END IF     ;}
IF  (ПЛАТФОРМА = T16)   ;{
                  pushad;
.ЦИКЛ:            mov  cx,[si];
                  test cx,cx ;
                  jz  .КЦИКЛ ;
                  test ch,ch ;
                  jz  .КЦИКЛ ;
                  cmp  ax,cx ;
                  jz  .ЕСТЬ  ;
                  inc  SI    ;
                  inc  SI    ;
                  jmp .ЦИКЛ  ;
.КЦИКЛ:
                  mov  al,0  ;
                  test al,al ;
                  jmp .ВЫХОД ;

.ЕСТЬ:
                  mov  al,1  ;
                  test al,al ;
.ВЫХОД:
                  popad      ;
                  ret        ;
                  END IF     ;}
IF  (ПЛАТФОРМА = T32)   ;{
                  pushad;
.ЦИКЛ:            mov  cx,[si];
                  test cx,cx ;
                  jz  .КЦИКЛ ;
                  test ch,ch ;
                  jz  .КЦИКЛ ;
                  cmp  ax,cx ;
                  jz  .ЕСТЬ  ;
                  inc  SI    ;
                  inc  SI    ;
                  jmp .ЦИКЛ  ;
.КЦИКЛ:
                  mov  al,0  ;
                  test al,al ;
                  jmp .ВЫХОД ;

.ЕСТЬ:
                  mov  al,1  ;
                  test al,al ;
.ВЫХОД:
                  popad      ;
                  ret        ;
                  END IF     ;}
;==============================================================================}

ПОИСК_ДВОЙНОЙ_БУКВЫ_AX_В_СТРОКЕ_SI_ШАГ2 :;{ Возвращает CX 2 цифру в BX Номер в списке
IF  (ПЛАТФОРМА = ДОС)   ;{
                  pushad;
                  mov  bx,1  ;
.ЦИКЛ:            mov  cx,[si];
                  test cx,cx ;
                  jz  .КЦИКЛ ;
                  test ch,ch ;
                  jz  .КЦИКЛ ;
                  cmp  ax,cx ;
                  jz  .ЕСТЬ  ;
                  inc  SI    ;
                  inc  SI    ;
                  inc  SI    ;
                  inc  SI    ;
                  inc  bx    ;
                  jmp .ЦИКЛ  ;
.КЦИКЛ:
                  mov  al,0  ;
                  test al,al ;
                  jmp .ВЫХОД ;

.ЕСТЬ:

                  inc  SI    ;
                  inc  SI    ;
                  mov  cx,[si];
                  call ВОЗВРАТИТЬ_CX;
                  call ВОЗВРАТИТЬ_BX;
                  mov  al,1  ;
                  test al,al ;
.ВЫХОД:
                  popad      ;
                  ret        ;
                  END IF     ;}
IF  (ПЛАТФОРМА = T16)   ;{
                  pushad;
                  mov  bx,1  ;
.ЦИКЛ:            mov  cx,[si];
                  test cx,cx ;
                  jz  .КЦИКЛ ;
                  test ch,ch ;
                  jz  .КЦИКЛ ;
                  cmp  ax,cx ;
                  jz  .ЕСТЬ  ;
                  inc  SI    ;
                  inc  SI    ;
                  inc  SI    ;
                  inc  SI    ;
                  inc  bx    ;
                  jmp .ЦИКЛ  ;
.КЦИКЛ:
                  mov  al,0  ;
                  test al,al ;
                  jmp .ВЫХОД ;

.ЕСТЬ:

                  inc  SI    ;
                  inc  SI    ;
                  mov  cx,[si];
                  call ВОЗВРАТИТЬ_CX;
                  call ВОЗВРАТИТЬ_BX;
                  mov  al,1  ;
                  test al,al ;
.ВЫХОД:
                  popad      ;
                  ret        ;
                  END IF     ;}
IF  (ПЛАТФОРМА = T32)   ;{
                  pushad;
                  mov  ebx,1  ;
.ЦИКЛ:            mov  cx,[si];
                  test cx,cx ;
                  jz  .КЦИКЛ ;
                  test ch,ch ;
                  jz  .КЦИКЛ ;
                  cmp  ax,cx ;
                  jz  .ЕСТЬ  ;
                  inc  SI    ;
                  inc  SI    ;
                  inc  SI    ;
                  inc  SI    ;
                  inc  bx    ;
                  jmp .ЦИКЛ  ;
.КЦИКЛ:
                  mov  al,0  ;
                  test al,al ;
                  jmp .ВЫХОД ;

.ЕСТЬ:

                  inc  SI    ;
                  inc  SI    ;
                  mov  cx,[si];
                  call ВОЗВРАТИТЬ_CX;
                  call ВОЗВРАТИТЬ_BX;
                  mov  al,1  ;
                  test al,al ;
.ВЫХОД:
                  popad      ;
                  ret        ;
                  END IF     ;}
;==============================================================================}


ПОИСК_AX_В_СТР_SI:;--------------------
ПОИСК_ДВОЙНОЙ_ЦИФРЫ_AX_В_СТРОКЕ_SI  :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                  pushad;
.ЦИКЛ:            mov  cx,[si];
                  test cx,cx ;
                  jz  .КЦИКЛ ;
                  cmp  ax,cx ;
                  jz  .ЕСТЬ  ;
                  inc  SI    ;
                  inc  SI    ;
                  jmp .ЦИКЛ  ;
.КЦИКЛ:
                  mov  al,0  ;
                  test al,al ;
                  jmp .ВЫХОД ;

.ЕСТЬ:
                  mov  al,1  ;
                  test al,al ;
.ВЫХОД:
                  popad      ;
                  ret        ;
                  END IF     ;}
IF  (ПЛАТФОРМА = T16)   ;{
                  pushad;
.ЦИКЛ:            mov  cx,[si];
                  test cx,cx ;
                  jz  .КЦИКЛ ;
                  cmp  ax,cx ;
                  jz  .ЕСТЬ  ;
                  inc  SI    ;
                  inc  SI    ;
                  jmp .ЦИКЛ  ;
.КЦИКЛ:
                  mov  al,0  ;
                  test al,al ;
                  jmp .ВЫХОД ;

.ЕСТЬ:
                  mov  al,1  ;
                  test al,al ;
.ВЫХОД:
                  popad      ;
                  ret        ;
                  END IF     ;}
IF  (ПЛАТФОРМА = T32)   ;{
                  pushad;
.ЦИКЛ:            mov  cx,[esi];
                  test cx,cx ;
                  jz  .КЦИКЛ ;
                  cmp  ax,cx ;
                  jz  .ЕСТЬ  ;
                  inc  eSI    ;
                  inc  eSI    ;
                  jmp .ЦИКЛ  ;
.КЦИКЛ:
                  mov  al,0  ;
                  test al,al ;
                  jmp .ВЫХОД ;

.ЕСТЬ:
                  mov  al,1  ;
                  test al,al ;
.ВЫХОД:
                  popad      ;
                  ret        ;
                  END IF     ;}
;==============================================================================}

ВОЗАРАЩАЕТ_В_DI_ДЛИНУ_СТРОКИ_DI     :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 push ax;
                 mov  ax,DI;
                 Call ВОЗВРАЩАЕТ_АДРЕС_DI_0БАЙТА_СТРОКИ_DI;// Перемещаемся в конец строки
                 sub  DI,ax;
                 test di,di;
                 pop  ax ;
                 ret   ;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 push ax;
                 mov  ax,DI;
                 Call ВОЗВРАЩАЕТ_АДРЕС_DI_0БАЙТА_СТРОКИ_DI;// Перемещаемся в конец строки
                 sub  DI,ax;
                 test di,di;
                 pop  ax ;
                 ret   ;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 push eax;
                 mov  eax,eDI;
                 Call ВОЗВРАЩАЕТ_АДРЕС_DI_0БАЙТА_СТРОКИ_DI;// Перемещаемся в конец строки
                 sub  eDI,eax;
                 test edi,edi;
                 pop  eax ;
                 ret   ;
                 END IF;}
;==============================================================================}
ДЛИНА_СТРОКИ_DX_В_CX:                ;{
IF  (ПЛАТФОРМА = ДОС)   ;{
     push di;
     mov  di,dx;
     call ВОЗАРАЩАЕТ_В_CX_ДЛИНУ_СТРОКИ_DI;
     pop  di;
     ret;
     END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
     push di;
     mov  di,dx;
     call ВОЗАРАЩАЕТ_В_CX_ДЛИНУ_СТРОКИ_DI;
     pop  di;
     ret;
     END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
     push eDi;
     mov  edi,edx;
     call ВОЗАРАЩАЕТ_В_CX_ДЛИНУ_СТРОКИ_DI;
     pop  edi;
     ret;
     END IF;}
;}
ДЛИНА_СТРОКИ_AX_В_CX:                ;{
IF  (ПЛАТФОРМА = ДОС)   ;{
     push di;
     mov  di,ax;
     call ВОЗАРАЩАЕТ_В_CX_ДЛИНУ_СТРОКИ_DI;
     pop  di;
     ret;
     END iF;}
IF  (ПЛАТФОРМА = T16)   ;{
     push di;
     mov  di,ax;
     call ВОЗАРАЩАЕТ_В_CX_ДЛИНУ_СТРОКИ_DI;
     pop  di;
     ret;
     END iF;}
IF  (ПЛАТФОРМА = T32)   ;{
     push edi;
     mov  edi,eax;
     call ВОЗАРАЩАЕТ_В_CX_ДЛИНУ_СТРОКИ_DI;
     pop  edi;
     ret;
     END iF;}
;}
ВОЗАРАЩАЕТ_В_CX_ДЛИНУ_СТРОКИ_DI     :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 push ax;
                 push di;
                 mov  ax,DI;
                 Call ВОЗВРАЩАЕТ_АДРЕС_DI_0БАЙТА_СТРОКИ_DI;// Перемещаемся в конец строки
                 sub  DI,ax;
                 mov  cx,di;
                 test cx,cx;
                 pop  di ;
                 pop  ax ;
                 ret   ;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 push ax;
                 push di;
                 mov  ax,DI;
                 Call ВОЗВРАЩАЕТ_АДРЕС_DI_0БАЙТА_СТРОКИ_DI;// Перемещаемся в конец строки
                 sub  DI,ax;
                 mov  cx,di;
                 test cx,cx;
                 pop  di ;
                 pop  ax ;
                 ret   ;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 push eax;
                 push edi;
                 mov  eax,eDI;
                 Call ВОЗВРАЩАЕТ_АДРЕС_DI_0БАЙТА_СТРОКИ_DI;// Перемещаемся в конец строки
                 sub  eDI,eax;
                 mov  ecx,edi;
                 test ecx,ecx;
                 pop  edi ;
                 pop  eax ;
                 ret   ;
                 END IF;}
;==============================================================================}
ВОЗВРАЩАЕТ_АДРЕС_DI_0БАЙТА_СТРОКИ_DI:;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                 push cx;
.ЦИКЛ:           mov  cl,[di];
                 test cl,cl  ;// Если конец строки то выход
                 JZ  .КЦИКЛ  ;
                 inc  DI     ;// Увеличиывкем указатель на читаемый символ
                 Jmp .ЦИКЛ   ;
.КЦИКЛ:
                 pop cx;
                 ret   ;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 push cx;
.ЦИКЛ:           mov  cl,[di];
                 test cl,cl  ;// Если конец строки то выход
                 JZ  .КЦИКЛ  ;
                 inc  DI     ;// Увеличиывкем указатель на читаемый символ
                 Jmp .ЦИКЛ   ;
.КЦИКЛ:
                 pop cx;
                 ret   ;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 push ecx;
.ЦИКЛ:           mov  cl,[edi];
                 test cl,cl  ;// Если конец строки то выход
                 JZ  .КЦИКЛ  ;
                 inc  eDI     ;// Увеличиывкем указатель на читаемый символ
                 Jmp .ЦИКЛ   ;
.КЦИКЛ:
                 pop ecx;
                 ret   ;
                 END IF;}
;==============================================================================}

ЧИТ_СЛОВО_С_SI_В_DX                 :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
    pushad                                 ;
    call ЧИТАЕТ_СЛОВО_С_АДР_SI_ВОЗ_СЛОВО_DI;
    mov  DX,DI                             ;
    call ВОЗВРАТИТЬ_DX                     ; //  Возврвщает адрес на строку
    test dx,dx                             ; //  Содержащию прочитаное слово
    popad                                  ; //  Если прочитать ек удалося JZ
    ret                                    ;
    END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
    pushad                                 ;
    call ЧИТАЕТ_СЛОВО_С_АДР_SI_ВОЗ_СЛОВО_DI;
    mov  DX,DI                             ;
    call ВОЗВРАТИТЬ_DX                     ; //  Возврвщает адрес на строку
    test dx,dx                             ; //  Содержащию прочитаное слово
    popad                                  ; //  Если прочитать ек удалося JZ
    ret                                    ;
    END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
    pushad                                 ;
    call ЧИТАЕТ_СЛОВО_С_АДР_SI_ВОЗ_СЛОВО_DI;
    mov  EDX,EDI                             ;
    call ВОЗВРАТИТЬ_DX                     ; //  Возврвщает адрес на строку
    test Edx,Edx                             ; //  Содержащию прочитаное слово
    popad                                  ; //  Если прочитать ек удалося JZ
    ret                                    ;
    END IF;}
;}
ЧИТАЕТ_СЛОВО_С_АДР_SI_ВОЗ_СЛОВО_DI  :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
            pushad                ; { ОПИСАНИЕ
            ;-------------------------------------------------------------------
            ; SI - Указатель на символ с котрого нужно попытаться прочитать
            ; DI - Возвращаемое прочитаное слово в случае неудачи 0
            ; Длина слова максимально 16 байт
            ;------------------------------------------------------------------}

            ;---------------------; // Красота ))))))
            mov  DI,0             ; // ПО умолчанию резульатт 0
            ;---------------------;
            test si,si            ; // А почему бы тут не устроить проверку на ноль ?
            jz  .ВЫХОД            ; // Если у читаемого символа адрес 0 выход
            ;---------------------;
            mov  al,[si]          ;
            call AL_ЭТО_БУКВА     ; // Проверяет являеться ли символ буквой
            jz  .ВЫХОД            ; // Если не буква то выход
            ;---------------------;
            call СОЗ_СТР_DI_16    ; // Создаем строку с ответом DI длиной 16
            jz  .ВЫХОД            ; // Если создать строку не удалося выход
            ;---------------------;
.ЦИКЛ:
            ;---------------------;
            mov  al,[si]          ;
            call AL_ЭТО_БУКВА     ; // ПРоверяем являеться ли символ буквой
            jz  .КЦИКЛ            ;
            ;---------------------;
            call ДОБ_AL_В_СТРО_DI ; // Добавляем буку AL в конец строки DI
            ;---------------------;
            inc  SI               ; // Увеличиваем читемый символ
            ;---------------------;
            jmp .ЦИКЛ             ;
            ;---------------------;
.КЦИКЛ:
.ВЫХОД:

            ;---------------------;
            call ВОЗВРАТИТЬ_DI    ;
            test di,di            ;
            popad                 ;
            ret                   ;
            END IF                ;}
IF  (ПЛАТФОРМА = T16)   ;{
            pushad                ; { ОПИСАНИЕ
            ;-------------------------------------------------------------------
            ; SI - Указатель на символ с котрого нужно попытаться прочитать
            ; DI - Возвращаемое прочитаное слово в случае неудачи 0
            ; Длина слова максимально 16 байт
            ;------------------------------------------------------------------}

            ;---------------------; // Красота ))))))
            mov  DI,0             ; // ПО умолчанию резульатт 0
            ;---------------------;
            test si,si            ; // А почему бы тут не устроить проверку на ноль ?
            jz  .ВЫХОД            ; // Если у читаемого символа адрес 0 выход
            ;---------------------;
            mov  al,[si]          ;
            call AL_ЭТО_БУКВА     ; // Проверяет являеться ли символ буквой
            jz  .ВЫХОД            ; // Если не буква то выход
            ;---------------------;
            call СОЗ_СТР_DI_16    ; // Создаем строку с ответом DI длиной 16
            jz  .ВЫХОД            ; // Если создать строку не удалося выход
            ;---------------------;
.ЦИКЛ:
            ;---------------------;
            mov  al,[si]          ;
            call AL_ЭТО_БУКВА     ; // ПРоверяем являеться ли символ буквой
            jz  .КЦИКЛ            ;
            ;---------------------;
            call ДОБ_AL_В_СТРО_DI ; // Добавляем буку AL в конец строки DI
            ;---------------------;
            inc  SI               ; // Увеличиваем читемый символ
            ;---------------------;
            jmp .ЦИКЛ             ;
            ;---------------------;
.КЦИКЛ:
.ВЫХОД:

            ;---------------------;
            call ВОЗВРАТИТЬ_DI    ;
            test di,di            ;
            popad                 ;
            ret                   ;
            END IF                ;}
IF  (ПЛАТФОРМА = T32)   ;{
            pushad                ; { ОПИСАНИЕ
            ;-------------------------------------------------------------------
            ; SI - Указатель на символ с котрого нужно попытаться прочитать
            ; DI - Возвращаемое прочитаное слово в случае неудачи 0
            ; Длина слова максимально 16 байт
            ;------------------------------------------------------------------}

            ;---------------------; // Красота ))))))
            mov  EDI,0            ; // ПО умолчанию резульатт 0
            ;---------------------;
            test Esi,Esi          ; // А почему бы тут не устроить проверку на ноль ?
            jz  .ВЫХОД            ; // Если у читаемого символа адрес 0 выход
            ;---------------------;
            mov  al,[Esi]         ;
            call AL_ЭТО_БУКВА     ; // Проверяет являеться ли символ буквой
            jz  .ВЫХОД            ; // Если не буква то выход
            ;---------------------;
            call СОЗ_СТР_DI_16    ; // Создаем строку с ответом DI длиной 16
            jz  .ВЫХОД            ; // Если создать строку не удалося выход
            ;---------------------;
.ЦИКЛ:
            ;---------------------;
            mov  al,[Esi]         ;
            call AL_ЭТО_БУКВА     ; // ПРоверяем являеться ли символ буквой
            jz  .КЦИКЛ            ;
            ;---------------------;
            call ДОБ_AL_В_СТРО_DI ; // Добавляем буку AL в конец строки DI
            ;---------------------;
            inc  ESI              ; // Увеличиваем читемый символ
            ;---------------------;
            jmp .ЦИКЛ             ;
            ;---------------------;
.КЦИКЛ:
.ВЫХОД:

            ;---------------------;
            call ВОЗВРАТИТЬ_DI    ;
            test Edi,Edi          ;
            popad                 ;
            ret                   ;
            END IF                ;}
;==============================================================================}
ЧИТ_ЧИСЛО_С_SI_В_DX                 :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
    pushad                                 ;
    call ЧИТАЕТ_ЧИСЛО_С_АДР_SI_ВОЗ_СЛОВО_DI;
    mov  DX,DI                             ;
    call ВОЗВРАТИТЬ_DX                     ; //  Возврвщает адрес на строку
    test dx,dx                             ; //  Содержащию прочитаное ЧИСЛО
    popad                                  ; //  Если прочитать ек удалося JZ
    ret                                    ;
    END IF                                 ;}
IF  (ПЛАТФОРМА = T16)   ;{
    pushad                                 ;
    call ЧИТАЕТ_ЧИСЛО_С_АДР_SI_ВОЗ_СЛОВО_DI;
    mov  DX,DI                             ;
    call ВОЗВРАТИТЬ_DX                     ; //  Возврвщает адрес на строку
    test dx,dx                             ; //  Содержащию прочитаное ЧИСЛО
    popad                                  ; //  Если прочитать ек удалося JZ
    ret                                    ;
    END IF                                 ;}
IF  (ПЛАТФОРМА = T32)   ;{
    pushad                                 ;
    call ЧИТАЕТ_ЧИСЛО_С_АДР_SI_ВОЗ_СЛОВО_DI;
    mov  EDX,EDI                             ;
    call ВОЗВРАТИТЬ_DX                     ; //  Возврвщает адрес на строку
    test Edx,Edx                             ; //  Содержащию прочитаное ЧИСЛО
    popad                                  ; //  Если прочитать ек удалося JZ
    ret                                    ;
    END IF                                 ;}
;}
ЧИТАЕТ_ЧИСЛО_С_АДР_SI_ВОЗ_СЛОВО_DI  :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
            pushad                ; { ОПИСАНИЕ
            ;-------------------------------------------------------------------
            ; SI - Указатель на символ с котрого нужно попытаться прочитать
            ; DI - Возвращаемое прочитаное слово в случае неудачи 0
            ; Длина слова максимально 16 байт
            ;------------------------------------------------------------------}

            ;---------------------; // Красота ))))))
            mov  DI,0             ; // ПО умолчанию резульатт 0
            ;---------------------;
            test si,si            ; // А почему бы тут не устроить проверку на ноль ?
            jz  .ВЫХОД            ; // Если у читаемого символа адрес 0 выход
            ;---------------------;
            mov  al,[si]          ;
            call AL_ЭТО_ЦИФРА     ; // Проверяет являеться ли символ буквой
            jz  .ВЫХОД            ; // Если не буква то выход
            ;---------------------;
            call СОЗ_СТР_DI_16    ; // Создаем строку с ответом DI длиной 16
            jz  .ВЫХОД            ; // Если создать строку не удалося выход
            ;---------------------;
.ЦИКЛ:
            ;---------------------;
            mov  al,[si]          ;
            call AL_ЭТО_ЦИФРА     ; // ПРоверяем являеться ли символ буквой
            jz  .КЦИКЛ            ;
            ;---------------------;
            call ДОБ_AL_В_СТРО_DI ; // Добавляем буку AL в конец строки DI
            ;---------------------;
            inc  SI               ; // Увеличиваем читемый символ
            ;---------------------;
            jmp .ЦИКЛ             ;
            ;---------------------;
.КЦИКЛ:
.ВЫХОД:

            ;---------------------;
            call ВОЗВРАТИТЬ_DI    ;
            test di,di            ;
            popad                 ;
            ret                   ;
            END IF                ;}
IF  (ПЛАТФОРМА = T16)   ;{
            pushad                ; { ОПИСАНИЕ
            ;-------------------------------------------------------------------
            ; SI - Указатель на символ с котрого нужно попытаться прочитать
            ; DI - Возвращаемое прочитаное слово в случае неудачи 0
            ; Длина слова максимально 16 байт
            ;------------------------------------------------------------------}

            ;---------------------; // Красота ))))))
            mov  DI,0             ; // ПО умолчанию резульатт 0
            ;---------------------;
            test si,si            ; // А почему бы тут не устроить проверку на ноль ?
            jz  .ВЫХОД            ; // Если у читаемого символа адрес 0 выход
            ;---------------------;
            mov  al,[si]          ;
            call AL_ЭТО_ЦИФРА     ; // Проверяет являеться ли символ буквой
            jz  .ВЫХОД            ; // Если не буква то выход
            ;---------------------;
            call СОЗ_СТР_DI_16    ; // Создаем строку с ответом DI длиной 16
            jz  .ВЫХОД            ; // Если создать строку не удалося выход
            ;---------------------;
.ЦИКЛ:
            ;---------------------;
            mov  al,[si]          ;
            call AL_ЭТО_ЦИФРА     ; // ПРоверяем являеться ли символ буквой
            jz  .КЦИКЛ            ;
            ;---------------------;
            call ДОБ_AL_В_СТРО_DI ; // Добавляем буку AL в конец строки DI
            ;---------------------;
            inc  SI               ; // Увеличиваем читемый символ
            ;---------------------;
            jmp .ЦИКЛ             ;
            ;---------------------;
.КЦИКЛ:
.ВЫХОД:

            ;---------------------;
            call ВОЗВРАТИТЬ_DI    ;
            test di,di            ;
            popad                 ;
            ret                   ;
            END IF                ;}
IF  (ПЛАТФОРМА = T32)   ;{
            pushad                ; { ОПИСАНИЕ
            ;-------------------------------------------------------------------
            ; SI - Указатель на символ с котрого нужно попытаться прочитать
            ; DI - Возвращаемое прочитаное слово в случае неудачи 0
            ; Длина слова максимально 16 байт
            ;------------------------------------------------------------------}

            ;---------------------; // Красота ))))))
            mov  EDI,0            ; // ПО умолчанию резульатт 0
            ;---------------------;
            test Esi,Esi          ; // А почему бы тут не устроить проверку на ноль ?
            jz  .ВЫХОД            ; // Если у читаемого символа адрес 0 выход
            ;---------------------;
            mov  al,[Esi]         ;
            call AL_ЭТО_ЦИФРА     ; // Проверяет являеться ли символ буквой
            jz  .ВЫХОД            ; // Если не буква то выход
            ;---------------------;
            call СОЗ_СТР_DI_16    ; // Создаем строку с ответом DI длиной 16
            jz  .ВЫХОД            ; // Если создать строку не удалося выход
            ;---------------------;
.ЦИКЛ:
            ;---------------------;
            mov  al,[Esi]         ;
            call AL_ЭТО_ЦИФРА     ; // ПРоверяем являеться ли символ буквой
            jz  .КЦИКЛ            ;
            ;---------------------;
            call ДОБ_AL_В_СТРО_DI ; // Добавляем буку AL в конец строки DI
            ;---------------------;
            inc  ESI              ; // Увеличиваем читемый символ
            ;---------------------;
            jmp .ЦИКЛ             ;
            ;---------------------;
.КЦИКЛ:
.ВЫХОД:

            ;---------------------;
            call ВОЗВРАТИТЬ_DI    ;
            test edi,edi          ;
            popad                 ;
            ret                   ;
            END IF                ;}
;==============================================================================}
ЧИТ_ЗНАК_С_SI_В_DX                  :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
    pushad                                 ;
    call ЧИТАЕТ_ЗНАК_С_АДР_SI_ВОЗ_СЛОВО_DI ;
    mov  DX,DI                             ;
    call ВОЗВРАТИТЬ_DX                     ; //  Возврвщает адрес на строку
    test dx,dx                             ; //  Содержащию прочитаное ЗНАК
    popad                                  ; //  Если прочитать ек удалося JZ
    ret                                    ;
    ENd IF                                 ;}
IF  (ПЛАТФОРМА = T16)   ;{
    pushad                                 ;
    call ЧИТАЕТ_ЗНАК_С_АДР_SI_ВОЗ_СЛОВО_DI ;
    mov  DX,DI                             ;
    call ВОЗВРАТИТЬ_DX                     ; //  Возврвщает адрес на строку
    test dx,dx                             ; //  Содержащию прочитаное ЗНАК
    popad                                  ; //  Если прочитать ек удалося JZ
    ret                                    ;
    ENd IF                                 ;}
IF  (ПЛАТФОРМА = T32)   ;{
    pushad                                 ;
    call ЧИТАЕТ_ЗНАК_С_АДР_SI_ВОЗ_СЛОВО_DI ;
    mov  EDX,EDI                           ;
    call ВОЗВРАТИТЬ_DX                     ; //  Возврвщает адрес на строку
    test Edx,Edx                           ; //  Содержащию прочитаное ЗНАК
    popad                                  ; //  Если прочитать ек удалося JZ
    ret                                    ;
    ENd IF                                 ;}
;}
ЧИТАЕТ_ЗНАК_С_АДР_SI_ВОЗ_СЛОВО_DI   :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
            pushad;

            call СОЗ_СТР_DI_16; // Создаем строку с ответом DI
            mov  cx,si            ; // Запоминаем то место с котрого начали читать слово
            mov  ax,[si]          ;
            mov  si,.Т_ЗНАК2      ;
            call ПОИСК_ДВОЙНОЙ_БУКВЫ_AX_В_СТРОКЕ_SI
            jnz .ЗНАК2            ;
            mov  si,.Т_ЗНАК1      ;
            call ПОИСК_БУКВЫ_AL_В_СТРОКЕ_SI;
            jnz .ЗНАК1            ;

            call УДАЛИТЬ_СТРОКУ_DI; // Чтение не удалося
            mov  di,0             ;
            JMP .ВЫХОД            ;
            ;---------------------;

.ЗНАК1:     ;---------------------;
            call ДОБАВИТЬ_БУКВУ_AL_В_КОНЕЦ_СТРОКИ_DI; // Чтение Удалося
            jmp .ВЫХОД            ;
.ЗНАК2:     ;---------------------;
            call ДОБАВИТЬ_БУКВУ_AL_В_КОНЕЦ_СТРОКИ_DI; // Чтение Удалося
            mov al,ah             ;
            call ДОБАВИТЬ_БУКВУ_AL_В_КОНЕЦ_СТРОКИ_DI; // Чтение Удалося
            ;---------------------;
.ВЫХОД:
            test di,di            ;
            pop  si               ;
            push di               ;
            popad                 ;
            ret                   ;
            END IF                ;}
IF  (ПЛАТФОРМА = T16)   ;{
            pushad;

            call СОЗ_СТР_DI_16; // Создаем строку с ответом DI
            mov  cx,si            ; // Запоминаем то место с котрого начали читать слово
            mov  ax,[si]          ;
            mov  si,.Т_ЗНАК2      ;
            call ПОИСК_ДВОЙНОЙ_БУКВЫ_AX_В_СТРОКЕ_SI
            jnz .ЗНАК2            ;
            mov  si,.Т_ЗНАК1      ;
            call ПОИСК_БУКВЫ_AL_В_СТРОКЕ_SI;
            jnz .ЗНАК1            ;

            call УДАЛИТЬ_СТРОКУ_DI; // Чтение не удалося
            mov  di,0             ;
            JMP .ВЫХОД            ;
            ;---------------------;

.ЗНАК1:     ;---------------------;
            call ДОБАВИТЬ_БУКВУ_AL_В_КОНЕЦ_СТРОКИ_DI; // Чтение Удалося
            jmp .ВЫХОД            ;
.ЗНАК2:     ;---------------------;
            call ДОБАВИТЬ_БУКВУ_AL_В_КОНЕЦ_СТРОКИ_DI; // Чтение Удалося
            mov al,ah             ;
            call ДОБАВИТЬ_БУКВУ_AL_В_КОНЕЦ_СТРОКИ_DI; // Чтение Удалося
            ;---------------------;
.ВЫХОД:
            test di,di            ;
            pop  si               ;
            push di               ;
            popad                 ;
            ret                   ;
            END IF                ;}
IF  (ПЛАТФОРМА = T32)   ;{
            pushad;

            call СОЗ_СТР_DI_16; // Создаем строку с ответом DI

            mov  ecx,esi            ; // Запоминаем то место с котрого начали читать слово
            mov  ax,[esi]          ;
            mov  esi,.Т_ЗНАК2      ;
            call ПОИСК_ДВОЙНОЙ_БУКВЫ_AX_В_СТРОКЕ_SI
            jnz .ЗНАК2            ;
            mov  esi,.Т_ЗНАК1      ;
            call ПОИСК_БУКВЫ_AL_В_СТРОКЕ_SI;
            jnz .ЗНАК1            ;

            call УДАЛИТЬ_СТРОКУ_DI; // Чтение не удалося
            mov  edi,0             ;
            jmp .ВЫХОД            ;
            ;---------------------;

.ЗНАК1:     ;---------------------;
            call ДОБАВИТЬ_БУКВУ_AL_В_КОНЕЦ_СТРОКИ_DI; // Чтение Удалося
            jmp .ВЫХОД            ;
.ЗНАК2:     ;---------------------;

            call ДОБАВИТЬ_БУКВУ_AL_В_КОНЕЦ_СТРОКИ_DI; // Чтение Удалося
            mov  al,ah             ;
            call ДОБАВИТЬ_БУКВУ_AL_В_КОНЕЦ_СТРОКИ_DI; // Чтение Удалося
            ;---------------------;
.ВЫХОД:
            test edi,edi            ;
            pop  esi               ;
            push edi               ;
            popad                 ;
            ret                   ;
            END IF                ;}

.Т_ЗНАК1: DB '+-*/{}()=<>',0;
.Т_ЗНАК2: DB ':===<=>=<>!=<<>>>&&||',0,0;
;==============================================================================}
ЧИТ_КАВЫЧКУ_С_SI_В_DX               :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
    pushad                                    ;

    call ЧИТАЕТ_КАВЫЧКУ_С_АДР_SI_ВОЗ_СЛОВО_DI ;
    mov  DX,DI                                ;
    call ВОЗВРАТИТЬ_DX                        ; //  Возврвщает адрес на строку
    test dx,dx                                ; //  Содержащию прочитаное ЗНАК
    popad                                     ; //  Если прочитать ек удалося JZ
    ret                                       ;
    END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
    pushad                                    ;

    call ЧИТАЕТ_КАВЫЧКУ_С_АДР_SI_ВОЗ_СЛОВО_DI ;
    mov  DX,DI                                ;
    call ВОЗВРАТИТЬ_DX                        ; //  Возврвщает адрес на строку
    test dx,dx                                ; //  Содержащию прочитаное ЗНАК
    popad                                     ; //  Если прочитать ек удалося JZ
    ret                                       ;
    END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
    pushad                                    ;

    call ЧИТАЕТ_КАВЫЧКУ_С_АДР_SI_ВОЗ_СЛОВО_DI ;
    mov  EDX,EDI                                ;
    call ВОЗВРАТИТЬ_DX                        ; //  Возврвщает адрес на строку
    test Edx,Edx                                ; //  Содержащию прочитаное ЗНАК
    popad                                     ; //  Если прочитать ек удалося JZ
    ret                                       ;
    END IF;}

;}
ЧИТАЕТ_КАВЫЧКУ_С_АДР_SI_ВОЗ_СЛОВО_DI:;{
IF  (ПЛАТФОРМА = ДОС)   ;{
            pushad;
            mov  di,0              ; // ПО умолчанию DI 0 адрес проч слова
            ;----------------------;
            mov  al,[si]           ;
            call AL_ЭТО_КАВЫЧКА    ; // Если Это кавычка то Читать
            jz  .ВЫХОД             ; // Если это не кавычка то выход
            ;----------------------;
            call СОЗ_СТР_DI_16     ;
            inc si
            ;----------------------;
.ЦИКЛ:
            ;----------------------;
            mov  al,[si]           ;
            call AL_ЭТО_КАВЫЧКА    ; // Если Это кавычка то выход
            jnz .КЦИКЛА            ;
            test al,al             ; // Если Это 0 то выход
            jz  .КЦИКЛА            ;
            ;----------------------;
            call ДОБ_AL_В_СТРО_DI  ; // Добавляем буку AL в конец строки DI
            inc  SI                ; // Увеличиваем читемый символ
            jmp .ЦИКЛ              ;
            ;----------------------;
.КЦИКЛА:
.ВЫХОД:
            CALL ВОЗВРАТИТЬ_DI     ;
            test di,di             ; // Если не удалося прочитать JZ
            popad                  ;
            ret                    ;
            END IF                 ;}
IF  (ПЛАТФОРМА = T16)   ;{
            pushad;
            mov  di,0              ; // ПО умолчанию DI 0 адрес проч слова
            ;----------------------;
            mov  al,[si]           ;
            call AL_ЭТО_КАВЫЧКА    ; // Если Это кавычка то Читать
            jz  .ВЫХОД             ; // Если это не кавычка то выход
            ;----------------------;
            call СОЗ_СТР_DI_16     ;
            inc si
            ;----------------------;
.ЦИКЛ:
            ;----------------------;
            mov  al,[si]           ;
            call AL_ЭТО_КАВЫЧКА    ; // Если Это кавычка то выход
            jnz .КЦИКЛА            ;
            test al,al             ; // Если Это 0 то выход
            jz  .КЦИКЛА            ;
            ;----------------------;
            call ДОБ_AL_В_СТРО_DI  ; // Добавляем буку AL в конец строки DI
            inc  SI                ; // Увеличиваем читемый символ
            jmp .ЦИКЛ              ;
            ;----------------------;
.КЦИКЛА:
.ВЫХОД:
            CALL ВОЗВРАТИТЬ_DI     ;
            test di,di             ; // Если не удалося прочитать JZ
            popad                  ;
            ret                    ;
            END IF                 ;}
IF  (ПЛАТФОРМА = T32)   ;{
            pushad;
            mov  edi,0              ; // ПО умолчанию DI 0 адрес проч слова
            ;----------------------;
            mov  al,[esi]           ;
            call AL_ЭТО_КАВЫЧКА    ; // Если Это кавычка то Читать
            jz  .ВЫХОД             ; // Если это не кавычка то выход
            ;----------------------;
            call СОЗ_СТР_DI_16     ;
            inc esi
            ;----------------------;
.ЦИКЛ:
            ;----------------------;
            mov  al,[esi]           ;
            call AL_ЭТО_КАВЫЧКА    ; // Если Это кавычка то выход
            jnz .КЦИКЛА            ;
            test al,al             ; // Если Это 0 то выход
            jz  .КЦИКЛА            ;
            ;----------------------;
            call ДОБ_AL_В_СТРО_DI  ; // Добавляем буку AL в конец строки DI
            inc  eSI                ; // Увеличиваем читемый символ
            jmp .ЦИКЛ              ;
            ;----------------------;
.КЦИКЛА:
.ВЫХОД:
            CALL ВОЗВРАТИТЬ_DI     ;
            test edi,edi             ; // Если не удалося прочитать JZ
            popad                  ;
            ret                    ;
            END IF                 ;}
;==============================================================================}

СТРОКА_AX_ОЧИСТКА:;{
IF  (ПЛАТФОРМА = ДОС)   ;{
pushad;
mov si,ax;
mov [si],byte 0;
popad;
ret;
END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
pushad;
mov si,ax;
mov [si],byte 0;
popad;
ret;
END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
pushad;
mov Esi,Eax;
mov [Esi],byte 0;
popad;
ret;
END IF;}
;}

;---}
;---{ ФУНКЦИИ ДЛЯ РАБОТЫ С БУКВАМИ          .

ЕСЛИ_В_AL_НЕ_СИМВОЛ_ФЛАГ_Z_0:;{ ПРоверяет являеться ли символ AL Буквой или (){}если это буква устанавливает флаг Z
IF  (ПЛАТФОРМА = ДОС)   ;{
              pushad             ;

              mov  si,.ДОПЗНАК;
              call ПОИСК_БУКВЫ_AL_В_СТРОКЕ_SI;
              jnz .ЭТО_БУК          ;
.КМБУК:
              ;------------------;
              cmp  al,'z'        ; // Кнопка МАленькие буквы
              ja  .КББУК         ;
              cmp  al,'a'        ; // Кнопка МАленькие буквы
              jb  .КББУК         ;
              jmp .ЭТО_БУК       ;
              ;------------------;
.КББУК:
              ;------------------;
              cmp  al,'Z'        ; // Кнопка МАленькие буквы
              ja  .ДАЛЕЕ         ;
              cmp  al,'A'        ; // Кнопка МАленькие буквы
              jb  .ДАЛЕЕ         ;
              jmp .ЭТО_БУК       ;
              ;------------------;
.ДАЛЕЕ:
              jmp .ЭТО_НЕ_БУКВА  ;
              ;------------------;
.ЭТО_БУК:
              ;----------------;
              mov  al,1          ;
              test al,al         ;
              jmp .ВЫХОД         ;
              ;-----------------
.ЭТО_НЕ_БУКВА:
              ;----------------;
              mov  al,0          ;
              test al,al         ;
              jmp .ВЫХОД         ;
              ;-----------------
.ВЫХОД:
              popad;
              ret;
              END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
              pushad             ;

              mov  si,.ДОПЗНАК;
              call ПОИСК_БУКВЫ_AL_В_СТРОКЕ_SI;
              jnz .ЭТО_БУК          ;
.КМБУК:
              ;------------------;
              cmp  al,'z'        ; // Кнопка МАленькие буквы
              ja  .КББУК         ;
              cmp  al,'a'        ; // Кнопка МАленькие буквы
              jb  .КББУК         ;
              jmp .ЭТО_БУК       ;
              ;------------------;
.КББУК:
              ;------------------;
              cmp  al,'Z'        ; // Кнопка МАленькие буквы
              ja  .ДАЛЕЕ         ;
              cmp  al,'A'        ; // Кнопка МАленькие буквы
              jb  .ДАЛЕЕ         ;
              jmp .ЭТО_БУК       ;
              ;------------------;
.ДАЛЕЕ:
              jmp .ЭТО_НЕ_БУКВА  ;
              ;------------------;
.ЭТО_БУК:
              ;----------------;
              mov  al,1          ;
              test al,al         ;
              jmp .ВЫХОД         ;
              ;-----------------
.ЭТО_НЕ_БУКВА:
              ;----------------;
              mov  al,0          ;
              test al,al         ;
              jmp .ВЫХОД         ;
              ;-----------------
.ВЫХОД:
              popad;
              ret;
              END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
              pushad             ;

              mov  Esi,.ДОПЗНАК;
              call ПОИСК_БУКВЫ_AL_В_СТРОКЕ_SI;
              jnz .ЭТО_БУК          ;
.КМБУК:
              ;------------------;
              cmp  al,'z'        ; // Кнопка МАленькие буквы
              ja  .КББУК         ;
              cmp  al,'a'        ; // Кнопка МАленькие буквы
              jb  .КББУК         ;
              jmp .ЭТО_БУК       ;
              ;------------------;
.КББУК:
              ;------------------;
              cmp  al,'Z'        ; // Кнопка МАленькие буквы
              ja  .ДАЛЕЕ         ;
              cmp  al,'A'        ; // Кнопка МАленькие буквы
              jb  .ДАЛЕЕ         ;
              jmp .ЭТО_БУК       ;
              ;------------------;
.ДАЛЕЕ:
              jmp .ЭТО_НЕ_БУКВА  ;
              ;------------------;
.ЭТО_БУК:
              ;----------------;
              mov  al,1          ;
              test al,al         ;
              jmp .ВЫХОД         ;
              ;-----------------
.ЭТО_НЕ_БУКВА:
              ;----------------;
              mov  al,0          ;
              test al,al         ;
              jmp .ВЫХОД         ;
              ;-----------------
.ВЫХОД:
              popad;
              ret;
              END IF;}
.ДОПЗНАК: DB ' <>?,./[]{};:`~()+-=_""0123456789',39,0;
;==============================================================================}
ПРЕОБРАЗУЕТ_АНГ_БУК_AL_В_РУС:;{ Преобразет Анл букву в руску
IF  (ПЛАТФОРМА = ДОС)   ;{
             push si;
             push cx;
             mov  cx,ax;
             mov  ch,cl;
             mov  ah,0;
             cmp  al,32
             jb  .ВЫХОД;
             cmp  al,127
             ja  .ВЫХОД;
             sub  al,32
             mov  si,ax;
             mov  si,ax    ;
             add  si,.ТАБ02;
             mov  cl,[si]  ;
             cmp  cl,' '   ;
             jz  .ВЫХОД2   ;
             mov  al,cl    ;
             jmp .ВЫХОД    ;
.ВЫХОД2:     mov  al,ch    ;


.ВЫХОД:
             mov ah,ch;
             pop cx;
             pop si;
             ret;
             END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
             push si;
             push cx;
             mov  cx,ax;
             mov  ch,cl;
             mov  ah,0;
             cmp  al,32
             jb  .ВЫХОД;
             cmp  al,127
             ja  .ВЫХОД;
             sub  al,32
             mov  si,ax;
             mov  si,ax    ;
             add  si,.ТАБ02;
             mov  cl,[si]  ;
             cmp  cl,' '   ;
             jz  .ВЫХОД2   ;
             mov  al,cl    ;
             jmp .ВЫХОД    ;
.ВЫХОД2:     mov  al,ch    ;


.ВЫХОД:
             mov ah,ch;
             pop cx;
             pop si;
             ret;
             END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
             push esi;
             push ecx;
             mov  ecx,eax;
             mov  ch,cl;
             mov  ah,0;
             cmp  al,32
             jb  .ВЫХОД;
             cmp  al,127
             ja  .ВЫХОД;
             sub  al,32
             mov  esi,eax;
             mov  esi,eax;
             add  esi,.ТАБ02;
             mov  cl,[esi]  ;
             cmp  cl,' '   ;
             jz  .ВЫХОД2   ;
             mov  al,cl    ;
             jmp .ВЫХОД    ;
.ВЫХОД2:     mov  al,ch    ;


.ВЫХОД:
             mov ah,ch;
             pop ecx;
             pop esi;
             ret;
             END IF;}

.ТАБ02:DB '  Э    э    б ю           ЖжБ Ю ';
.ТАБ03:DB ' ФИСВУАПРШОЛДЬТЩЗЙКЫЕГМЦЧНЯx ъ  ';
.ТАБ04:DB 'ёфисвуапршолдьтщзйкыегмцчняX ЪЁ ';
;==============================================================================}
ПРЕОБРАЗУЕТ_МАЛ_БУК_AL_В_БОЛ:;{ Преобразет все буквы в большие
IF  (ПЛАТФОРМА = ДОС)   ;{
             push si;

             cmp   al,97 ;
             jb   .ДАЛЕЕ;
             cmp   al,122;
             ja   .ДАЛЕЕ;
             sub   al,32;
             jmp  .ВЫХОД;

.ДАЛЕЕ:
             cmp   al,160 ;
             jb   .ДАЛЕЕ2;
             cmp   al,175;
             ja   .ДАЛЕЕ2;
             sub   al,32;
             jmp  .ВЫХОД;

.ДАЛЕЕ2:

             cmp   al,224 ;
             jb   .ДАЛЕЕ3;
             cmp   al,239;
             ja   .ДАЛЕЕ3;
             sub   al,80;
             jmp  .ВЫХОД;

.ДАЛЕЕ3:     cmp   al,241;
             jnz  .ДАЛЕЕ4;
             dec   al;


.ДАЛЕЕ4:
.ВЫХОД:
             pop  si;
             ret;
             END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
             push si;

             cmp   al,97 ;
             jb   .ДАЛЕЕ;
             cmp   al,122;
             ja   .ДАЛЕЕ;
             sub   al,32;
             jmp  .ВЫХОД;

.ДАЛЕЕ:
             cmp   al,160 ;
             jb   .ДАЛЕЕ2;
             cmp   al,175;
             ja   .ДАЛЕЕ2;
             sub   al,32;
             jmp  .ВЫХОД;

.ДАЛЕЕ2:

             cmp   al,224 ;
             jb   .ДАЛЕЕ3;
             cmp   al,239;
             ja   .ДАЛЕЕ3;
             sub   al,80;
             jmp  .ВЫХОД;

.ДАЛЕЕ3:     cmp   al,241;
             jnz  .ДАЛЕЕ4;
             dec   al;


.ДАЛЕЕ4:
.ВЫХОД:
             pop  si;
             ret;
             END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
             push esi;

             cmp   al,97 ;
             jb   .ДАЛЕЕ;
             cmp   al,122;
             ja   .ДАЛЕЕ;
             sub   al,32;
             jmp  .ВЫХОД;

.ДАЛЕЕ:
             cmp   al,160 ;
             jb   .ДАЛЕЕ2;
             cmp   al,175;
             ja   .ДАЛЕЕ2;
             sub   al,32;
             jmp  .ВЫХОД;

.ДАЛЕЕ2:

             cmp   al,224 ;
             jb   .ДАЛЕЕ3;
             cmp   al,239;
             ja   .ДАЛЕЕ3;
             sub   al,80;
             jmp  .ВЫХОД;

.ДАЛЕЕ3:     cmp   al,241;
             jnz  .ДАЛЕЕ4;
             dec   al;


.ДАЛЕЕ4:
.ВЫХОД:
             pop  esi;
             ret;
             END IF;}

;==============================================================================}

AL_ЭТО_КАВЫЧКА              :;{ Если AL Это кавычка или 0
IF  (ПЛАТФОРМА = ДОС)   ;{
            push dx       ;
            mov  dl,0     ;
            ;-------------;
            cmp  al,34   ; // Если это кавычка то ВЫХОД  "
            jz  .ЭТО_КАВ  ;
            cmp  al,39   ; // Если это кавычка то  ВЫХОД  '
            jz  .ЭТО_КАВ  ;
            jmp .ВЫХОД    ;
            ;-------------;
.ЭТО_КАВ:   mov  dl,1     ;
.ВЫХОД:     test dl,dl    ;
            ;-------------;
            pop  dx       ;
            ret           ;
            ENd IF        ;}
IF  (ПЛАТФОРМА = T16)   ;{
            push dx       ;
            mov  dl,0     ;
            ;-------------;
            cmp  al,34   ; // Если это кавычка то ВЫХОД  "
            jz  .ЭТО_КАВ  ;
            cmp  al,39   ; // Если это кавычка то  ВЫХОД  '
            jz  .ЭТО_КАВ  ;
            jmp .ВЫХОД    ;
            ;-------------;
.ЭТО_КАВ:   mov  dl,1     ;
.ВЫХОД:     test dl,dl    ;
            ;-------------;
            pop  dx       ;
            ret           ;
            ENd IF        ;}
IF  (ПЛАТФОРМА = T32)   ;{
            push edx       ;
            mov  dl,0     ;
            ;-------------;
            cmp  al,34   ; // Если это кавычка то ВЫХОД  "
            jz  .ЭТО_КАВ  ;
            cmp  al,39   ; // Если это кавычка то  ВЫХОД  '
            jz  .ЭТО_КАВ  ;
            jmp .ВЫХОД    ;
            ;-------------;
.ЭТО_КАВ:   mov  dl,1     ;
.ВЫХОД:     test dl,dl    ;
            ;-------------;
            pop  edx       ;
            ret           ;
            ENd IF        ;}
;}
AL_ЭТО_БУКВА:;-------------------------------------------------
ЕСЛИ_В_AL_НЕ_БУКВА_ФЛАГ_Z_0 :;{ БУКВЫ это a-z A-Z а-я А-Я
IF  (ПЛАТФОРМА = ДОС)   ;{
              pushad             ;
.МАЛ_АНГ_БУК:
              ;------------------;
              cmp  al,'z'        ; // Кнопка МАленькие буквы
              ja  .БОЛ_АНГ_БУК   ;
              cmp  al,'a'        ; // Кнопка МАленькие буквы
              jb  .БОЛ_АНГ_БУК   ;
              jmp .ЭТО_БУК       ;
              ;------------------;
.БОЛ_АНГ_БУК:
              ;------------------;
              cmp  al,'Z'        ; // Кнопка МАленькие буквы
              ja  .БОЛ_РУС_БУК   ;
              cmp  al,'A'        ; // Кнопка МАленькие буквы
              jb  .БОЛ_РУС_БУК   ;
              jmp .ЭТО_БУК       ;
              ;------------------;
.БОЛ_РУС_БУК:
              ;------------------;
              cmp  al,'Я'        ; // Кнопка МАленькие буквы
              ja  .МАЛ_РУС_БУК1  ;
              cmp  al,'А'        ; // Кнопка МАленькие буквы
              jb  .МАЛ_РУС_БУК1  ;
              jmp .ЭТО_БУК       ;
              ;------------------;
.МАЛ_РУС_БУК1:
              ;------------------;
              cmp  al,'п'        ; // Кнопка МАленькие буквы
              ja  .МАЛ_РУС_БУК2  ;
              cmp  al,'а'        ; // Кнопка МАленькие буквы
              jb  .МАЛ_РУС_БУК2  ;
              jmp .ЭТО_БУК       ;
              ;------------------;
.МАЛ_РУС_БУК2:
              ;------------------;
              cmp  al,'я'        ; // Кнопка МАленькие буквы
              ja  .ЁЁЁЁЁ         ;
              cmp  al,'р'        ; // Кнопка МАленькие буквы
              jb  .ЁЁЁЁЁ         ;
              jmp .ЭТО_БУК       ;
              ;------------------;
.ЁЁЁЁЁ:
              ;------------------;
              cmp  al,'ё'        ; // Кнопка МАленькие буквы
              jNZ .БУК_          ;
              cmp  al,'Ё'        ; // Кнопка МАленькие буквы
              jNz .БУК_          ;
              jmp .ЭТО_БУК       ;
              ;------------------;
.БУК_:
              ;------------------;
              cmp  al,'_'        ; // Кнопка МАленькие буквы
              jNZ  .ДАЛЕЕ        ;
              jmp .ЭТО_БУК       ;
              ;------------------;

.ДАЛЕЕ:

              jmp .ЭТО_НЕ_БУКВА  ;
              ;------------------;
.ЭТО_БУК:
              ;----------------;
              mov  al,1          ;
              test al,al         ;
              jmp .ВЫХОД         ;
              ;-----------------
.ЭТО_НЕ_БУКВА:
              ;----------------;
              mov  al,0          ;
              test al,al         ;
              jmp .ВЫХОД         ;
              ;-----------------
.ВЫХОД:
              popad;
              ret;
              END IF            ;}
IF  (ПЛАТФОРМА = T16)   ;{
              pushad             ;
.МАЛ_АНГ_БУК:
              ;------------------;
              cmp  al,'z'        ; // Кнопка МАленькие буквы
              ja  .БОЛ_АНГ_БУК   ;
              cmp  al,'a'        ; // Кнопка МАленькие буквы
              jb  .БОЛ_АНГ_БУК   ;
              jmp .ЭТО_БУК       ;
              ;------------------;
.БОЛ_АНГ_БУК:
              ;------------------;
              cmp  al,'Z'        ; // Кнопка МАленькие буквы
              ja  .БОЛ_РУС_БУК   ;
              cmp  al,'A'        ; // Кнопка МАленькие буквы
              jb  .БОЛ_РУС_БУК   ;
              jmp .ЭТО_БУК       ;
              ;------------------;
.БОЛ_РУС_БУК:
              ;------------------;
              cmp  al,'Я'        ; // Кнопка МАленькие буквы
              ja  .МАЛ_РУС_БУК1  ;
              cmp  al,'А'        ; // Кнопка МАленькие буквы
              jb  .МАЛ_РУС_БУК1  ;
              jmp .ЭТО_БУК       ;
              ;------------------;
.МАЛ_РУС_БУК1:
              ;------------------;
              cmp  al,'п'        ; // Кнопка МАленькие буквы
              ja  .МАЛ_РУС_БУК2  ;
              cmp  al,'а'        ; // Кнопка МАленькие буквы
              jb  .МАЛ_РУС_БУК2  ;
              jmp .ЭТО_БУК       ;
              ;------------------;
.МАЛ_РУС_БУК2:
              ;------------------;
              cmp  al,'я'        ; // Кнопка МАленькие буквы
              ja  .ЁЁЁЁЁ         ;
              cmp  al,'р'        ; // Кнопка МАленькие буквы
              jb  .ЁЁЁЁЁ         ;
              jmp .ЭТО_БУК       ;
              ;------------------;
.ЁЁЁЁЁ:
              ;------------------;
              cmp  al,'ё'        ; // Кнопка МАленькие буквы
              jNZ .БУК_          ;
              cmp  al,'Ё'        ; // Кнопка МАленькие буквы
              jNz .БУК_          ;
              jmp .ЭТО_БУК       ;
              ;------------------;
.БУК_:
              ;------------------;
              cmp  al,'_'        ; // Кнопка МАленькие буквы
              jNZ  .ДАЛЕЕ        ;
              jmp .ЭТО_БУК       ;
              ;------------------;

.ДАЛЕЕ:

              jmp .ЭТО_НЕ_БУКВА  ;
              ;------------------;
.ЭТО_БУК:
              ;----------------;
              mov  al,1          ;
              test al,al         ;
              jmp .ВЫХОД         ;
              ;-----------------
.ЭТО_НЕ_БУКВА:
              ;----------------;
              mov  al,0          ;
              test al,al         ;
              jmp .ВЫХОД         ;
              ;-----------------
.ВЫХОД:
              popad;
              ret;
              END IF            ;}
IF  (ПЛАТФОРМА = T32)   ;{
              pushad             ;
.МАЛ_АНГ_БУК:
              ;------------------;
              cmp  al,'z'        ; // Кнопка МАленькие буквы
              ja  .БОЛ_АНГ_БУК   ;
              cmp  al,'a'        ; // Кнопка МАленькие буквы
              jb  .БОЛ_АНГ_БУК   ;
              jmp .ЭТО_БУК       ;
              ;------------------;
.БОЛ_АНГ_БУК:
              ;------------------;
              cmp  al,'Z'        ; // Кнопка МАленькие буквы
              ja  .БОЛ_РУС_БУК   ;
              cmp  al,'A'        ; // Кнопка МАленькие буквы
              jb  .БОЛ_РУС_БУК   ;
              jmp .ЭТО_БУК       ;
              ;------------------;
.БОЛ_РУС_БУК:
              ;------------------;
              cmp  al,'Я'        ; // Кнопка МАленькие буквы
              ja  .МАЛ_РУС_БУК1  ;
              cmp  al,'А'        ; // Кнопка МАленькие буквы
              jb  .МАЛ_РУС_БУК1  ;
              jmp .ЭТО_БУК       ;
              ;------------------;
.МАЛ_РУС_БУК1:
              ;------------------;
              cmp  al,'п'        ; // Кнопка МАленькие буквы
              ja  .МАЛ_РУС_БУК2  ;
              cmp  al,'а'        ; // Кнопка МАленькие буквы
              jb  .МАЛ_РУС_БУК2  ;
              jmp .ЭТО_БУК       ;
              ;------------------;
.МАЛ_РУС_БУК2:
              ;------------------;
              cmp  al,'я'        ; // Кнопка МАленькие буквы
              ja  .ЁЁЁЁЁ         ;
              cmp  al,'р'        ; // Кнопка МАленькие буквы
              jb  .ЁЁЁЁЁ         ;
              jmp .ЭТО_БУК       ;
              ;------------------;
.ЁЁЁЁЁ:
              ;------------------;
              cmp  al,'ё'        ; // Кнопка МАленькие буквы
              jNZ .БУК_          ;
              cmp  al,'Ё'        ; // Кнопка МАленькие буквы
              jNz .БУК_          ;
              jmp .ЭТО_БУК       ;
              ;------------------;
.БУК_:
              ;------------------;
              cmp  al,'_'        ; // Кнопка МАленькие буквы
              jNZ  .ДАЛЕЕ        ;
              jmp .ЭТО_БУК       ;
              ;------------------;

.ДАЛЕЕ:

              jmp .ЭТО_НЕ_БУКВА  ;
              ;------------------;
.ЭТО_БУК:
              ;----------------;
              mov  al,1          ;
              test al,al         ;
              jmp .ВЫХОД         ;
              ;-----------------
.ЭТО_НЕ_БУКВА:
              ;----------------;
              mov  al,0          ;
              test al,al         ;
              jmp .ВЫХОД         ;
              ;-----------------
.ВЫХОД:
              popad;
              ret;
              END IF            ;}
;==============================================================================}
AL_ЭТО_ЦИФРА:;-------------------------------------------------
ЕСЛИ_В_AL_ЦИФРА_ФЛАГ_Z_1    :;{ ПРоверяет являеться ли символ AL Буквой если это буква устанавливает флаг Z
IF  (ПЛАТФОРМА = ДОС)   ;{
              pushad;
              ;----------------;
              cmp  al,'9'        ; // Если Больше '9' Это не фифра
              ja  .ЭТО_НЕ_ЦИФ    ;
              cmp  al,'0'        ; // Если меньше '0' Это не фифра
              jb  .ЭТО_НЕ_ЦИФ    ;

              mov  al,1          ;
              test al,al         ;
              jmp .ВЫХОД         ;
              ;-----------------
.ЭТО_НЕ_ЦИФ:
              ;----------------;
              mov  al,0          ;
              test al,al         ;
              jmp .ВЫХОД         ;
              ;-----------------
.ВЫХОД:
              popad;
              ret;
              END IF ;}
IF  (ПЛАТФОРМА = T16)   ;{
              pushad;
              ;----------------;
              cmp  al,'9'        ; // Если Больше '9' Это не фифра
              ja  .ЭТО_НЕ_ЦИФ    ;
              cmp  al,'0'        ; // Если меньше '0' Это не фифра
              jb  .ЭТО_НЕ_ЦИФ    ;

              mov  al,1          ;
              test al,al         ;
              jmp .ВЫХОД         ;
              ;-----------------
.ЭТО_НЕ_ЦИФ:
              ;----------------;
              mov  al,0          ;
              test al,al         ;
              jmp .ВЫХОД         ;
              ;-----------------
.ВЫХОД:
              popad;
              ret;
              END IF ;}
IF  (ПЛАТФОРМА = T32)   ;{
              pushad;
              ;----------------;
              cmp  al,'9'        ; // Если Больше '9' Это не фифра
              ja  .ЭТО_НЕ_ЦИФ    ;
              cmp  al,'0'        ; // Если меньше '0' Это не фифра
              jb  .ЭТО_НЕ_ЦИФ    ;

              mov  al,1          ;
              test al,al         ;
              jmp .ВЫХОД         ;
              ;-----------------
.ЭТО_НЕ_ЦИФ:
              ;----------------;
              mov  al,0          ;
              test al,al         ;
              jmp .ВЫХОД         ;
              ;-----------------
.ВЫХОД:
              popad;
              ret;
              END IF ;}
;==============================================================================}

;---}
;---{ ФУНКЦИИ ДЛЯ РАБОТЫ С ЭКРАНОМ          .
ЧИСЛОAX:;{ Вывод содержимого регистра AX как число на экран
pushad;
call ЭКРАН_ВЫВОД_ПРОБЕЛА;
call ЭКРАН_ВЫВОД_ЧИСЛА;
call ЭКРАН_ВЫВОД_ПРОБЕЛА;
popad;
ret;
;=====================}
ЧИСЛОBX:;{ Вывод содержимого регистра BX как число на экран
IF  (ПЛАТФОРМА = ДОС)   ;{
push ax;
mov  ax,bx;
call ЧИСЛОAX;
pop  ax;
ret;
END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
push ax;
mov  ax,bx;
call ЧИСЛОAX;
pop  ax;
ret;
END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
push eax;
mov  eax,ebx;
call ЧИСЛОAX;
pop  eax;
ret;
END IF;}
;=====================}
ЧИСЛОCX:;{ Вывод содержимого регистра CX как число на экран
IF  (ПЛАТФОРМА = ДОС)   ;{
push ax;
mov  ax,cx;
call ЧИСЛОAX;
pop  ax;
ret;
END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
push ax;
mov  ax,cx;
call ЧИСЛОAX;
pop  ax;
ret;
END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
push eax;
mov  eax,ecx;
call ЧИСЛОAX;
pop  eax;
ret;
END IF;}
;=====================}
ЧИСЛОDX:;{ Вывод содержимого регистра DX как число на экран
IF  (ПЛАТФОРМА = ДОС)   ;{
push ax;
mov  ax,dx;
call ЧИСЛОAX;
pop  ax;
ret;
END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
push ax;
mov  ax,dx;
call ЧИСЛОAX;
pop  ax;
ret;
END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
push eax;
mov  eax,edx;
call ЧИСЛОAX;
pop  eax;
ret;
END IF;}
;=====================}
ЧИСЛОDI:;{ Вывод содержимого регистра DI как число на экран
IF  (ПЛАТФОРМА = ДОС)   ;{
push ax;
mov  ax,di;
call ЧИСЛОAX;
pop  ax;
ret;
END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
push ax;
mov  ax,di;
call ЧИСЛОAX;
pop  ax;
ret;
END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
push eax;
mov  eax,edi;
call ЧИСЛОAX;
pop  eax;
ret;
END IF;}
;=====================}
ЧИСЛОSI:;{ Вывод содержимого регистра SI как число на экран
IF  (ПЛАТФОРМА = ДОС)   ;{
push ax;
mov  ax,Si;
call ЧИСЛОAX;
pop  ax;
ret;
END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
push ax;
mov  ax,Si;
call ЧИСЛОAX;
pop  ax;
ret;
END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
push eax;
mov  eax,eSi;
call ЧИСЛОAX;
pop  eax;
ret;
END IF;}
;=====================}

СТРОКАAX:;{ Вывод строки адрес котрой в AX на экран
IF  (ПЛАТФОРМА = ДОС)   ;{
push di;
mov di,ax;
call СТРОКАDI;
pop di;
ret;
ENd IF;}
IF  (ПЛАТФОРМА = T16)   ;{
push di;
mov di,ax;
call СТРОКАDI;
pop di;
ret;
ENd IF;}
IF  (ПЛАТФОРМА = T32)   ;{
push edi;
mov edi,eax;
call СТРОКАDI;
pop edi;
ret;
ENd IF;}
;=====================}
СТРОКАBX:;{ Вывод строки адрес котрой в BX на экран
IF  (ПЛАТФОРМА = ДОС)   ;{
push di;
mov di,bx;
call СТРОКАDI;
pop di;
ret;
END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
push di;
mov di,bx;
call СТРОКАDI;
pop di;
ret;
END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
push edi;
mov edi,ebx;
call СТРОКАDI;
pop edi;
ret;
END IF;}
;=====================}
СТРОКАCX:;{ Вывод строки адрес котрой в CX на экран
IF  (ПЛАТФОРМА = ДОС)   ;{
push di;
mov  di,cx;
call СТРОКАDI;
pop  di;
ret;
END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
push di;
mov  di,cx;
call СТРОКАDI;
pop  di;
ret;
END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
push edi;
mov  edi,ecx;
call СТРОКАDI;
pop  edi;
ret;
END IF;}
;=====================}
СТРОКАDX:;{ Вывод строки адрес котрой в DX на экран
IF  (ПЛАТФОРМА = ДОС)   ;{
push di;
mov  di,dx;
call СТРОКАDI;
pop  di;
ret;
END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
push di;
mov  di,dx;
call СТРОКАDI;
pop  di;
ret;
END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
push edi;
mov  edi,edx;
call СТРОКАDI;
pop  edi;
ret;
END IF;}
;=====================}
СТРОКАDI:;{ Вывод строки адрес котрой в SI на экран
pushad;
call ЭКРАН_ВЫВОД_ПРОБЕЛА;
call ЭКРАН_ВЫВОД_СТРОКИ;
call ЭКРАН_ВЫВОД_ПРОБЕЛА;
popad;
ret;
;=====================}
СТРОКАSI:;{ Вывод строки адрес котрой в DI на экран
IF  (ПЛАТФОРМА = ДОС)   ;{
push di;
mov di,si;
call СТРОКАDI;
pop di;
ret;
END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
push di;
mov di,si;
call СТРОКАDI;
pop di;
ret;
END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
push edi;
mov edi,esi;
call СТРОКАDI;
pop edi;
ret;
END IF;}
;=====================}

ВЫВОД_СЛОВА_РАВНО    :;{ Функция печати слова РАВНО
IF  (ПЛАТФОРМА = ДОС)   ;{
                 pushad
                 mov  di,.ТЕКС_РАВНО;
                 call ЭКРАН_ВЫВОД_СТРОКИ;
                 popad
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 pushad
                 mov  di,.ТЕКС_РАВНО;
                 call ЭКРАН_ВЫВОД_СТРОКИ;
                 popad
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 pushad
                 mov  edi,.ТЕКС_РАВНО;
                 call ЭКРАН_ВЫВОД_СТРОКИ;
                 popad
                 ret;
                 END IF;}
.ТЕКС_РАВНО: db 'РАВНО',0,0;
;==============================================================================}
ВЫВОД_СЛОВА_НЕРАВНО  :;{ Функция печати слова НЕРАВНО
IF  (ПЛАТФОРМА = ДОС)   ;{
                 pushad
                 mov  di,.ТЕКС_НЕРАВНО;
                 call ЭКРАН_ВЫВОД_СТРОКИ;
                 popad
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 pushad
                 mov  di,.ТЕКС_НЕРАВНО;
                 call ЭКРАН_ВЫВОД_СТРОКИ;
                 popad
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 pushad
                 mov  edi,.ТЕКС_НЕРАВНО;
                 call ЭКРАН_ВЫВОД_СТРОКИ;
                 popad
                 ret;
                 END IF;}
.ТЕКС_НЕРАВНО: db 'НЕРАВНО',0,0;
;==============================================================================}


ЭКРАН_ВЫВОД_СТРОКИ_AX :;{
IF  (ПЛАТФОРМА = ДОС)   ;{
                     pushad;
                     mov di,ax;
                     call ЭКРАН_ВЫВОД_СТРОКИ;
                     popad;
                     ret;
                     END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                     pushad;
                     mov di,ax;
                     call ЭКРАН_ВЫВОД_СТРОКИ;
                     popad;
                     ret;
                     END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                     pushad;
                     mov  edi,eax;
                     call ЭКРАН_ВЫВОД_СТРОКИ;
                     popad;
                     ret;
                     END IF;}

;==============================================================================}
ЭКРАН_ВЫВОД_ПРОВЕРКА  :;{ Функция печати слова ПРОВЕРКА
IF  (ПЛАТФОРМА = ДОС)   ;{
                 pushad
                 mov  di,.ТЕКС_ПРОВЕРКА;
                 call ЭКРАН_ВЫВОД_СТРОКИ;
                 popad
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 pushad
                 mov  di,.ТЕКС_ПРОВЕРКА;
                 call ЭКРАН_ВЫВОД_СТРОКИ;
                 popad
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 pushad
                 mov  Edi,.ТЕКС_ПРОВЕРКА;
                 call ЭКРАН_ВЫВОД_СТРОКИ;
                 popad
                 ret;
                 END IF;}
.ТЕКС_ПРОВЕРКА: db 'ПРОВЕРКА',0,0;
;==============================================================================}
ЭКРАН_ВЫВОД_ПРОБЕЛА   :;{ Функция печати пробела
IF  (ПЛАТФОРМА = ДОС)   ;{
                 pushad
                 mov  di,.ТЕКС_ПРОБЕЛ  ;
                 call ЭКРАН_ВЫВОД_СТРОКИ;
                 popad
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 pushad
                 mov  di,.ТЕКС_ПРОБЕЛ  ;
                 call ЭКРАН_ВЫВОД_СТРОКИ;
                 popad
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 pushad
                 mov  Edi,.ТЕКС_ПРОБЕЛ  ;
                 call ЭКРАН_ВЫВОД_СТРОКИ;
                 popad
                 ret;
                 END IF;}
.ТЕКС_ПРОБЕЛ: db ' ',0,0;
;==============================================================================}
ЭКРАН_ВЫВОД_ПЕРСТРО   :;{ Функция печати перевода строки
IF  (ПЛАТФОРМА = ДОС)   ;{
                 pushad
                 mov  di,.ТЕКС_ПЕРЕВОД_СТРОКИ;
                 call ЭКРАН_ВЫВОД_СТРОКИ      ;
                 popad
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T16)   ;{
                 pushad
                 mov  di,.ТЕКС_ПЕРЕВОД_СТРОКИ;
                 call ЭКРАН_ВЫВОД_СТРОКИ      ;
                 popad
                 ret;
                 END IF;}
IF  (ПЛАТФОРМА = T32)   ;{
                 pushad
                 mov  edi,.ТЕКС_ПЕРЕВОД_СТРОКИ;
                 call ЭКРАН_ВЫВОД_СТРОКИ      ;
                 popad
                 ret;
                 END IF;}

.ТЕКС_ПЕРЕВОД_СТРОКИ: db 13,10,0,0;
;==============================================================================}


;---}
;---{ ФУНКЦИИ ДЛЯ РАБОТЫ С МЫШКОЙ           .

МЫШКА_НАРИСОВАТЬ:;{
               pushad;
               mov  cl,[МЫШ_КООX1];
               mov  dl,[МЫШ_КООY1];
               mov  al,' ';
               mov  ah,[МЫШ_ЦВЕТА];
               call ЭКРАН_ВЫВОД_AX_CX_DX;// Вывод Символа Al с атрибутами AH на экран в координатах x CX,y DX так как AL=0 символна экране не затираеться выводяться тока атрибуты
               popad;
               ret
;==============================================================================}
МЫШКА_ВКЛЮЧИТЬ :;{ Инициализация мышки установка атрибутов мышки AX в
            pushad;
            Call МЫШ_ИНИЦИАЛИЗАЦИЯ;
            popad;
            ret;
;==============================================================================}
МЫШКА_ЧИТАТЬ   :;{ Читает коррдинату мышки и номер нажатой кнопки все нижеследующие переменные
             pushad;

             Mov cx,[МЫШ_КООX2];
             Mov dx,[МЫШ_КООY2];
             Mov bx,[МЫШ_КНОП2];

             Mov [МЫШ_КООX1],CX;
             Mov [МЫШ_КООY1],DX;
             Mov [МЫШ_КНОП1],BX;

             mov ax,[МЫШ_ВЫДЕ2];
             mov [МЫШ_ВЫДЕ1],ax;

             call МЫШ_ЧТЕНИЕ2;
             Mov cx,[МЫШКА_X1];
             Mov dx,[МЫШКА_Y1];
             Mov bx,[МЫШКА_I1];

             Mov [МЫШ_КООX2],CX;
             Mov [МЫШ_КООY2],DX;
             Mov [МЫШ_КНОП2],BX;
             popad;
             ret;
;==============================================================================}
МЫШКА_СОСТОЯНИЕ:;{ ПРоверяет на сосотвествее нажатия кнопок  предыдущий  состояние должно быть cl в след состояние  ch
             pushad;
             ;----------------------
             mov  al,[МЫШ_КНОП1]   ;// ПРедыдущие состояние кнопки не нажата
             cmp  al,cl            ;
             JNZ .НЕПОДХОДИТ       ;
             ;----------------------
             mov  al,[МЫШ_КНОП2]   ;// новое состояние кнопки  нажата
             cmp  al,ch            ;
             JNZ .НЕПОДХОДИТ       ;
             ;----------------------

             mov  al,1             ;
             test al,al            ;

             JMP .ВЫХОД            ;
.НЕПОДХОДИТ:
             mov  al,0             ;
             test al,al            ;
.ВЫХОД:
             popad;
             ret;
;==============================================================================}
МЫШКА_ЩЕЛЧЕК   :;{ ПРоверяет была ли щас нажата мышка
             pushad;
             mov  cl,0           ;// ПРедыдущие состояне не нажата никакая кнопка
             mov  ch,1           ;// Новое состояние нажата левая кнопка мышки
             call МЫШКА_СОСТОЯНИЕ;// Проверка на соотвествие указаным выше условиям
             popad;
             ret;
;==============================================================================}
МЫШКА_НАЖАТА   :;{ ПРоверяет нажата ли щас нажата мышка
             pushad;
             mov  cl,1           ;// ПРедыдущие состояние нажата левая кнопка мышки
             mov  ch,1           ;// Новое состояние нажата левая кнопка мышки
             call МЫШКА_СОСТОЯНИЕ;// Проверка на соотвествие указаным выше условиям
             popad;
             ret;
;==============================================================================}

МЫШ_КООX1: DD 0 ;// предыдущая Координаты мышки для X
МЫШ_КООY1: DD 0 ;// предыдущая Координаты мышки для Y
МЫШ_КНОП1: DD 0 ;// предыдущая Нажатая кнопка на мышке

МЫШ_КООX2: DD 0 ;// Координаты мышки для X
МЫШ_КООY2: DD 0 ;// Координаты мышки для Y
МЫШ_КНОП2: DD 0 ;// Нажатая кнопка на мышке

МЫШ_ЦВЕТА: DD 00010000b ;// Атрибуты мышки 10010000b

;---}
;---{ ФУНКЦИИ ДЛЯ РАБОТЫ С КЛВИАТУРОЙ       .

КЛАВИАТУРА_ЧИТАТЬ :;{ Читаем код нажатой кнопки В  [НАЖ_КНОПК]
             pushad;

             IF ПЛАТФОРМА = ДОС  ;{
             mov ah,01h;// ПРоверяет готовность символа
             int 16h   ;
             jz .ВЫХОД ;
             mov ah,00h;// Если кнопка готова читаем код
             int 16h   ;
             mov [НАЖ_КНОПК],AX;

.ВЫХОД:
             END IF    ;}
             IF ПЛАТФОРМА = T16  ;{
             END IF ;}
             IF ПЛАТФОРМА = T32  ;{


             END IF ;}

             popad;
             ret;
;==============================================================================}
ОЖИДАНИЕ_ЛЮБОЙ_КНОПКИ:;{ Ожидание нажатия любой кнопки паузка
        pushad;


        IF ПЛАТФОРМА = ДОС  ;{
        mov ah,8h;
        int 21h;
        END IF;}
        IF ПЛАТФОРМА = T16  ;{
        mov  bx,[НАЖ_КНОПК]       ;
.ПОВТОР:
        call МЫШКА_ЧИТАТЬ         ; // Читает координаты мышки
        call КЛАВИАТУРА_ЧИТАТЬ    ; // Читает нажатую кнопку на клавиатуре и запоминает в переменную [НАЖ_КНОПК]

        mov  ax,[НАЖ_КНОПК]       ;
        cmp  ax,bx                ;
        jnz .ПОВТОР               ;

        END IF;}
        IF ПЛАТФОРМА = T32  ;{
.ПОВТОР:
        mov  al,[keypress]        ;
        test al,al                ;
        jnz .ПОВТОР               ;
        mov [keypress],byte 1     ;
        END IF;}

        popad;
        ret;
;==============================================================================}
ПАУЗА:;{
pushad;
call ОЖИДАНИЕ_ЛЮБОЙ_КНОПКИ;
popad;
ret;
;}
НАЖ_КНОПК: DW 0 ;// Последняя нажатая кнопка
;---}
;---{ ФУНКЦИИ ДЛЯ РАБОТЫ С ПАМЯТЬЮ          .
БИОС_ВКЛЮЧИТЬ_ПАМЯТЬ             :;{ Инициализация памяти
                    IF  (ПЛАТФОРМА = ДОС)   ;{
                    pushad                  ;
                    MOV   AX,КОНЕЦ_ПРОГРАММЫ;
                    MOV  [НАЧ_КУЧИ],AX      ;// Установка адреса начала кучи
                    mov   AX,65000          ;
                    MOV  [КОН_КУЧИ],AX      ;// Установка Окончания Кучи
                    MOV   SI,[НАЧ_КУЧИ]     ;
                    MOV   DI,[КОН_КУЧИ]     ;
                    call  ОЧИСТКА_ПАМЯТИ_С_SI_ДО_DI;// Производим очистку памяти
                    popad                   ;
                    ret                     ;
                    END IF;-----------------}
                    IF  (ПЛАТФОРМА = T16)   ;{
                    pushad                   ;
                    MOV   AX,КОНЕЦ_ПРОГРАММЫ;
                    MOV  [НАЧ_КУЧИ],AX      ;// Установка адреса начала кучи
                    mov   AX,65000          ;
                    MOV  [КОН_КУЧИ],AX      ;// Установка Окончания Кучи
                    MOV   SI,[НАЧ_КУЧИ]     ;
                    MOV   DI,[КОН_КУЧИ]     ;
                    call  ОЧИСТКА_ПАМЯТИ_С_SI_ДО_DI;// Производим очистку памяти
                    popad                    ;
                    ret                      ;
                    END IF;------------------}
                    IF  (ПЛАТФОРМА = T32)   ;{
                    pushad                  ;
                    MOV  EAX,КОНЕЦ_ПРОГРАММЫ;
                    MOV [НАЧ_КУЧИ],EAX      ;// Установка адреса начала кучи
                    mov  EAX,190000         ;
                    MOV [КОН_КУЧИ],EAX      ;// Установка Окончания Кучи
                    MOV  ESI,[НАЧ_КУЧИ]     ;
                    MOV  EDI,[КОН_КУЧИ]     ;
                    call ОЧИСТКА_ПАМЯТИ_С_SI_ДО_DI;// Производим очистку памяти
                    popad                   ;
                    ret                     ;
                    END IF;------------------}
;==============================================================================}
ОЧИСТКА_ПАМЯТИ_С_SI_ДО_DI        :;{ Очистка памяти с адреса  SI до адреса  DI  Уже не входит в очистку
IF  (ПЛАТФОРМА = ДОС)   ; {
      pushad            ; // Сохранение содержимого всех регистров
.ЦИКЛ:;-----------------; //
      CMP   SI,DI       ; // Чтение адрсеа окончания кучи
      JAE  .КЦИК        ; // Если SI>DI то выход
      mov   [SI],Byte 0 ; // Запись нуля по адресу SI
      INC   SI          ; // Увеличиываем SI
      JMP  .ЦИКЛ        ; // Повторить
.КЦИК:;-----------------; //
      popad             ; // Вотсановление всех регистров
      ret               ; // Выход из подпрограммы
      END IF;-----------; }
IF  (ПЛАТФОРМА = T16)   ; {
      pushad            ; // Сохранение содержимого всех регистров
.ЦИКЛ:;-----------------; //
      CMP   SI,DI       ; // Чтение адрсеа окончания кучи
      JAE  .КЦИК        ; // Если SI>DI то выход
      mov   [SI],Byte 0 ; // Запись нуля по адресу SI
      INC   SI          ; // Увеличиываем SI
      JMP  .ЦИКЛ        ; // Повторить
.КЦИК:;-----------------; //
      popad             ; // Вотсановление всех регистров
      ret               ; // Выход из подпрограммы
      END IF;-----------; }
IF  (ПЛАТФОРМА = T32)   ; {
      pushad            ; // Сохранение содержимого всех регистров
.ЦИКЛ:;-----------------; //
      CMP   ESI,EDI       ; // Чтение адрсеа окончания кучи
      JAE  .КЦИК        ; // Если SI>DI то выход
      mov   [ESI],Byte 0; // Запись нуля по адресу SI
      INC   ESI         ; // Увеличиываем SI
      JMP  .ЦИКЛ        ; // Повторить
.КЦИК:;-----------------; //
      popad             ; // Вотсановление всех регистров
      ret               ; // Выход из подпрограммы
      END IF;-----------; }
;==============================================================================}
ОСВОБОЖДЕНИЕ_УЧАСТКА_ПАМЯТИ_DI   :;{ Освобождение участка памяти DI Адрес полученый ранее например с помощбю функции ПАМЯТЬ_ВЫДЕЛИТЬ
IF  (ПЛАТФОРМА = ДОС)    ; {
         pushad          ;
         SUB  DI,3       ;// Переходим к байту занятости
         MOV  [DI],Byte 0;// И обнуляем его
         inc  di         ;
         mov  cx,[di]    ; // Читаем размер участка
         add  di,2       ; // Переходим к  первому байту участка памяти
         mov  si,di      ; //устанавливаем начало стираемого участка памяти
         add  di,CX      ; // устанавливаем конец стираемого участка памяти
         call ОЧИСТКА_ПАМЯТИ_С_SI_ДО_DI;
         popad           ;
         RET             ;
         END IF          ;}
IF  (ПЛАТФОРМА = T16)    ; {
         pushad          ;
         SUB  DI,3       ;// Переходим к байту занятости
         MOV  [DI],Byte 0;// И обнуляем его
         inc  di         ;
         mov  cx,[di]    ; // Читаем размер участка
         add  di,2       ; // Переходим к  первому байту участка памяти
         mov  si,di      ; //устанавливаем начало стираемого участка памяти
         add  di,CX      ; // устанавливаем конец стираемого участка памяти
         call ОЧИСТКА_ПАМЯТИ_С_SI_ДО_DI;
         popad           ;
         RET             ;
         END IF          ;}
IF  (ПЛАТФОРМА = T32)    ; {
         pushad           ;
         SUB  EDI,5       ;// Переходим к байту занятости
         MOV  [EDI],Byte 0;// И обнуляем его
         inc  Edi         ;
         mov  Ecx,[Edi]   ; // Читаем размер участка
         add  Edi,4       ; // Переходим к  первому байту участка памяти
         mov  Esi,Edi     ; //устанавливаем начало стираемого участка памяти
         add  Edi,ECX     ; // устанавливаем конец стираемого участка памяти
         call ОЧИСТКА_ПАМЯТИ_С_SI_ДО_DI;
         popad            ;
         RET              ;
         END IF           ;}
;==============================================================================}
ОСВОБОЖДЕНИЕ_УЧАСТКА_ПАМЯТИ_DX   :;{ Освобождает участок памяти DX
push di;
mov di,dx;
pop di;
ret;
;}
ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI:;{ Выделяет участок памяти размером DI Возвращает адрес выделеного участка в DI
IF  (ПЛАТФОРМА = ДОС)   ;{
         PUSHAD             ;
         MOV  SI,[НАЧ_КУЧИ] ; Читаем адрес начала кучи
.ЦИКЛ:   ;//----------------;
         MOV  AL,[SI]       ; Читаем флаг занятости
         INC  SI            ; Увеличиваем указатель
         MOV  CX,[SI]       ; Читаем размер участка памяти
         TEST AL,AL         ; Проверка флага занятости
         JNZ .СЛЕ_УЧА       ; Если не равно нулю переходим к следующему участку
         TEST CX,CX         ;
         JZ  .СВОБ          ; Участок подходит если это последний участок в куче с нулевым размерм
         CMP  CX,DI         ; Сравниваем размер участка CX и размер запрашиваемого участка DI
         JZ  .СВОБ          ; Участок подходит если размер участка соотвествующий
.СЛЕ_УЧА:
         ADD  CX,2          ; Переход к след участку размер этого участка + 2 байта попадаем на байт занятости следующего участка
         ADD  SI,CX         ;
         JMP .ЦИКЛ          ;

.СВОБ:   ;//---------------
         DEC  SI            ;
         MOV  byte [SI],1   ; // Устанавливаем флаг занятости
         INC  SI            ; // Переходим к указанию размера учатка
         MOV [SI],DI        ; // Записываем размер участка
         ADD  SI,2          ; // прибавляем 2 получаем адрес Выделеного участка
         MOV  DI,SI         ; // Возвращаем адрес выделеного участка в регистсре DI
         ;//---------------
         test DI,DI         ;
         POP  SI            ;
         PUSH DI            ; // DI на вершие стека всегда
         POPAD              ;
         RET                ;
         END IF             ; }
IF  (ПЛАТФОРМА = T16)   ;{
         PUSHAD             ;
         MOV  SI,[НАЧ_КУЧИ] ; Читаем адрес начала кучи
.ЦИКЛ:   ;//----------------;
         MOV  AL,[SI]       ; Читаем флаг занятости
         INC  SI            ; Увеличиваем указатель
         MOV  CX,[SI]       ; Читаем размер участка памяти
         TEST AL,AL         ; Проверка флага занятости
         JNZ .СЛЕ_УЧА       ; Если не равно нулю переходим к следующему участку
         TEST CX,CX         ;
         JZ  .СВОБ          ; Участок подходит если это последний участок в куче с нулевым размерм
         CMP  CX,DI         ; Сравниваем размер участка CX и размер запрашиваемого участка DI
         JZ  .СВОБ          ; Участок подходит если размер участка соотвествующий
.СЛЕ_УЧА:
         ADD  CX,2          ; Переход к след участку размер этого участка + 2 байта попадаем на байт занятости следующего участка
         ADD  SI,CX         ;
         JMP .ЦИКЛ          ;

.СВОБ:   ;//----------------;
         DEC  SI            ;
         MOV  byte [SI],1   ; // Устанавливаем флаг занятости
         INC  SI            ; // Переходим к указанию размера учатка
         MOV [SI],DI        ; // Записываем размер участка
         ADD  SI,2          ; // прибавляем 2 получаем адрес Выделеного участка
         MOV  DI,SI         ; // Возвращаем адрес выделеного участка в регистсре DI
         ;//----------------;
         test DI,DI         ;
         POP  SI            ;
         PUSH DI            ; // DI на вершие стека всегда
         POPAD              ;
         RET                ;
         END IF             ; }
IF  (ПЛАТФОРМА = T32)   ;{
         PUSHAD             ;
         MOV  ESI,[НАЧ_КУЧИ]; Читаем адрес начала кучи
.ЦИКЛ:   ;//----------------;
         MOV  AL,[ESI]      ; Читаем флаг занятости
         INC  ESI           ; Увеличиваем указатель
         MOV  ECX,[ESI]     ; Читаем размер участка памяти
         TEST AL,AL         ; Проверка флага занятости
         JNZ .СЛЕ_УЧА       ; Если не равно нулю переходим к следующему участку
         TEST ECX,ECX       ;
         JZ  .СВОБ          ; Участок подходит если это последний участок в куче с нулевым размерм
         CMP  ECX,EDI       ; Сравниваем размер участка CX и размер запрашиваемого участка DI
         JZ  .СВОБ          ; Участок подходит если размер участка соотвествующий
.СЛЕ_УЧА:
         ADD  ECX,4         ; Переход к след участку размер этого участка + 2 байта попадаем на байт занятости следующего участка
         ADD  ESI,ECX       ;
         JMP .ЦИКЛ          ;

.СВОБ:   ;//---------------
         DEC  ESI           ;
         MOV  [ESI],byte  1 ; // Устанавливаем флаг занятости
         INC  ESI           ; // Переходим к указанию размера учатка
         MOV [ESI],EDI      ; // Записываем размер участка
         ADD  ESI,4         ; // прибавляем 4 получаем адрес Выделеного участка
         MOV  EDI,ESI       ; // Возвращаем адрес выделеного участка в регистсре DI
         ;//---------------
         test EDI,EDI       ;
         POP  ESI           ;
         PUSH EDI           ; // DI на вершие стека всегда
         POPAD              ;
         RET                ;
         END IF             ; }
;==============================================================================}
ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DX_РАЗ_DX:;{ Выделяет участок памяти размером DX Возвращает адрес выделеного участка в DX
IF  (ПЛАТФОРМА = ДОС)   ;{
push di                               ; // Все это не идеально но потом можно переделать
mov  di,dx                            ; // Кагда все уже будет раблотать целиком
call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;
mov  dx,di                            ;
pop  di                               ;
ret                                   ;
END IF                                ;}
IF  (ПЛАТФОРМА = T16)   ;{
push di                               ; // Все это не идеально но потом можно переделать
mov  di,dx                            ; // Кагда все уже будет раблотать целиком
call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;
mov  dx,di                            ;
pop  di                               ;
ret                                   ;
END IF                                ;}
IF  (ПЛАТФОРМА = T32)   ;{
push Edi                              ; // Все это не идеально но потом можно переделать
mov  Edi,Edx                          ; // Кагда все уже будет раблотать целиком
call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;
mov  Edx,Edi                          ;
pop  Edi                              ;
ret                                   ;
END IF                                ;}
;}
РАЗМЕР_DX_УЧАСТКА_ПАМЯТИ_DI      :;{ Возвращает размер выделеного участка памяти DI в регистре DX
IF  (ПЛАТФОРМА = ДОС) ;{
push ax          ;
call РАЗМЕР_AX_УЧАСТКА_ПАМЯТИ_DI;
mov  DX,ax       ;
pop  ax          ;
ret              ;
END IF           ;}
IF  (ПЛАТФОРМА = T16) ;{
push ax          ;
call РАЗМЕР_AX_УЧАСТКА_ПАМЯТИ_DI;
mov  DX,ax       ;
pop  ax          ;
ret              ;
END IF           ;}
IF  (ПЛАТФОРМА = T32) ;{
push eax         ;
call РАЗМЕР_AX_УЧАСТКА_ПАМЯТИ_DI;
mov  eDX,eax     ;
pop  eax         ;
ret              ;
END IF           ;}
;}
РАЗМЕР_AX_УЧАСТКА_ПАМЯТИ_DI      :;{ Возвращает размер участка памяти DI
IF  (ПЛАТФОРМА = ДОС)   ;{
push di                 ;
sub  di,2               ;
mov  ax,[di]            ;
pop  di                 ;
ret                     ;
END IF                  ;}
IF  (ПЛАТФОРМА = T16)   ;{
push di                 ;
sub  di,2               ;
mov  ax,[di]            ;
pop  di                 ;
ret                     ;
END IF                  ;}
IF  (ПЛАТФОРМА = T32)   ;{
push edi                ;
sub  edi,4              ;
mov  eax,[edi]          ;
pop  edi                ;
ret                     ;
END IF                  ;}
;}
ЗАНЯТАЯ_ПАМЯТЬ                   :;{ Считает Количество занятой памяти
IF  (ПЛАТФОРМА = ДОС)       ;{
         pushad             ;
         MOV  SI,[НАЧ_КУЧИ] ; Читаем адрес начала кучи
         mov  bx,0          ;
.ЦИКЛ:   ;------------------;
         MOV  AL,[SI]       ; Читаем флаг занятости
         INC  SI            ; Увеличиваем указатель
         MOV  CX,[SI]       ; Читаем размер участка памяти
         TEST AL,AL         ; Проверка флага занятости
         JNZ .СЛЕ_УЧА       ; Если не равно нулю переходим к следующему участку
         TEST CX,CX         ;
         JZ  .ВЫХОД         ; Участок подходит если это последний участок в куче с нулевым размерм
         ADD  CX,2          ; Переход к след участку размер этого участка + 2 байта попадаем на байт занятости следующего участка
         ADD  SI,CX         ;
         JMP .ЦИКЛ          ;

.СЛЕ_УЧА:
         ADD  CX,2          ; Переход к след участку размер этого участка + 2 байта попадаем на байт занятости следующего участка
         ADD  SI,CX         ;
         add  bx,cx         ;
         JMP .ЦИКЛ          ;

.ВЫХОД:  mov  di,bx         ;
         POP  SI            ;
         PUSH DI            ; // DI на вершие стека всегда
         POPAD              ;
         RET                ;
         END IF             ;}
IF  (ПЛАТФОРМА = T16)       ;{
         pushad             ;
         MOV  SI,[НАЧ_КУЧИ] ; Читаем адрес начала кучи
         mov  bx,0          ;
.ЦИКЛ:   ;------------------;
         MOV  AL,[SI]       ; Читаем флаг занятости
         INC  SI            ; Увеличиваем указатель
         MOV  CX,[SI]       ; Читаем размер участка памяти
         TEST AL,AL         ; Проверка флага занятости
         JNZ .СЛЕ_УЧА       ; Если не равно нулю переходим к следующему участку
         TEST CX,CX         ;
         JZ  .ВЫХОД         ; Участок подходит если это последний участок в куче с нулевым размерм
         ADD  CX,2          ; Переход к след участку размер этого участка + 2 байта попадаем на байт занятости следующего участка
         ADD  SI,CX         ;
         JMP .ЦИКЛ          ;

.СЛЕ_УЧА:
         ADD  CX,2          ; Переход к след участку размер этого участка + 2 байта попадаем на байт занятости следующего участка
         ADD  SI,CX         ;
         add  bx,cx         ;
         JMP .ЦИКЛ          ;

.ВЫХОД:  mov  di,bx         ;
         POP  SI            ;
         PUSH DI            ; // DI на вершие стека всегда
         POPAD              ;
         RET                ;
         END IF             ;}
IF  (ПЛАТФОРМА = T32)       ;{
         pushad             ;
         MOV  ESI,[НАЧ_КУЧИ]; Читаем адрес начала кучи
         mov  Ebx,0         ;
.ЦИКЛ:   ;------------------;

         MOV  AL,[ESI]      ; Читаем флаг занятости
         INC  ESI           ; Увеличиваем указатель

         MOV  ECX,[ESI]     ; Читаем размер участка памяти
         TEST ECX,ECX       ; ПРоверка размера участка
         JZ  .ВЫХОД         ; Заканчиваем поиск если это последний участок в куче с нулевым размерм

         TEST AL,AL         ; Проверка флага занятости
         JNZ .СЛЕ_УЧА       ; Если не равно нулю переходим к следующему участку

         ADD  ECX,4         ; Переход к след участку размер этого участка + 2 байта попадаем на байт занятости следующего участка
         ADD  ESI,ECX       ;
         JMP .ЦИКЛ          ;

.СЛЕ_УЧА:
         ADD  ECX,4         ; Переход к след участку размер этого участка + 2 байта попадаем на байт занятости следующего участка
         ADD  ESI,ECX       ;
         ADD  EBX,ECX       ;
         INC  EBX;
         JMP .ЦИКЛ          ;

.ВЫХОД:  mov  Edi,Ebx       ;
         POP  ESI           ;
         PUSH EDI           ; // DI на вершие стека всегда
         POPAD              ;
         RET                ;
         END IF             ;}

;}
;ПЕРЕМЕННЫЕ                      ::{ Опсиания необходимых переменных
IF  (ПЛАТФОРМА = ДОС)   ;{
НАЧ_КУЧИ : DW 0 ;// Адрес начала кучи
КОН_КУЧИ : DW 0 ;// Адрес Окончания Кучи
END IF          ;}
IF  (ПЛАТФОРМА = T16)   ;{
НАЧ_КУЧИ : DW 0 ;// Адрес начала кучи
КОН_КУЧИ : DW 0 ;// Адрес Окончания Кучи
END IF          ;}
IF  (ПЛАТФОРМА = T32)   ;{
НАЧ_КУЧИ : DD 0 ;// Адрес начала кучи
КОН_КУЧИ : DD 0 ;// Адрес Окончания Кучи
END IF          ;}
;}
;---}
;---{ ФУНКЦИB ДЛЯ РАБОТЫ С ПАУЗАМИ          .

БИОС_ПАУЗА          :;{ Пауза в микросекундах
IF  (ПЛАТФОРМА = ДОС)   ;{
pushad      ;
MOV CX,0000h;// Старшие разряды количества микросек
MOV DX,3333h;// Младшие разряды количесвтва микросекунд
MOV AH,86H  ;// Номер Функции DELAY паузы в DOS
INT 15h     ;// Прервыание для функции
popad       ;
ret         ;
END IF      ;}
IF  (ПЛАТФОРМА = T16)   ;{
pushad      ;
MOV CX,0000h;// Старшие разряды количества микросек
MOV DX,3333h;// Младшие разряды количесвтва микросекунд
MOV AH,86H  ;// Номер Функции DELAY паузы в DOS
INT 15h     ;// Прервыание для функции
popad       ;
ret         ;
END IF      ;}
IF  (ПЛАТФОРМА = T32)   ;{
pushad      ;

popad       ;
ret         ;
END IF      ;}
;==============================================================================}

;---}
;---{ ФУНКЦИИ ДЛЯ РАБОТЫ НА НИЗКОМ УРОВНЕ   .


КУРСОР              :;{Установка курсора влевый верхний угол
pushad;
mov cx,0;
mov dx,0;
call ЭКРАН_КУРСОР_XY;
call ЭКРАН_ОЧИСТКА;
popad;
ret;
;}
ПОДГОТОВКА_К_ЗАПУСКУ:;{ ПОдготовка всего того что нужно для работы
             pushad;
             IF  (ПЛАТФОРМА = T32);{
             call TR_PS2_ИНИЦИАЛИЗАЦИЯ ;
             END IF;}
             IF  (ПЛАТФОРМА = T16);{
             call TR_ПРЕРЫВАНИЯ_ВЫКЛ

             mov EAX,[8*4]                        ; // Читаю адрес котрый уже установлен
             mov [TR_INT_08_БИОС_ТАЙМЕР],eax      ; // Сохраняю адрес
             mov EAX,(8*4)                        ;
             mov [EAX],DWORD I32                  ; // Устанавливаю свое прерыывание


             mov EAX,[9*4]                        ; // Читаю адрес котрый уже установлен
             mov [TR_INT_09_БИОС_КЛАВИАТУРА],eax  ; // Сохраняю адрес
             mov EAX,(9*4)                        ;
             mov [EAX],DWORD I33                  ; // Устанавливаю свое прерыывание

             ;// Устанавливаю обработчик прерывания от мышки
             mov EAX,[116*4]                      ; // Читаю адрес котрый уже установлен
             mov [TR_INT_74_БИОС_МЫШКА],eax       ; // Сохраняю адрес
             mov EAX,(116*4)                      ;
             mov [EAX],DWORD I44                  ; // Устанавливаю свое прерыывание

             call TR_PS2_ИНИЦИАЛИЗАЦИЯ;
             call TR_ПРЕРЫВАНИЯ_ВКЛ
             END IF ;}
             call БИОС_ВКЛЮЧИТЬ_ПАМЯТЬ    ;// ПОдготовка памяти для работы системы
             call ЭКРАН_ПОДГОТОВИТЬ       ;// Подготовка  Экрана для работы
             Call ПОДГОТОВКА_СЛОВАРЯ      ;// Выделяет память под словарь
             call МЫШКА_ВКЛЮЧИТЬ          ;// Включаем мышку
             call СОЗДАТЬ_КОРНЕВОЙ_ЭЛЕМЕНТ;// Включение корневого элемента
             call СОЗДАТЬ_ТАБЛИЦУ_ПОТОКОВ ;
             popad;
             ret;

;========================================================================================}
ЗАВЕРШЕНИЕ_РАБОТЫ   :;{ ЗАвершение программы
                    int 20h;
                    ret;
;==============================================================================}
ЭКРАН_ПОДГОТОВИТЬ   :;{ ПОдготовка видео буфера и экрана
            pushad;
            mov  al,[РЕЖИМ_ЭКРАНА]      ;// Читем режжим работы экрана
            ;---------------------------;
            cmp  al,0                   ;
            jz  .НЕ_ВЫБРАН              ;// Если видеорежим не выбран
            ;---------------------------;
            cmp  al,1                   ;// Если режим тектовый 80 на 25
            jnz .НЕТ_ТАКОГО             ;// НЕизвестный видеорежим нет такого видеорежима
            ;---------------------------;
            call ЭКРАН_80_25_ПОДГОТОВИТЬ;// ПОдготовка ВИДЕОРЕЖИМА 80 на 25 тектовый;
            jmp .ВЫХОД                  ;
            ;---------------------------;
.НЕ_ВЫБРАН: MOV  AX,1                   ;// КРИТИЧЕСКАЯ ОШИБКА №1 НЕ ВЫБРАН ВИДОРЕЖИМ
            Call КРИТИЧЕСКАЯ_ОШИБКА     ;
            jmp .ВЫХОД                  ;
            ;---------------------------;
.НЕТ_ТАКОГО:MOV  AX,2                   ;// КРИТИЧЕСКАЯ ОШИБКА №2 НЕ ИЗВЕТНЫЙ ВИДЕОРЕЖИМ
            Call КРИТИЧЕСКАЯ_ОШИБКА     ;
            jmp .ВЫХОД                  ;
            ;---------------------------;
.ВЫХОД:     popad                       ;
            ret                         ;
           ;{ОПИСАНИЕ ПРОЦЕДУРЫ
           ; ПРоцедура очистки экрана в заыисимости от установлденого
           ; видеорежима
           ;
           ;
           ;}
;}
ЭКРАН_ОЧИСТКА       :;{ Очистка экрана
            pushad;
            mov  al,[РЕЖИМ_ЭКРАНА]  ;// Читем режжим работы экрана
            ;-----------------------;
            cmp  al,0               ;
            jz  .НЕ_ВЫБРАН          ;// Если видеорежим не выбран
            ;-----------------------;
            cmp  al,1               ;// Если режим тектовый 80 на 25
            jnz .НЕТ_ТАКОГО         ;// НЕизвестный видеорежим нет такого видеорежима
            ;-----------------------;
            call ЭКРАН_80_25_ОЧИСТКА;// УСТНОВКА ВИДЕОРЕЖИМА 80 на 25 тектовый;
            jmp .ВЫХОД              ;
            ;-----------------------;
.НЕ_ВЫБРАН: MOV  AX,1               ;// КРИТИЧЕСКАЯ ОШИБКА №1 НЕ ВЫБРАН ВИДОРЕЖИМ
            Call КРИТИЧЕСКАЯ_ОШИБКА ;
            jmp .ВЫХОД              ;
            ;-----------------------;
.НЕТ_ТАКОГО:MOV  AX,2               ;// КРИТИЧЕСКАЯ ОШИБКА №2 НЕ ИЗВЕТНЫЙ ВИДЕОРЕЖИМ
            Call КРИТИЧЕСКАЯ_ОШИБКА ;
            jmp .ВЫХОД              ;
            ;-----------------------;
.ВЫХОД:     popad                   ;
            ret                     ;
           ;{ОПИСАНИЕ ПРОЦЕДУРЫ
           ; ПРоцедура очистки экрана в заыисимости от установлденого
           ; видеорежима
           ;
           ;
           ;}
;}
ЭКРАН_ВЫВОД         :;{ Выводит содержимое видеобуфера на реальный экран
            pushad;
            mov  al,[РЕЖИМ_ЭКРАНА]      ;// Читем режжим работы экрана
            ;---------------------------;
            cmp  al,0                   ;
            jz  .НЕ_ВЫБРАН              ;// Если видеорежим не выбран
            ;---------------------------;
            cmp  al,1                   ;// Если режим тектовый 80 на 25
            jnz .НЕТ_ТАКОГО             ;// НЕизвестный видеорежим нет такого видеорежима
            ;---------------------------;
            call ЭКРАН_80_25_ЭКРАН_ВЫВОД;// вывод на экран буфера в режиме 80 на 25 тектовый;
            jmp .ВЫХОД                  ;
            ;---------------------------;
.НЕ_ВЫБРАН: MOV  AX,1                   ;// КРИТИЧЕСКАЯ ОШИБКА №1 НЕ ВЫБРАН ВИДОРЕЖИМ
            Call КРИТИЧЕСКАЯ_ОШИБКА     ;
            jmp .ВЫХОД                  ;
            ;---------------------------;
.НЕТ_ТАКОГО:MOV  AX,2                   ;// КРИТИЧЕСКАЯ ОШИБКА №2 НЕ ИЗВЕТНЫЙ ВИДЕОРЕЖИМ
            Call КРИТИЧЕСКАЯ_ОШИБКА     ;
            jmp .ВЫХОД                  ;
            ;---------------------------;
.ВЫХОД:     popad                       ;
            ret                         ;
           ;{ОПИСАНИЕ ПРОЦЕДУРЫ
           ; Вывод видео буфера на экран  в заыисимости от установлденого
           ; видеорежима
           ;
           ;
           ;}

;}
ЭКРАН_КУРСОР_XY     :;{ Устанавливает курсор в заданую позицю
            pushad;
            mov  al,[РЕЖИМ_ЭКРАНА]       ;// Читем режжим работы экрана
            ;----------------------------;
            cmp  al,0                    ;
            jz  .НЕ_ВЫБРАН               ;// Если видеорежим не выбран
            ;----------------------------;
            cmp  al,1                    ;// Если режим тектовый 80 на 25
            jnz .НЕТ_ТАКОГО              ;// НЕизвестный видеорежим нет такого видеорежима
            ;----------------------------;
            call ЭКРАН_80_25_КУРСОР_CX_DX;// Установка курсора на экране  в режиме 80 на 25 тектовый;
            jmp .ВЫХОД                   ;
            ;----------------------------;
.НЕ_ВЫБРАН: MOV  AX,1                    ;// КРИТИЧЕСКАЯ ОШИБКА №1 НЕ ВЫБРАН ВИДОРЕЖИМ
            Call КРИТИЧЕСКАЯ_ОШИБКА      ;
            jmp .ВЫХОД                   ;
            ;----------------------------;
.НЕТ_ТАКОГО:MOV  AX,2                    ;// КРИТИЧЕСКАЯ ОШИБКА №2 НЕ ИЗВЕТНЫЙ ВИДЕОРЕЖИМ
            Call КРИТИЧЕСКАЯ_ОШИБКА      ;
            jmp .ВЫХОД                   ;
            ;----------------------------;
.ВЫХОД:     popad                        ;
            ret                          ;
           ;{ОПИСАНИЕ ПРОЦЕДУРЫ
           ; Устнвоока курсора в заданую позицю в заыисимости от установлденого
           ; видеорежима
           ;
           ;
           ;}


;}
ЭКРАН_ВЫВОД_СТРОКИ  :;{ Выводит строку DI на экран
IF (ПЛАТФОРМА = ДОС);{
            pushad;
            mov  al,[РЕЖИМ_ЭКРАНА]          ;// Читем режжим работы экрана
            ;-------------------------------;
            cmp  al,0                       ;
            jz  .НЕ_ВЫБРАН                  ;// Если видеорежим не выбран
            ;-------------------------------;
            cmp  al,1                       ;// Если режим тектовый 80 на 25
            jnz .НЕТ_ТАКОГО                 ;// НЕизвестный видеорежим нет такого видеорежима
            ;-------------------------------;
            mov  si,di                      ;// перемещение DI в SI
            call ЭКРАН_80_25_ВЫВОД_СТРОКИ_SI;// вывод на экран строки SI в режиме 80 на 25 тектовый;
            jmp .ВЫХОД                      ;
            ;-------------------------------;
.НЕ_ВЫБРАН: MOV  AX,1                       ;// КРИТИЧЕСКАЯ ОШИБКА №1 НЕ ВЫБРАН ВИДОРЕЖИМ
            Call КРИТИЧЕСКАЯ_ОШИБКА         ;
            jmp .ВЫХОД                      ;
            ;-------------------------------;
.НЕТ_ТАКОГО:MOV  AX,2                       ;// КРИТИЧЕСКАЯ ОШИБКА №2 НЕ ИЗВЕТНЫЙ ВИДЕОРЕЖИМ
            Call КРИТИЧЕСКАЯ_ОШИБКА         ;
            jmp .ВЫХОД                      ;
            ;-------------------------------;
.ВЫХОД:     popad                           ;
            ret                             ;
            END IF                          ;}
IF (ПЛАТФОРМА = T16);{
            pushad;
            mov  al,[РЕЖИМ_ЭКРАНА]          ;// Читем режжим работы экрана
            ;-------------------------------;
            cmp  al,0                       ;
            jz  .НЕ_ВЫБРАН                  ;// Если видеорежим не выбран
            ;-------------------------------;
            cmp  al,1                       ;// Если режим тектовый 80 на 25
            jnz .НЕТ_ТАКОГО                 ;// НЕизвестный видеорежим нет такого видеорежима
            ;-------------------------------;
            mov  si,di                      ;// перемещение DI в SI
            call ЭКРАН_80_25_ВЫВОД_СТРОКИ_SI;// вывод на экран строки SI в режиме 80 на 25 тектовый;
            jmp .ВЫХОД                      ;
            ;-------------------------------;
.НЕ_ВЫБРАН: MOV  AX,1                       ;// КРИТИЧЕСКАЯ ОШИБКА №1 НЕ ВЫБРАН ВИДОРЕЖИМ
            Call КРИТИЧЕСКАЯ_ОШИБКА         ;
            jmp .ВЫХОД                      ;
            ;-------------------------------;
.НЕТ_ТАКОГО:MOV  AX,2                       ;// КРИТИЧЕСКАЯ ОШИБКА №2 НЕ ИЗВЕТНЫЙ ВИДЕОРЕЖИМ
            Call КРИТИЧЕСКАЯ_ОШИБКА         ;
            jmp .ВЫХОД                      ;
            ;-------------------------------;
.ВЫХОД:     popad                           ;
            ret                             ;
            END IF                          ;}
IF (ПЛАТФОРМА = T32);{
            pushad;
            mov  al,[РЕЖИМ_ЭКРАНА]          ;// Читем режжим работы экрана
            ;-------------------------------;
            cmp  al,0                       ;
            jz  .НЕ_ВЫБРАН                  ;// Если видеорежим не выбран
            ;-------------------------------;
            cmp  al,1                       ;// Если режим тектовый 80 на 25
            jnz .НЕТ_ТАКОГО                 ;// НЕизвестный видеорежим нет такого видеорежима
            ;-------------------------------;
            mov  esi,edi                    ;// перемещение DI в SI
            call ЭКРАН_80_25_ВЫВОД_СТРОКИ_SI;// вывод на экран строки SI в режиме 80 на 25 тектовый;
            jmp .ВЫХОД                      ;
            ;-------------------------------;
.НЕ_ВЫБРАН: MOV  AX,1                       ;// КРИТИЧЕСКАЯ ОШИБКА №1 НЕ ВЫБРАН ВИДОРЕЖИМ
            Call КРИТИЧЕСКАЯ_ОШИБКА         ;
            jmp .ВЫХОД                      ;
            ;-------------------------------;
.НЕТ_ТАКОГО:MOV  AX,2                       ;// КРИТИЧЕСКАЯ ОШИБКА №2 НЕ ИЗВЕТНЫЙ ВИДЕОРЕЖИМ
            Call КРИТИЧЕСКАЯ_ОШИБКА         ;
            jmp .ВЫХОД                      ;
            ;-------------------------------;
.ВЫХОД:     popad                           ;
            ret                             ;
            END IF                          ;}


            ;{ОПИСАНИЕ ПРОЦЕДУРЫ
           ; Вывод Строки DI на экран  в заыисимости от установлденого
           ; видеорежима
           ;
           ;
           ;}

;}
ЭКРАН_ВЫВОД_ЧИСЛА   :;{ Вывод числа в консоль в 10 системе счисления AX
            pushad;
            mov  bx,ax                      ;// Запоминаем выводимое число
            mov  al,[РЕЖИМ_ЭКРАНА]          ;// Читем режжим работы экрана
            ;-------------------------------;
            cmp  al,0                       ;
            jz  .НЕ_ВЫБРАН                  ;// Если видеорежим не выбран
            ;-------------------------------;
            cmp  al,1                       ;// Если режим тектовый 80 на 25
            jnz .НЕТ_ТАКОГО                 ;// НЕизвестный видеорежим нет такого видеорежима
            ;-------------------------------;
            mov  ax,bx                      ;// перемещение bx в ax
            call ЭКРАН_80_25_ВЫВОД_ЧИСЛА_AX ;// вывод на экран числа AX в режиме 80 на 25 тектовый;
            jmp .ВЫХОД                      ;
            ;-------------------------------;
.НЕ_ВЫБРАН: MOV  AX,1                       ;// КРИТИЧЕСКАЯ ОШИБКА №1 НЕ ВЫБРАН ВИДОРЕЖИМ
            Call КРИТИЧЕСКАЯ_ОШИБКА         ;
            jmp .ВЫХОД                      ;
            ;-------------------------------;
.НЕТ_ТАКОГО:MOV  AX,2                       ;// КРИТИЧЕСКАЯ ОШИБКА №2 НЕ ИЗВЕТНЫЙ ВИДЕОРЕЖИМ
            Call КРИТИЧЕСКАЯ_ОШИБКА         ;
            jmp .ВЫХОД                      ;
            ;-------------------------------;
.ВЫХОД:     popad                           ;
            ret                             ;
           ;{ОПИСАНИЕ ПРОЦЕДУРЫ
           ; Вывод Числа AX на экран  в заыисимости от установлденого
           ; видеорежима
           ;
           ;
           ;}

;}
ЭКРАН_АДРЕС_В_AX    :;{ ПОмещает в регистр AX Адрес Видеобуфера

            mov  al,[РЕЖИМ_ЭКРАНА]          ;// Читем режжим работы экрана
            ;-------------------------------;
            cmp  al,0                       ;
            jz  .НЕ_ВЫБРАН                  ;// Если видеорежим не выбран
            ;-------------------------------;
            cmp  al,1                       ;// Если режим тектовый 80 на 25
            jnz .НЕТ_ТАКОГО                 ;// НЕизвестный видеорежим нет такого видеорежима
            ;-------------------------------;
            mov  ax,[ЭКРАН_80_25_АДРЕС]     ;// ПОмещает адрес видеобуфера в регистр AX
            jmp .ВЫХОД                      ;
            ;-------------------------------;
.НЕ_ВЫБРАН: MOV  AX,1                       ;// КРИТИЧЕСКАЯ ОШИБКА №1 НЕ ВЫБРАН ВИДОРЕЖИМ
            Call КРИТИЧЕСКАЯ_ОШИБКА         ;
            jmp .ВЫХОД                      ;
            ;-------------------------------;
.НЕТ_ТАКОГО:MOV  AX,2                       ;// КРИТИЧЕСКАЯ ОШИБКА №2 НЕ ИЗВЕТНЫЙ ВИДЕОРЕЖИМ
            Call КРИТИЧЕСКАЯ_ОШИБКА         ;
            jmp .ВЫХОД                      ;
            ;-------------------------------;
.ВЫХОД:
            ret                             ;
           ;{ОПИСАНИЕ ПРОЦЕДУРЫ
           ; ПОмещает в регистр AX Адрес Видеобуфера  в заыисимости от установлденого
           ; видеорежима
           ;
           ;
           ;}

;}
ЭКРАН_ВЫВОД_AX_CX_DX:;{ Функция Вывод Символ AL с атрибутами AH если AL=0 то выводит тока атрибуты
            pushad;
            mov  bx,ax;
            mov  al,[РЕЖИМ_ЭКРАНА]         ;// Читем режжим работы экрана
            ;------------------------------;
            cmp  al,0                      ;
            jz  .НЕ_ВЫБРАН                 ;// Если видеорежим не выбран
            ;------------------------------;
            cmp  al,1                      ;// Если режим тектовый 80 на 25
            jnz .НЕТ_ТАКОГО                ;// НЕизвестный видеорежим нет такого видеорежима
            ;------------------------------;
            mov  ax,bx;
            call ЭКРАН_80_25_ВЫВОД_AX_CX_DX;// Выводим символ Al С Атрибутами AH на экран X-CX y-DX  в режиме 80 на 25 тектовый;
            jmp .ВЫХОД                     ;
            ;------------------------------;
.НЕ_ВЫБРАН: MOV  AX,1                      ;// КРИТИЧЕСКАЯ ОШИБКА №1 НЕ ВЫБРАН ВИДОРЕЖИМ
            Call КРИТИЧЕСКАЯ_ОШИБКА        ;
            jmp .ВЫХОД                     ;
            ;------------------------------;
.НЕТ_ТАКОГО:MOV  AX,2                      ;// КРИТИЧЕСКАЯ ОШИБКА №2 НЕ ИЗВЕТНЫЙ ВИДЕОРЕЖИМ
            Call КРИТИЧЕСКАЯ_ОШИБКА        ;
            jmp .ВЫХОД                     ;
            ;------------------------------;
.ВЫХОД:     popad                          ;
            ret                            ;
           ;{ОПИСАНИЕ ПРОЦЕДУРЫ
           ; Функция Вывод Символ AL с атрибутами AH если AL=0 то выводит тока атрибуты  в заыисимости от установлденого
           ; видеорежима
           ; координата X это CX
           ; координата Y это DX
           ;}

;}
КРИТИЧЕСКАЯ_ОШИБКА  :;{ Обработка критических ошибок
                  pushad;

                  popad;
                  ret;
;}
БИОС_ИНФОРМАЦИЯ     :;{ Вывод информации о БИОС для отладки
IF  (ПЛАТФОРМА = ДОС)       ;{
     pushad;

     mov  al,[ИНФ_СТРО];
     test al,al;
     jz  .ВЫХОД;
     ;------------------------; Устновка курсора в левый верхний угол экрана
     mov  cx,0                ;
     mov  dx,0                ;
     call ЭКРАН_КУРСОР_XY     ;
     ;------------------------;


     ;------------------------;
     mov   edi,.ТЕКСТ_TR_TIMER;  Вывод количества занятой памяти Всего
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     mov   EAX,[TR_TIMER]     ;
     call  ЧИСЛОAX            ;
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;


     ;------------------------;
     mov   di,.ТЕКСТ_ЗАНПАМВС ;  Вывод количества занятой памяти Всего
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     call  ЗАНЯТАЯ_ПАМЯТЬ     ;
     mov   ax,di              ;
     add   ax,КОНЕЦ_ПРОГРАММЫ ;
     call  ЧИСЛОAX            ;
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;

     ;------------------------;
     mov   di,.ТЕКСТ_ЗАНПАМЯТ ;  Вывод количества занятой памяти
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     call  ЗАНЯТАЯ_ПАМЯТЬ     ;
     mov   ax,di              ;
     call  ЧИСЛОAX            ;
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;

     ;------------------------;
     mov   di,.ТЕКСТ_СВОПАМЯТ ;  Вывод количества Свобьодной памяти
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     call  ЗАНЯТАЯ_ПАМЯТЬ     ;
     mov   ax,[КОН_КУЧИ]      ;
     sub   ax,[НАЧ_КУЧИ]      ;
     sub   ax,di              ;

     call  ЧИСЛОAX            ;
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;

     ;------------------------;
     mov   di,.ТЕКСТ_КОЛПОТ   ; Выводт Количкество потоков
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     call  КОЛИЧЕСТВО_ПОТОКОВ ;
     call  ЧИСЛОAX            ;
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;



     ;------------------------;
     mov   di,.ТЕКСТ_АДРНАЧКУ ; Выводим надпись  (Адрес начала кучи)
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     mov   ax,[НАЧ_КУЧИ]      ;
     call  ЧИСЛОAX            ; Выводи адрес начала кучи на экран
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;

     ;------------------------;
     mov   di,.ТЕКСТ_АДРКОНКУ ; Выводим надпись  (Адрес Окончания кучи)
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     mov   ax,[КОН_КУЧИ]      ;
     call  ЧИСЛОAX            ; Выводим адрес окончания кучи на экран
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;

     ;------------------------;
     mov   di,.ТЕКСТ_АДРЭКРАН ; Выводим надпись (адрес виде буфера)
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     Call  ЭКРАН_АДРЕС_В_AX   ; ПОлучаем адрес Видеобуфера в регист AX
     call  ЧИСЛОAX            ; Выводим вдрес видео буфера на экран
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;

     ;------------------------;
     mov   di,.ТЕКСТ_АДРКОРЭЛ ; Выводим надпись (Адрес корневого Элемента)
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     mov   ax,[КОР_ЭЛЕМ]      ; Читаем дарес корневого Элемента
     call  ЧИСЛОAX            ; Выводим адрес корневого элемента на экран
     call  ЭКРАН_ВЫВОД_ПЕРСТРО; промежуточный пробел
     ;------------------------;

     ;------------------------;
     mov   di,.ТЕКСТ_ИНФМЫШКА ; Выводим надпись (информации о мышке) о нажатых кнопках координатах  и тд и тп
     call  ЭКРАН_ВЫВОД_СТРОКИ ;

     mov   ax,[МЫШ_КООX1]     ; Вывод координаты по X
     call  ЧИСЛОAX            ;

     mov   ax,[МЫШ_КООY1]     ; Вывод координаты по Y
     call  ЧИСЛОAX            ;

     mov   ax,[МЫШ_КНОП1]     ; Вывод информации о нажатых кнопках
     call  ЧИСЛОAX            ;
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;

     ;------------------------;
     mov   di,.ТЕКСТ_АДРАКТОК ; Выводим надпись (Адрес корневого Элемента)
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     mov   ax,[МЫШ_ВЫДЕ1]     ; Вывод информации об обьекте по котрому нажата мышка
     call  ЧИСЛОAX            ;
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;


     ;mov   ax,[МЫШ_КООX2]     ; Вывод предыдущей координаты по X
     ;call  ЭКРАН_ВЫВОД_ЧИСЛА  ;
     ;call  ЭКРАН_ВЫВОД_ПРОБЕЛА;

     ;mov   ax,[МЫШ_КООY2]     ; Вывод Предыдущей координаты по Y
     ;call  ЭКРАН_ВЫВОД_ЧИСЛА  ;
     ;call  ЭКРАН_ВЫВОД_ПРОБЕЛА;

     ;mov   ax,[МЫШ_КНОП2]     ; Вывод предыдущей нажатой кнопки
     ;call  ЭКРАН_ВЫВОД_ЧИСЛА  ;
     ;call  ЭКРАН_ВЫВОД_ПРОБЕЛА;

     ;mov   ax,[МЫШ_ВЫДЕ2]     ; Вывод предыдущего обекта по котрому нажаты была кнопка
     ;call  ЭКРАН_ВЫВОД_ЧИСЛА  ;
     ;call  ЭКРАН_ВЫВОД_ПРОБЕЛА;
     ;------------------------;

     ;call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;
     ;mov   di,.ТЕКСТ_ТИППЕРЕМ ; Вывод типа перемещения обьекта мышкой
     ;call  ЭКРАН_ВЫВОД_СТРОКИ ; Завиист от того места по котрому была нажата мышка
     ;mov   ax,[МЫШ_ТИППЕ]     ;
     ;call  ЭКРАН_ВЫВОД_ЧИСЛА  ;
     ;call  ЭКРАН_ВЫВОД_ПРОБЕЛА;
     ;------------------------;


     ;------------------------;
     mov   di,.ТЕКСТ_АДРСТЕКА ; Выводт код нажатой кнопки
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     mov   ax,sp              ;  КНОПКА_1   НАЖ_КНОПК
     call  ЧИСЛОAX            ;
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;

.ВЫХОД:
     popad;
     ret;
     END IF                   ;}
IF  (ПЛАТФОРМА = T16)       ;{
     pushad;

     mov  ax,[ИНФ_СТРО];
     test ax,ax;
     jz  .ВЫХОД;
     ;------------------------; Устновка курсора в левый верхний угол экрана
     mov  cx,0                ;
     mov  dx,0                ;
     call ЭКРАН_КУРСОР_XY     ;
     ;------------------------;

     ;------------------------;
     mov   edi,.ТЕКСТ_TR_TIMER;  Вывод количества занятой памяти Всего
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     mov   EAX,[TR_TIMER]     ;
     call  ЧИСЛОAX            ;
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;



     ;------------------------;
     mov   di,.ТЕКСТ_ЗАНПАМВС ;  Вывод количества занятой памяти Всего
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     call  ЗАНЯТАЯ_ПАМЯТЬ     ;
     mov   ax,di              ;
     add   ax,КОНЕЦ_ПРОГРАММЫ ;
     call  ЧИСЛОAX            ;
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;

     ;------------------------;
     mov   di,.ТЕКСТ_ЗАНПАМЯТ ;  Вывод количества занятой памяти
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     call  ЗАНЯТАЯ_ПАМЯТЬ     ;
     mov   ax,di              ;
     call  ЧИСЛОAX            ;
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;

     ;------------------------;
     mov   di,.ТЕКСТ_СВОПАМЯТ ;  Вывод количества Свобьодной памяти
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     call  ЗАНЯТАЯ_ПАМЯТЬ     ;
     mov   ax,[КОН_КУЧИ]      ;
     sub   ax,[НАЧ_КУЧИ]      ;
     sub   ax,di              ;

     call  ЧИСЛОAX            ;
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;

     ;------------------------;
     mov   di,.ТЕКСТ_КОЛПОТ   ; Выводт Количкество потоков
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     call  КОЛИЧЕСТВО_ПОТОКОВ ;
     call  ЧИСЛОAX            ;
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;



     ;------------------------;
     mov   di,.ТЕКСТ_АДРНАЧКУ ; Выводим надпись  (Адрес начала кучи)
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     mov   ax,[НАЧ_КУЧИ]      ;
     call  ЧИСЛОAX            ; Выводи адрес начала кучи на экран
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;

     ;------------------------;
     mov   di,.ТЕКСТ_АДРКОНКУ ; Выводим надпись  (Адрес Окончания кучи)
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     mov   ax,[КОН_КУЧИ]      ;
     call  ЧИСЛОAX            ; Выводим адрес окончания кучи на экран
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;

     ;------------------------;
     mov   di,.ТЕКСТ_АДРЭКРАН ; Выводим надпись (адрес виде буфера)
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     Call  ЭКРАН_АДРЕС_В_AX   ; ПОлучаем адрес Видеобуфера в регист AX
     call  ЧИСЛОAX            ; Выводим вдрес видео буфера на экран
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;

     ;------------------------;
     mov   di,.ТЕКСТ_АДРКОРЭЛ ; Выводим надпись (Адрес корневого Элемента)
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     mov   ax,[КОР_ЭЛЕМ]      ; Читаем дарес корневого Элемента
     call  ЧИСЛОAX            ; Выводим адрес корневого элемента на экран
     call  ЭКРАН_ВЫВОД_ПЕРСТРО; промежуточный пробел
     ;------------------------;

     ;------------------------;
     mov   di,.ТЕКСТ_ИНФМЫШКА ; Выводим надпись (информации о мышке) о нажатых кнопках координатах  и тд и тп
     call  ЭКРАН_ВЫВОД_СТРОКИ ;

     mov   ax,[МЫШ_КООX1]     ; Вывод координаты по X
     call  ЧИСЛОAX            ;

     mov   ax,[МЫШ_КООY1]     ; Вывод координаты по Y
     call  ЧИСЛОAX            ;

     mov   ax,[МЫШ_КНОП1]     ; Вывод информации о нажатых кнопках
     call  ЧИСЛОAX            ;
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;

     ;------------------------;
     mov   di,.ТЕКСТ_АДРАКТОК ; Выводим надпись (Адрес корневого Элемента)
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     mov   ax,[МЫШ_ВЫДЕ1]     ; Вывод информации об обьекте по котрому нажата мышка
     call  ЧИСЛОAX            ;
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;


     ;mov   ax,[МЫШ_КООX2]     ; Вывод предыдущей координаты по X
     ;call  ЭКРАН_ВЫВОД_ЧИСЛА  ;
     ;call  ЭКРАН_ВЫВОД_ПРОБЕЛА;

     ;mov   ax,[МЫШ_КООY2]     ; Вывод Предыдущей координаты по Y
     ;call  ЭКРАН_ВЫВОД_ЧИСЛА  ;
     ;call  ЭКРАН_ВЫВОД_ПРОБЕЛА;

     ;mov   ax,[МЫШ_КНОП2]     ; Вывод предыдущей нажатой кнопки
     ;call  ЭКРАН_ВЫВОД_ЧИСЛА  ;
     ;call  ЭКРАН_ВЫВОД_ПРОБЕЛА;

     ;mov   ax,[МЫШ_ВЫДЕ2]     ; Вывод предыдущего обекта по котрому нажаты была кнопка
     ;call  ЭКРАН_ВЫВОД_ЧИСЛА  ;
     ;call  ЭКРАН_ВЫВОД_ПРОБЕЛА;
     ;------------------------;

     ;call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;
     ;mov   di,.ТЕКСТ_ТИППЕРЕМ ; Вывод типа перемещения обьекта мышкой
     ;call  ЭКРАН_ВЫВОД_СТРОКИ ; Завиист от того места по котрому была нажата мышка
     ;mov   ax,[МЫШ_ТИППЕ]     ;
     ;call  ЭКРАН_ВЫВОД_ЧИСЛА  ;
     ;call  ЭКРАН_ВЫВОД_ПРОБЕЛА;
     ;------------------------;


     ;------------------------;
     mov   di,.ТЕКСТ_АДРСТЕКА ; Выводт код нажатой кнопки
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     mov   ax,sp              ;  КНОПКА_1   НАЖ_КНОПК
     call  ЧИСЛОAX            ;
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;

.ВЫХОД:
     popad;
     ret;
     END IF                   ;}
IF  (ПЛАТФОРМА = T32)       ;{
     pushad;

     mov  al,[ИНФ_СТРО];
     test al,al;
     jz  .ВЫХОД;
     ;------------------------; Устновка курсора в левый верхний угол экрана
     mov  ecx,0               ;
     mov  edx,0               ;
     call ЭКРАН_КУРСОР_XY     ;
     ;------------------------;


     ;------------------------;
     mov   edi,.ТЕКСТ_TR_TIMER;  Вывод количества занятой памяти Всего
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     mov   EAX,[TR_TIMER]     ;
     call  ЧИСЛОAX            ;
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;


     ;------------------------;
     mov   edi,.ТЕКСТ_ЗАНПАМВС;  Вывод количества занятой памяти Всего
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     call  ЗАНЯТАЯ_ПАМЯТЬ     ;
     mov   eax,edi            ;
     add   ax,КОНЕЦ_ПРОГРАММЫ ;
     call  ЧИСЛОAX            ;
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;

     ;------------------------;
     mov   edi,.ТЕКСТ_ЗАНПАМЯТ;  Вывод количества занятой памяти
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     call  ЗАНЯТАЯ_ПАМЯТЬ     ;
     mov   eax,edi            ;
     call  ЧИСЛОAX            ;
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;

     ;------------------------;
     mov   edi,.ТЕКСТ_СВОПАМЯТ;  Вывод количества Свобьодной памяти
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     call  ЗАНЯТАЯ_ПАМЯТЬ     ;
     mov   eax,[КОН_КУЧИ]     ;
     sub   eax,[НАЧ_КУЧИ]     ;
     sub   eax,edi            ;

     call  ЧИСЛОAX            ;
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;

     ;------------------------;
     mov   edi,.ТЕКСТ_КОЛПОТ  ; Выводт Количкество потоков
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     call  КОЛИЧЕСТВО_ПОТОКОВ ;
     call  ЧИСЛОAX            ;
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;



     ;------------------------;
     mov   edi,.ТЕКСТ_АДРНАЧКУ; Выводим надпись  (Адрес начала кучи)
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     mov   eax,[НАЧ_КУЧИ]     ;
     call  ЧИСЛОAX            ; Выводи адрес начала кучи на экран
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;

     ;------------------------;
     mov   edi,.ТЕКСТ_АДРКОНКУ; Выводим надпись  (Адрес Окончания кучи)
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     mov   eax,[КОН_КУЧИ]     ;
     call  ЧИСЛОAX            ; Выводим адрес окончания кучи на экран
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;

     ;------------------------;
     mov   edi,.ТЕКСТ_АДРЭКРАН; Выводим надпись (адрес виде буфера)
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     Call  ЭКРАН_АДРЕС_В_AX   ; ПОлучаем адрес Видеобуфера в регист AX
     call  ЧИСЛОAX            ; Выводим вдрес видео буфера на экран
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;

     ;------------------------;
     mov   edi,.ТЕКСТ_АДРКОРЭЛ; Выводим надпись (Адрес корневого Элемента)
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     mov   eax,[КОР_ЭЛЕМ]     ; Читаем дарес корневого Элемента
     call  ЧИСЛОAX            ; Выводим адрес корневого элемента на экран
     call  ЭКРАН_ВЫВОД_ПЕРСТРО; промежуточный пробел
     ;------------------------;

     ;------------------------;
     mov   edi,.ТЕКСТ_ИНФМЫШКА; Выводим надпись (информации о мышке) о нажатых кнопках координатах  и тд и тп
     call  ЭКРАН_ВЫВОД_СТРОКИ ;

     mov   eax,[МЫШ_КООX1]    ; Вывод координаты по X
     call  ЧИСЛОAX            ;

     mov   eax,[МЫШ_КООY1]    ; Вывод координаты по Y
     call  ЧИСЛОAX            ;

     mov   eax,[МЫШ_КНОП1]    ; Вывод информации о нажатых кнопках
     call  ЧИСЛОAX            ;
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;

     ;------------------------;
     mov   edi,.ТЕКСТ_АДРАКТОК; Выводим надпись (Адрес корневого Элемента)
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     mov   eax,[МЫШ_ВЫДЕ1]    ; Вывод информации об обьекте по котрому нажата мышка
     call  ЧИСЛОAX            ;
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;


     ;mov   ax,[МЫШ_КООX2]     ; Вывод предыдущей координаты по X
     ;call  ЭКРАН_ВЫВОД_ЧИСЛА  ;
     ;call  ЭКРАН_ВЫВОД_ПРОБЕЛА;

     ;mov   ax,[МЫШ_КООY2]     ; Вывод Предыдущей координаты по Y
     ;call  ЭКРАН_ВЫВОД_ЧИСЛА  ;
     ;call  ЭКРАН_ВЫВОД_ПРОБЕЛА;

     ;mov   ax,[МЫШ_КНОП2]     ; Вывод предыдущей нажатой кнопки
     ;call  ЭКРАН_ВЫВОД_ЧИСЛА  ;
     ;call  ЭКРАН_ВЫВОД_ПРОБЕЛА;

     ;mov   ax,[МЫШ_ВЫДЕ2]     ; Вывод предыдущего обекта по котрому нажаты была кнопка
     ;call  ЭКРАН_ВЫВОД_ЧИСЛА  ;
     ;call  ЭКРАН_ВЫВОД_ПРОБЕЛА;
     ;------------------------;

     ;call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;
     ;mov   di,.ТЕКСТ_ТИППЕРЕМ ; Вывод типа перемещения обьекта мышкой
     ;call  ЭКРАН_ВЫВОД_СТРОКИ ; Завиист от того места по котрому была нажата мышка
     ;mov   ax,[МЫШ_ТИППЕ]     ;
     ;call  ЭКРАН_ВЫВОД_ЧИСЛА  ;
     ;call  ЭКРАН_ВЫВОД_ПРОБЕЛА;
     ;------------------------;


     ;------------------------;
     mov   edi,.ТЕКСТ_АДРСТЕКА; Выводт адрес стека
     call  ЭКРАН_ВЫВОД_СТРОКИ ;
     mov   eax,esp            ;  КНОПКА_1   НАЖ_КНОПК
     call  ЧИСЛОAX            ;
     call  ЭКРАН_ВЫВОД_ПЕРСТРО;
     ;------------------------;

.ВЫХОД:
     popad;
     ret;
     END IF                   ;}

.ТЕКСТ_TR_TIMER: DB 'TIM TIM =',0;
.ТЕКСТ_АДРСТЕКА: DB 'АДР ESP =',0;
.ТЕКСТ_ЗАНПАМВС: DB 'Все ЗПА =',0;
.ТЕКСТ_ЗАНПАМЯТ: DB 'Зан пам =',0;
.ТЕКСТ_СВОПАМЯТ: DB 'Сво пам =',0;
.ТЕКСТ_АДРАКТОК: DB 'Адр окн =',0;
.ТЕКСТ_АДРКОРЭЛ: DB 'Адр кор =',0;
.ТЕКСТ_АДРНАЧКУ: DB 'Нач куч =',0;
.ТЕКСТ_АДРКОНКУ: DB 'Кон куч =',0;
.ТЕКСТ_АДРЭКРАН: DB 'Адр экр =',0;
.ТЕКСТ_ИНФМЫШКА: DB 'Инф мыш =',0;
.ТЕКСТ_ТИППЕРЕМ: DB 'Тип пер =',0;
.ТЕКСТ_КОДКНОПК: DB 'Код кно =',0;
.ТЕКСТ_КОЛПОТ  : DB 'Кол пот =',0;

;==============================================================================}

РЕЖИМ_ЭКРАНА: DD 1 ; // Режим работы Экрана 1 - 80x25 Текстовый


;{ Автономные Функции для работы с экраном в текстовом режиме 80 на 25  в 16 битном режиме

ЭКРАН_80_25_ПОДГОТОВИТЬ     :;{ ПОдготовка экрана к работе
     pushad                       ;

     IF (ПЛАТФОРМА = ДОС) ;{
     ;----------------------------;
     mov  ax,00h                  ; //Функуия устновки видео режима
     mov  al,03h                  ; //текстовый режим 80 X 25
     int  10h                     ; //Прервывание биос
     ;----------------------------;
     mov  ah,05H                  ; //Устновка видео страницы
     mov  al,0                    ; //нулевая
     int  10h                     ;
     ;----------------------------;
     mov  ah,2                    ; // Функция Скрыть Курсор
     mov  bh,0                    ; // номер видо страницы
     mov  dh,25                   ; // координаты курсора по Y Установка в 25 строку скрывает курсор
     mov  dl,0                    ; // координаты курсора по X
     int  10h                     ;
     ;----------------------------;
     ;Call ЭКРАН_80_25_РУСКИЕ_БУКВЫ; // Загрузка русских шрифтов
     ;----------------------------; // Выделение памяти под видеобуфера
     mov  DI,4000                 ; // Указываем размер запрашиваемого участка памяти для буфера экрана
     call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;// Выделяем участок
     mov  [ЭКРАН_80_25_АДРЕС],DI  ;// Сохраняем адрес выделеного участка для буфера экрана
     ;mov  word [ЭКРАН_80_25_ФОН],00111111b;
     END IF ;}
     IF (ПЛАТФОРМА = T16) ;{
     ;----------------------------;
     mov  ax,00h                  ; //Функуия устновки видео режима
     mov  al,03h                  ; //текстовый режим 80 X 25
     int  10h                     ; //Прервывание биос
     ;----------------------------;
     mov  ah,05H                  ; //Устновка видео страницы
     mov  al,0                    ; //нулевая
     int  10h                     ;
     ;----------------------------;
     mov  ah,2                    ; // Функция Скрыть Курсор
     mov  bh,0                    ; // номер видо страницы
     mov  dh,25                   ; // координаты курсора по Y Установка в 25 строку скрывает курсор
     mov  dl,0                    ; // координаты курсора по X
     int  10h                     ;
     ;----------------------------;
     Call ЭКРАН_80_25_РУСКИЕ_БУКВЫ; // Загрузка русских шрифтов
     ;----------------------------; // Выделение памяти под видеобуфера
     mov  DI,4000                 ; // Указываем размер запрашиваемого участка памяти для буфера экрана
     call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;// Выделяем участок
     mov  [ЭКРАН_80_25_АДРЕС],DI  ;// Сохраняем адрес выделеного участка для буфера экрана
     ;mov  word [ЭКРАН_80_25_ФОН],01111111b;
     END IF ;}
     IF (ПЛАТФОРМА = T32) ;{
     mov  EDI,4000                 ; // Указываем размер запрашиваемого участка памяти для буфера экрана
     call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;// Выделяем участок
     mov  [ЭКРАН_80_25_АДРЕС],EDI  ;// Сохраняем адрес выделеного участка для буфера экрана
     END IF ;}


     popad                        ;
     ret                          ;
;==============================================================================}
ЭКРАН_80_25_КУРСОР_CX_DX    :;{ Устанавливает курсор в заданую позицию
                pushad;

                cmp  cx,79;
                jb  .ДАЛЕЕ1;
                mov  cx,0;
.ДАЛЕЕ1:
                cmp  dx,24;
                jb  .ДАЛЕЕ2;
                mov  dx,0;
.ДАЛЕЕ2:
                mov  [ЭКРАН_80_25_КУРСОР_X],cx;
                mov  [ЭКРАН_80_25_КУРСОР_Y],Dx;

                popad;
                ret;
;==============================================================================}
ЭКРАН_80_25_ОЧИСТКА         :;{ Очистка экрана
          pushad
          ;------------------------;
          mov  cx,2000            ; // Для счета заполняемых символов
          mov  al,' '              ; // Записываем символ
          mov  ah,[ЭКРАН_80_25_ФОН]; // Атрибуты экрана
          ;------------------------;
          mov  DI,[ЭКРАН_80_25_АДРЕС];
          ;------------------------;
.ЦИКЛ:    test cx,cx               ; // Проверяем на 0 пока CX<>0
          jz  .КЦИКЛ               ; // Если CX=0 ВЫход
          MOV [DI],al              ; // Записываем код выводимого символа
          inc  DI                  ; // Увеличиваем адрес
          MOV [DI],ah              ; // Записываем атрибуты
          inc  DI                  ; // Увеличиваем адрес
          dec  cx                  ; // Уменьшаем счетчик
          jmp .ЦИКЛ                ; // Повторить
.КЦИКЛ:   ;------------------------;
          popad                    ;
          ret                      ;
;==============================================================================}
ЭКРАН_80_25_ВЫВОД_AX_CX_DX  :;{ Функция Вывод Символ AL с атрибутами AH если AL=0 то выводит тока атрибуты
        pushad;
        mov  bx,ax          ; // Сохраняю выводимый символ и атрибуты в регистр BX
        ;-------------------;
        mov  DI,[ЭКРАН_80_25_АДРЕС]    ; Настраиваем регистр DI на началово Адреса видео буфера
        ;-------------------;
        mov  ch,0;
        cmp  cx,79;
        ja .ВЫХОД;
        mov  dh,0;
        cmp  dx,24;
        ja .ВЫХОД;

        ;-------------------;
        mov  ax,2           ;  (КОД,АТРИБУТ) 2 байта на 1 символ
        mul  cl             ;  Умнажем координату по X на 2
        mov  cx,ax          ;  Запоминаем
        mov  ax,160         ;  Помещаем в регистр AX длину 1 строки на экране
        mul  dl             ;
        ADD  AX,CX          ;
        ADD  DI,ax          ;
        test bl,bl          ;
        jz  .ДАЛЕЕ          ;
        MOV  byte[DI],bl    ;       (Символ)
.ДАЛЕЕ: inc  DI             ;
        MOV  byte[DI],bh    ;       (Цвет Атрибут)
        ;-------------------;
.ВЫХОД:                     ;
        popad               ;
        ret                 ;
;==============================================================================}
ЭКРАН_80_25_СЛЕД_ПОЗИЦИЯ    :;{ Перевод курсора в следующию позицию
                pushad;
                mov  cx,[ЭКРАН_80_25_КУРСОР_X];
                mov  Dx,[ЭКРАН_80_25_КУРСОР_Y];

                cmp  cx,79      ;
                jae .СЛЕД_СТРОКА;
                inc  cx         ;
                jmp .ВЫХОД;
.СЛЕД_СТРОКА:   mov  cx,0;
                inc  dx;
                cmp  dx,24;
                jb  .ВЫХОД;
                mov  cx,0;
                mov  dx,0;
.ВЫХОД:
                mov  [ЭКРАН_80_25_КУРСОР_X],cx;
                mov  [ЭКРАН_80_25_КУРСОР_Y],Dx;
                popad;
                ret;
;==============================================================================}

ЭКРАН_80_25_СЛЕД_СТРОКА     :;{ Перевод курсора НА следующию строку
                pushad;
                mov  cx,[ЭКРАН_80_25_КУРСОР_X];
                mov  Dx,[ЭКРАН_80_25_КУРСОР_Y];

.СЛЕД_СТРОКА:   mov  cx,0;
                inc  dx;
                cmp  dx,24;
                jb  .ВЫХОД;

                call ЭКРАН_80_25_ОЧИСТКА;
                mov  cx,0;
                mov  dx,0;
.ВЫХОД:
                mov  [ЭКРАН_80_25_КУРСОР_X],cx;
                mov  [ЭКРАН_80_25_КУРСОР_Y],Dx;
                popad;
                ret;
;==============================================================================}
ЭКРАН_80_25_ВЫВОД_БУКВЫ_AL  :;{ Выводит символ в консоль
                pushad;
                cmp  al,13;
                jnz .ДАЛЕЕ;
                call ЭКРАН_80_25_СЛЕД_СТРОКА;
                jmp .ВЫХОД;
.ДАЛЕЕ:
                cmp  al,' ';
                jb .ВЫХОД;
                mov  cx,[ЭКРАН_80_25_КУРСОР_X];
                mov  dx,[ЭКРАН_80_25_КУРСОР_Y];
                call ЭКРАН_80_25_ВЫВОД_AX_CX_DX;
                call ЭКРАН_80_25_СЛЕД_ПОЗИЦИЯ;
.ВЫХОД:
                popad;
                ret;
;==============================================================================}
ЭКРАН_80_25_ВЫВОД_СТРОКИ_SI :;{ Выводит строку в консоль
IF (ПЛАТФОРМА = ДОС);{
                pushad;
                mov  ah,[ЭКРАН_80_25_ФОН];
.ЦИКЛ:          mov  al,[si];
                test al,al;
                jz  .КЦИКЛ;
                call ЭКРАН_80_25_ВЫВОД_БУКВЫ_AL;
                inc  si;
                jmp .ЦИКЛ;
.КЦИКЛ:
                popad;
                ret;
                END IF;}
IF (ПЛАТФОРМА = T16);{
                pushad;
                mov  ah,[ЭКРАН_80_25_ФОН];
.ЦИКЛ:          mov  al,[si];
                test al,al;
                jz  .КЦИКЛ;
                call ЭКРАН_80_25_ВЫВОД_БУКВЫ_AL;
                inc  si;
                jmp .ЦИКЛ;
.КЦИКЛ:
                popad;
                ret;
                END IF;}
IF (ПЛАТФОРМА = T32);{
                pushad;
                mov  ah,[ЭКРАН_80_25_ФОН];
.ЦИКЛ:          mov  al,[esi];
                test al,al;
                jz  .КЦИКЛ;
                call ЭКРАН_80_25_ВЫВОД_БУКВЫ_AL;
                inc  esi;
                jmp .ЦИКЛ;
.КЦИКЛ:
                popad;
                ret;
                END IF;}
;==============================================================================}
ЭКРАН_80_25_ВЫВОД_ЧИСЛА_AX  :;{ Выводит строку в консоль
IF  (ПЛАТФОРМА = ДОС)   ;{
                pushad;
                MOV BX,10   ;// 10 система счисления
                xor cx,cx   ;

       .ЦИКЛ1:  ;------------
                xor  DX,DX  ;
                DIV  BX     ;
                push dx     ;// Сохраняем остаток от деления в стек
                inc  cx     ;
                test ax,ax  ;
                jnz .ЦИКЛ1  ;
                ;------------


       .ЦИКЛ2:  ;---------;
                pop  dx     ;
                add  dl,'0' ;
                mov  al,dl;
                mov  ah,[ЭКРАН_80_25_ФОН];
                call ЭКРАН_80_25_ВЫВОД_БУКВЫ_AL;
                dec  cx     ;
                test cx,cx  ;
                jnz .ЦИКЛ2  ;
                ;---------;
                popad;
                ret;
.БУФФЕР: DB '            ',0;
                END IF      ;}
IF  (ПЛАТФОРМА = T16)   ;{
                pushad;
                MOV BX,10   ;// 10 система счисления
                xor cx,cx   ;

       .ЦИКЛ1:  ;------------
                xor  DX,DX  ;
                DIV  BX     ;
                push dx     ;// Сохраняем остаток от деления в стек
                inc  cx     ;
                test ax,ax  ;
                jnz .ЦИКЛ1  ;
                ;------------


       .ЦИКЛ2:  ;---------;
                pop  dx     ;
                add  dl,'0' ;
                mov  al,dl;
                mov  ah,[ЭКРАН_80_25_ФОН];
                call ЭКРАН_80_25_ВЫВОД_БУКВЫ_AL;
                dec  cx     ;
                test cx,cx  ;
                jnz .ЦИКЛ2  ;
                ;---------;
                popad;
                ret;
.БУФФЕР: DB '            ',0;
                END IF      ;}
IF  (ПЛАТФОРМА = T32)   ;{
                pushad;
                MOV eBX,10   ;// 10 система счисления
                xor ecx,ecx   ;

       .ЦИКЛ1:  ;------------
                xor  eDX,eDX  ;
                DIV  eBX     ;
                push edx     ;// Сохраняем остаток от деления в стек
                inc  ecx     ;
                test eax,eax  ;
                jnz .ЦИКЛ1  ;
                ;------------


       .ЦИКЛ2:  ;----------;
                pop  edx    ;
                add  dl,'0';
                mov  al,dl;
                mov  ah,[ЭКРАН_80_25_ФОН];
                call ЭКРАН_80_25_ВЫВОД_БУКВЫ_AL;
                dec  ecx    ;
                test ecx,ecx ;
                jnz .ЦИКЛ2 ;
                ;---------;
                popad;
                ret;
.БУФФЕР: DB '            ',0;
                END IF      ;}
;==============================================================================}
ЭКРАН_80_25_ЭКРАН_ВЫВОД     :;{ Функция для вывода содержимого фидео буфер ана экран
            pushad           ;
            IF  (ПЛАТФОРМА = ДОС);{ Для 16 бит
            mov  AX,0B800h   ; Настраиваем регистр ES на началово видеопаямити
            mov  ES,AX       ;
            mov si,0         ;
            mov di,[ЭКРАН_80_25_АДРЕС];
            mov cx,4000      ;

.ЦИКЛ:      test cx,cx       ;
            jz  .КЦИКЛ       ;
            mov  al,[di]     ;
            test al,al       ;
            jz  .ПРОПУСТИТЬ  ;
            MOV [ES:SI],al   ;
.ПРОПУСТИТЬ:
            dec  cx          ;
            inc  si          ;
            inc  di          ;
            jmp .ЦИКЛ        ;
.КЦИКЛ:


            END IF;}
            IF  (ПЛАТФОРМА = T16);{ Для 16 бит
            mov  AX,0B800h   ; Настраиваем регистр ES на началово видеопаямити
            mov  ES,AX       ;
            mov  si,0         ;
            mov  di,[ЭКРАН_80_25_АДРЕС];
            mov  cx,4000      ;

.ЦИКЛ:      test cx,cx       ;
            jz  .КЦИКЛ       ;
            mov  al,[di]     ;
            test al,al       ;
            jz  .ПРОПУСТИТЬ  ;
            MOV [ES:SI],al   ;
.ПРОПУСТИТЬ:
            dec  cx          ;
            inc  si          ;
            inc  di          ;
            jmp .ЦИКЛ        ;
.КЦИКЛ:
            END IF;}
            IF  (ПЛАТФОРМА = T32);{ Для 32 бит
            mov  esi,0B8000h  ;
            mov  di,[ЭКРАН_80_25_АДРЕС];
            mov  cx,4000     ;

.ЦИКЛ:      test cx,cx       ;
            jz  .КЦИКЛ       ;
            mov  al,[di]     ;
            test al,al       ;
            jz  .ПРОПУСТИТЬ  ;
            MOV [ES:eSI],al  ;
.ПРОПУСТИТЬ:
            dec  cx          ;
            inc  esi         ;
            inc  di          ;
            jmp .ЦИКЛ        ;
.КЦИКЛ:


            END IF;}
            popad            ;
            ret              ;
;==============================================================================}

ЭКРАН_80_25_АДРЕС     : DD 0,0;
ЭКРАН_80_25_КУРСОР_X  : DD 0,0;
ЭКРАН_80_25_КУРСОР_Y  : DD 0,0;
ЭКРАН_80_25_ФОН       : DD 00110000b;
;Буду перестовлять пока не найду то мекстио где что то идет не так .....................................



;}
;{ Автономные Функции для работы с потоками

ДОБАВИТЬ_ПРОЦЕС:;{ Добавляет новый процесс в списко процессов
PUSHAD         ;
           IF ПЛАТФОРМА = ДОС  ;{
           mov  bx,di     ;
           Mov  DI,1024   ;
           call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI
           mov  dx,DI
           add  DI,1000   ;
           ;--------------;
           mov  [di],dx   ; // Указываем адрес выделеного участка
           sub   di ,2    ;    1020
           mov   cx,СТОП  ;
           mov  [di],cx   ; // Указываем адрес остановки потока
           sub   di ,2    ;    1018
           mov  [di],ax   ; // Указываем адрес с которого нужно запустить поток
           sub   di ,32   ;    1018
           mov  [di],bx   ; // Указываем адрес с которого нужно запустить поток
           ;--------------;
           mov   dx,di    ;
           mov   di,[ПОТОКИ]; // Читаю адрес списка потоков
           ;--------------;

           ;--------------;
.ЦИКЛ:     mov  cx,[di]   ; // запоминаю адрес котрый был первым в списке
           test cx,cx     ; // Если это последний поток в списке
           jz  .КЦИКЛ     ; // Выходим из цикла
           add  di,2      ; // Переходим к следующему потоку
           jmp .ЦИКЛ      ;
           ;--------------;
.КЦИКЛ:
           mov  [di],dx   ; // Записываю поток в очередь
           END IF ;}
           IF ПЛАТФОРМА = T16  ;{
           mov  bx,di     ;
           Mov  DI,2048   ;
           call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI
           mov  dx,DI
           add  DI,2000   ;
           ;--------------;
           mov  [di],dx   ; // Указываем адрес выделеного участка
           sub   di ,2    ;    1020
           mov   cx,СТОП  ;
           mov  [di],cx   ; // Указываем адрес остановки потока
           sub   di ,2    ;    1018
           mov  [di],ax   ; // Указываем адрес с которого нужно запустить поток
           sub   di ,32   ;    1018
           mov  [di],bx   ; // Указываем адрес с которого нужно запустить поток
           ;--------------;
           mov   dx,di    ;
           mov   di,[ПОТОКИ]; // Читаю адрес списка потоков
           ;--------------;

           ;--------------;
.ЦИКЛ:     mov  cx,[di]   ; // запоминаю адрес котрый был первым в списке
           test cx,cx     ; // Если это последний поток в списке
           jz  .КЦИКЛ     ; // Выходим из цикла
           add  di,2      ; // Переходим к следующему потоку
           jmp .ЦИКЛ      ;
           ;--------------;
.КЦИКЛ:
           mov  [di],dx   ; // Записываю поток в очередь
           END IF ;}
           IF ПЛАТФОРМА = T32  ;{
           mov  ebx,edi     ;
           Mov  EDI,2048   ;
           call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI
           mov  edx,eDI
           add  eDI,2000   ;
           ;--------------;
           mov  [edi],edx  ; // Указываем адрес выделеного участка
           sub   edi ,4    ;    1020
           mov   ecx,СТОП  ;
           mov  [edi],ecx  ; // Указываем адрес остановки потока
           sub   edi ,4    ;    1018
           mov  [edi],eax  ; // Указываем адрес с которого нужно запустить поток
           sub   edi ,32   ;    1018
           mov  [edi],bx   ; // Указываем адрес с которого нужно запустить поток
           ;--------------;
           mov   edx,edi    ;
           mov   di,[ПОТОКИ]; // Читаю адрес списка потоков
           ;--------------;

           ;--------------;
.ЦИКЛ:     mov  cx,[edi]  ; // запоминаю адрес котрый был первым в списке
           test cx,cx     ; // Если это последний поток в списке
           jz  .КЦИКЛ     ; // Выходим из цикла
           add  edi,4     ; // Переходим к следующему потоку
           jmp .ЦИКЛ      ;
           ;--------------;
.КЦИКЛ:
           mov  [edi],edx ; // Записываю поток в очередь
           END IF ;}
POPAD;
RET;}
ПРЕРЫВАНИЕ     :;{ Програмное прерывание для организации много задачности
IF ПЛАТФОРМА = ДОС  ;{
           pushad         ;
           ;--------------;
           mov cx,sp      ; // Запоминаем адрес текущего потока
           ;--------------;
           mov si,[ПОТОКИ]; // Читаю адрес списка потоков
           mov di,[ПОТОКИ]; // Читаю адрес списка потоков
           add di,2       ; // В DI переходим к следующему в списке
           MOV dx,[SI]    ; // Читаю адрес первого потока в DX
           ;--------------;
           test dx,dx     ;  // Если это единственный поток то идем на выход
           jz  .ВЫХОД     ;

           ;--------------;
.ЦИКЛ:     mov  AX,[DI]   ; // Читаю адрес следующего потока
           mov  [SI],AX   ; // Записываем на место предыдущего
           test AX,AX     ; // Если больше в списке нет потоков
           jz  .КЦИКЛ     ; // Выходим из цикла
           ADD  SI,2      ; // Переходим к следующему потоку
           ADD  DI,2      ; // Переходим к следующему потоку
           jmp .ЦИКЛ      ;
           ;--------------;
.КЦИКЛ:    mov  [SI],CX   ; // Записываем текущий поток как последний в списке
           mov  sp,dx     ;

.ВЫХОД:
           popad          ;
           ret            ;
           END IF;}
IF ПЛАТФОРМА = T16  ;{
           pushad         ;
           ;--------------;
           mov cx,sp      ; // Запоминаем адрес текущего потока
           ;--------------;
           mov si,[ПОТОКИ]; // Читаю адрес списка потоков
           mov di,[ПОТОКИ]; // Читаю адрес списка потоков
           add di,2       ; // В DI переходим к следующему в списке
           MOV dx,[SI]    ; // Читаю адрес первого потока в DX
           ;--------------;
           test dx,dx     ;  // Если это единственный поток то идем на выход
           jz  .ВЫХОД     ;

           ;--------------;
.ЦИКЛ:     mov  AX,[DI]   ; // Читаю адрес следующего потока
           mov  [SI],AX   ; // Записываем на место предыдущего
           test AX,AX     ; // Если больше в списке нет потоков
           jz  .КЦИКЛ     ; // Выходим из цикла
           ADD  SI,2      ; // Переходим к следующему потоку
           ADD  DI,2      ; // Переходим к следующему потоку
           jmp .ЦИКЛ      ;
           ;--------------;
.КЦИКЛ:    mov  [SI],CX   ; // Записываем текущий поток как последний в списке
           mov  sp,dx     ;

.ВЫХОД:
           popad          ;
           ret            ;
           END IF;}
IF ПЛАТФОРМА = T32  ;{
           pushad         ;
           ;--------------;
           mov ecx,esp      ; // Запоминаем адрес текущего потока
           ;--------------;
           mov esi,[ПОТОКИ]; // Читаю адрес списка потоков
           mov edi,[ПОТОКИ]; // Читаю адрес списка потоков
           add edi,4       ; // В DI переходим к следующему в списке
           MOV edx,[eSI]    ; // Читаю адрес первого потока в DX
           ;--------------;
           test edx,edx     ;  // Если это единственный поток то идем на выход
           jz  .ВЫХОД     ;

           ;--------------;
.ЦИКЛ:     mov  eAX,[eDI]   ; // Читаю адрес следующего потока
           mov  [eSI],eAX   ; // Записываем на место предыдущего
           test eAX,eAX     ; // Если больше в списке нет потоков
           jz  .КЦИКЛ     ; // Выходим из цикла
           ADD  eSI,4      ; // Переходим к следующему потоку
           ADD  eDI,4      ; // Переходим к следующему потоку
           jmp .ЦИКЛ      ;
           ;--------------;
.КЦИКЛ:    mov  [eSI],eCX   ; // Записываем текущий поток как последний в списке
           mov  esp,edx     ;

.ВЫХОД:
           popad          ;
           ret            ;
           END IF;}
;--------------;}
   СТОП           :;{ Сюда передаеться управление кагда процес завершаеться
         IF ПЛАТФОРМА = ДОС  ;{ Остиальные тоде допсиать 4094
         pop  di        ; // Читаем адрес участка выделеного под стек потока

         mov  ax,[ВР_СТЕ];
         mov  sp,ax;
         call ОСВОБОЖДЕНИЕ_УЧАСТКА_ПАМЯТИ_DI;

         MOV  SI,[ПОТОКИ]; // Читаю адрес списка потоков
         mov  DI,[ПОТОКИ]; // Читаю адрес списка потоков
         add  DI,2       ;
         MOV  dx,[SI]    ; // Читаю адрес первого потока


.ЦИКЛ:   MOV  AX,[DI]   ;
         MOV  [SI],AX   ;
         TEST AX,AX     ;
         jz  .КЦИКЛ     ;
         add  si,2      ;
         add  di,2      ;
         jmp .ЦИКЛ      ;
.КЦИКЛ:
         ;--------------;
         mov  sp,dx     ;
         popad          ;
         ret            ;
         ;--------------;




         END IF;}
         IF ПЛАТФОРМА = T16  ;{
         pop  di        ; // Читаем адрес участка выделеного под стек потока

         mov  ax,[ПОТОКИ];
         add  ax,1022;
         mov  sp,ax;
         call ОСВОБОЖДЕНИЕ_УЧАСТКА_ПАМЯТИ_DI;

         MOV SI,[ПОТОКИ]; // Читаю адрес списка потоков
         mov DI,[ПОТОКИ]; // Читаю адрес списка потоков
         add DI,2       ;
         MOV dx,[SI]    ; // Читаю адрес первого потока


.ЦИКЛ:   MOV  AX,[DI]   ;
         MOV  [SI],AX   ;
         TEST AX,AX     ;
         jz  .КЦИКЛ     ;
         add  si,2      ;
         add  di,2      ;
         jmp .ЦИКЛ      ;
.КЦИКЛ:
         ;--------------;
         mov  sp,dx     ;
         popad          ;
         ret            ;
         ;--------------;

         END IF;}
         IF ПЛАТФОРМА = T32  ;{
         pop  edi        ; // Читаем адрес участка выделеного под стек потока

         mov  eax,[ПОТОКИ];
         add  eax,1022;
         mov  esp,eax;
         call ОСВОБОЖДЕНИЕ_УЧАСТКА_ПАМЯТИ_DI;

         MOV eSI,[ПОТОКИ]; // Читаю адрес списка потоков
         mov eDI,[ПОТОКИ]; // Читаю адрес списка потоков
         add eDI,4       ;
         MOV edx,[eSI]    ; // Читаю адрес первого потока


.ЦИКЛ:   MOV  eAX,[eDI]   ;
         MOV  [eSI],eAX   ;
         TEST eAX,eAX     ;
         jz  .КЦИКЛ     ;
         add  esi,4      ;
         add  edi,4      ;
         jmp .ЦИКЛ      ;
.КЦИКЛ:
         ;--------------;
         mov  esp,edx     ;
         popad          ;
         ret            ;
         ;--------------;


         END IF;}
         ;}
   КОЛИЧЕСТВО_ПОТОКОВ:;{ Возвращает количество потоков
IF ПЛАТФОРМА = ДОС  ;{
   push cx;
   push di;
    mov  ax,0;
    mov  di,[ПОТОКИ];
.ЦИКЛ:
    mov  cx,[di];
    inc  ax;
    inc  di;
    inc  di;
    test cx,cx;
    jnz .ЦИКЛ;
   pop di;
   pop cx;
   ret   ;
END IF;}
IF ПЛАТФОРМА = T16  ;{
   push cx;
   push di;
    mov  ax,0;
    mov  di,[ПОТОКИ];
.ЦИКЛ:
    mov  cx,[di];
    inc  ax;
    inc  di;
    inc  di;
    test cx,cx;
    jnz .ЦИКЛ;
   pop di;
   pop cx;
   ret   ;
END IF;}
IF ПЛАТФОРМА = T32  ;{
   push ecx;
   push edi;
    mov  eax,0;
    mov  edi,[ПОТОКИ];
.ЦИКЛ:
    mov  ecx,[edi];
    inc  eax;
    add  EDi,4;
    test ecx,ecx;
    jnz .ЦИКЛ;
   pop edi;
   pop ecx;
   ret   ;
END IF;}


;}
   СОЗДАТЬ_ТАБЛИЦУ_ПОТОКОВ:;{ Создание ТАБЛИЦУ ПОТОКОВ
   IF ПЛАТФОРМА = ДОС  ;{
   pushad;

   mov  di,128;
   call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;
   mov [ПОТОКИ],di;

   mov  di,128;
   call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;
   Add  Di,100;
   mov [ВР_СТЕ],di;

   popad;
   ret;
   END IF;}
   IF ПЛАТФОРМА = T16  ;{
   pushad;

   mov  di,128;
   call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;
   mov [ПОТОКИ],di;

   mov  di,128;
   call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;
   Add  Di,100;
   mov [ВР_СТЕ],di;

   popad;
   ret;
   END IF;}
   IF ПЛАТФОРМА = T32  ;{
   pushad;

   mov  edi,128;
   call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;
   mov [ПОТОКИ],edi;

   mov  edi,128;
   call ВЫДЕЛИТЬ_УЧАСТОК_ПАМЯТИ_DI_РАЗ_DI;
   Add  eDi,100;
   mov [ВР_СТЕ],edi;

   popad;
   ret;
   END IF;}
   ;=================================================}
   ;Переменные:{
   IF ПЛАТФОРМА = ДОС  ;{
   ПОТОКИ         : DW 0 ;// Адрес таблицы содержащей конвеер потоков
   ВР_СТЕ         : DW 0 ;// Адрес таблицы содержащей конвеер потоков
   END IF;}
   IF ПЛАТФОРМА = T16  ;{
   ПОТОКИ         : DW 0 ;// Адрес таблицы содержащей конвеер потоков
   ВР_СТЕ         : DW 0 ;// Адрес таблицы содержащей конвеер потоков
   END IF;}
   IF ПЛАТФОРМА = T32  ;{
   ПОТОКИ         : DD 0 ;// Адрес таблицы содержащей конвеер потоков
   ВР_СТЕ         : DD 0 ;// Адрес таблицы содержащей конвеер потоков
   END IF;}
   ;}




;}
;{ ПОдфункции для возврата значений регистров из подпрограмм
ВОЗВРАТИТЬ_DI:;{ Возвращает значение регистра DI
IF  (ПЛАТФОРМА = ДОС) ;{
              push  ax        ; // Сохраняем значения регистра AX
              push  si        ; // Сохраняем значения регистра SI

              mov  si,sp      ; // Читаем Вдрес вершины стека
              add  si,SM      ; // Прибавляем смещение AX+SI+ВЫЗОВ
              mov  [si],DI    ; // Записываем Значение

              pop   si        ;
              pop   ax        ;
              ret             ;
              END IF          ;}
IF  (ПЛАТФОРМА = T16) ;{
              push  ax        ; // Сохраняем значения регистра AX
              push  si        ; // Сохраняем значения регистра SI

              mov  si,sp      ; // Читаем Вдрес вершины стека
              add  si,SM      ; // Прибавляем смещение AX+SI+ВЫЗОВ
              mov  [si],DI    ; // Записываем Значение

              pop   si        ;
              pop   ax        ;
              ret             ;
              END IF          ;}
IF  (ПЛАТФОРМА = T32) ;{
              push  eax       ; // Сохраняем значения регистра AX
              push  esi       ; // Сохраняем значения регистра SI

              mov   esi,esp   ; // Читаем Вдрес вершины стека
              add   esi,SM    ; // Прибавляем смещение EAX+ESI+ВЫЗОВ
              mov  [esi],eDI  ; // Записываем Значение

              pop   esi       ;
              pop   eax       ;
              ret             ;
              END IF          ;}

;}
ВОЗВРАТИТЬ_AX:;{ Возаращет значение регистра  AX
IF  (ПЛАТФОРМА = ДОС) ;{

              push  ax        ; // Сохраняем значения регистра AX
              push  si        ; // Сохраняем значения регистра SI

              mov  si,sp      ; // Читаем Вдрес вершины стека
              add  si,SM+28   ; // Прибавляем смещение AX+SI+ВЫЗОВ
              mov  [si],AX    ; // Записываем Значение

              pop   si        ;
              pop   ax        ;
              ret             ;
              END IF          ;}
IF  (ПЛАТФОРМА = T16) ;{

              push  ax        ; // Сохраняем значения регистра AX
              push  si        ; // Сохраняем значения регистра SI

              mov  si,sp      ; // Читаем Вдрес вершины стека
              add  si,SM+28   ; // Прибавляем смещение AX+SI+ВЫЗОВ
              mov  [si],AX    ; // Записываем Значение

              pop   si        ;
              pop   ax        ;
              ret             ;
              END IF          ;}
IF  (ПЛАТФОРМА = T32) ;{

              push  eax        ; // Сохраняем значения регистра AX
              push  esi        ; // Сохраняем значения регистра SI

              mov  esi,esp      ; // Читаем Вдрес вершины стека
              add  esi,SM+28   ; // Прибавляем смещение AX+SI+ВЫЗОВ
              mov  [esi],eAX    ; // Записываем Значение

              pop   esi        ;
              pop   eax        ;
              ret             ;
              END IF          ;}


 ;}
ВОЗВРАТИТЬ_CX:;{ Возаращет значение регистра  CX
IF  (ПЛАТФОРМА = ДОС) ;{

              push  ax        ; // Сохраняем значения регистра AX
              push  si        ; // Сохраняем значения регистра SI

              mov  si,sp      ; // Читаем Вдрес вершины стека
              add  si,SM+24   ; // Прибавляем смещение AX+SI+ВЫЗОВ
              mov  [si],CX    ; // Записываем Значение

              pop   si        ;
              pop   ax        ;
              ret             ;
              END IF          ;}
IF  (ПЛАТФОРМА = T16) ;{

              push  ax        ; // Сохраняем значения регистра AX
              push  si        ; // Сохраняем значения регистра SI

              mov  si,sp      ; // Читаем Вдрес вершины стека
              add  si,SM+24   ; // Прибавляем смещение AX+SI+ВЫЗОВ
              mov  [si],CX    ; // Записываем Значение

              pop   si        ;
              pop   ax        ;
              ret             ;
              END IF          ;}
IF  (ПЛАТФОРМА = T32) ;{

              push  Eax        ; // Сохраняем значения регистра AX
              push  Esi        ; // Сохраняем значения регистра SI

              mov  Esi,Esp      ; // Читаем Вдрес вершины стека
              add  Esi,SM+24   ; // Прибавляем смещение AX+SI+ВЫЗОВ
              mov  [Esi],ECX    ; // Записываем Значение

              pop   Esi        ;
              pop   Eax        ;
              ret             ;
              END IF          ;}

 ;}
ВОЗВРАТИТЬ_DX:;{ Возаращет значение регистра  DX

IF  (ПЛАТФОРМА = ДОС) ;{
              push  ax        ; // Сохраняем значения регистра AX
              push  si        ; // Сохраняем значения регистра SI

              mov  si,sp      ; // Читаем Вдрес вершины стека
              add  si,SM+20   ; // Прибавляем смещение AX+SI+ВЫЗОВ
              mov  [si],DX    ; // Записываем Значение

              pop   si        ;
              pop   ax        ;
              ret             ;
              END IF          ;}
IF  (ПЛАТФОРМА = T16) ;{
              push  ax        ; // Сохраняем значения регистра AX
              push  si        ; // Сохраняем значения регистра SI

              mov  si,sp      ; // Читаем Вдрес вершины стека
              add  si,SM+20   ; // Прибавляем смещение AX+SI+ВЫЗОВ
              mov  [si],DX    ; // Записываем Значение

              pop   si        ;
              pop   ax        ;
              ret             ;
              END IF          ;}
IF  (ПЛАТФОРМА = T32) ;{
              push  eax        ; // Сохраняем значения регистра AX
              push  esi        ; // Сохраняем значения регистра SI

              mov  esi,esp      ; // Читаем Вдрес вершины стека
              add  esi,SM+20   ; // Прибавляем смещение AX+SI+ВЫЗОВ
              mov  [esi],eDX    ; // Записываем Значение

              pop   esi        ;
              pop   eax        ;
              ret             ;
              END IF          ;}


 ;}
ВОЗВРАТИТЬ_BX:;{ Возаращет значение регистра  BX

IF  (ПЛАТФОРМА = ДОС) ;{
              push  ax        ; // Сохраняем значения регистра AX
              push  si        ; // Сохраняем значения регистра SI

              mov  si,sp      ; // Читаем Вдрес вершины стека
              add  si,SM+16   ; // Прибавляем смещение AX+SI+ВЫЗОВ
              mov  [si],BX    ; // Записываем Значение

              pop   si        ;
              pop   ax        ;
              ret             ;
              END IF          ;}
IF  (ПЛАТФОРМА = T16) ;{
              push  ax        ; // Сохраняем значения регистра AX
              push  si        ; // Сохраняем значения регистра SI

              mov  si,sp      ; // Читаем Вдрес вершины стека
              add  si,SM+16   ; // Прибавляем смещение AX+SI+ВЫЗОВ
              mov  [si],BX    ; // Записываем Значение

              pop   si        ;
              pop   ax        ;
              ret             ;
              END IF          ;}
IF  (ПЛАТФОРМА = T32) ;{
              push  Eax        ; // Сохраняем значения регистра AX
              push  esi        ; // Сохраняем значения регистра SI

              mov  esi,esp      ; // Читаем Вдрес вершины стека
              add  esi,SM+16   ; // Прибавляем смещение AX+SI+ВЫЗОВ
              mov  [esi],eBX    ; // Записываем Значение

              pop  esi        ;
              pop  eax        ;
              ret             ;
              END IF          ;}



 ;}
ВОЗВРАТИТЬ_SI:;{ Возаращет значение регистра  SI

IF  (ПЛАТФОРМА = ДОС) ;{
              push  ax        ; // Сохраняем значения регистра AX
              push  di        ; // Сохраняем значения регистра DI

              mov  di,sp      ; // Читаем Вдрес вершины стека
              add  di,SM+4    ; // Прибавляем смещение AX+DI+ВЫЗОВ
              mov  [di],sI    ; // Записываем Значение

              pop   di        ;
              pop   ax        ;
              ret             ;
              END IF          ;}
IF  (ПЛАТФОРМА = T16) ;{
              push  ax        ; // Сохраняем значения регистра AX
              push  di        ; // Сохраняем значения регистра DI

              mov  di,sp      ; // Читаем Вдрес вершины стека
              add  di,SM+4    ; // Прибавляем смещение AX+DI+ВЫЗОВ
              mov  [di],sI    ; // Записываем Значение

              pop   di        ;
              pop   ax        ;
              ret             ;
              END IF          ;}
IF  (ПЛАТФОРМА = T32) ;{
              push  eax        ; // Сохраняем значения регистра AX
              push  edi        ; // Сохраняем значения регистра DI

              mov  edi,esp      ; // Читаем Вдрес вершины стека
              add  edi,SM+4    ; // Прибавляем смещение AX+DI+ВЫЗОВ
              mov  [edi],esI    ; // Записываем Значение

              pop   edi        ;
              pop   eax        ;
              ret             ;
              END IF          ;}

 ;}
;{ пример использования процедур
; Подпрограмма возвращает значемние DI  или например еще AX возврвщает
;PUSHAD;
;..... Тут какая то программа
;mov DI,12 ; // Возвращаемые значения
;mov AX,14 ; // Возвращаемые значения
;ВОЗВРАТИТЬ_DI
;ВОЗВРАТИТЬ_AX
;POPAD;
;RET;
;}
;{ Порядок сохранения регистров в стеке
; АХ/ЕАХ,1   36     ; Вобщем чай попил и придумал как сделать
; СХ/ЕСХ,2   32     ; кажеться ))))) придамл
; DX/EDX,3   28     ; В 16 бит 6
; ВХ/ЕВХ,4   24     ; как старно в 32 битном режиме тоже самое ????????????????????
; SP/ESP,5   20     ; 32 байта в 32 битном режиме
; BP/EBP,6   16
; SI/ESI,7   12
; DI/EDI,8
;}
IF  (ПЛАТФОРМА = ДОС) ;{ // Высчитывать смещение в стеке
SM=6;
END IF;}
IF  (ПЛАТФОРМА = T16) ;{
SM=6;    34
END IF;}
IF  (ПЛАТФОРМА = T32) ;{
SM=12;    36
END IF;}
;}

IF (ПЛАТФОРМА = T16);{
ЭКРАН_80_25_РУСКИЕ_БУКВЫ    :;{ Функция загрузки руских букв через биос
      ;{ ОПИСАНИЕ
      ; ПОдробное описание взято от сюда http://biosprog.narod.ru/real/ints/int10.htm
      ;
      ;}
      pushad;
      ;--------------------------------;
      mov     bp,ЭКРАН_80_25_ШРИФТ_А_п ;
      mov     dx, 128                  ; // Номер символа с которого нужно загружать CP866
      mov     cx, 48                   ; // Количество загружаемых символов
      mov     bx, 1000h                ; // BH - число байт на один символ 16 BL - Номер загружаемого блока (шрифта) знакогенератора (0-3 для CGA и 0-7 для VGA)
      mov     ax, 1100h                ; // AH 11 Функция установки шрифта   AL 0 Установка пользовательского шрифта
      int     10h                      ; // Прерывание BIOS для загрузки шрифта
      ;--------------------------------;

      ;--------------------------------;
      mov     bp,ЭКРАН_80_25_ШРИФТ_р_ё ;
      mov     dx, 224                  ;
      mov     cx, 18                   ;
      mov     bx, 1000h                ;
      mov     ax, 1100h                ;
      int     10h                      ;
      ;--------------------------------;
      popad                            ;
      ret                              ;
ЭКРАН_80_25_ШРИФТ_А_п :;{ Руские буквы от (А) до (п) 8 Бит в ширину 16 байт в высоту кодировка CP866
          ;-------------;А
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00011100b ;2
          DB 00010100b ;3
          DB 00010100b ;4
          DB 00010110b ;5
          DB 00100010b ;6
          DB 00100010b ;7
          DB 00100010b ;8
          DB 01111111b ;9
          DB 01000001b ;10
          DB 01000001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Б
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01111100b ;2
          DB 01000000b ;3
          DB 01000000b ;4
          DB 01000000b ;5
          DB 01111100b ;6
          DB 01000110b ;7
          DB 01000010b ;8
          DB 01000010b ;9
          DB 01000110b ;10
          DB 01111100b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;В
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01111100b ;2
          DB 01000010b ;3
          DB 01000010b ;4
          DB 01000110b ;5
          DB 01111100b ;6
          DB 01000110b ;7
          DB 01000010b ;8
          DB 01000010b ;9
          DB 01000110b ;10
          DB 01111100b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Г
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00111111b ;2
          DB 00100000b ;3
          DB 00100000b ;4
          DB 00100000b ;5
          DB 00100000b ;6
          DB 00100000b ;7
          DB 00100000b ;8
          DB 00100000b ;9
          DB 00100000b ;10
          DB 00100000b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Д
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00111111b ;2
          DB 00100001b ;3
          DB 00100001b ;4
          DB 00100001b ;5
          DB 00100001b ;6
          DB 00100001b ;7
          DB 00100001b ;8
          DB 00100001b ;9
          DB 01000001b ;10
          DB 11111111b ;11
          DB 10000000b ;12
          DB 10000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Е
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00111111b ;2
          DB 00100000b ;3
          DB 00100000b ;4
          DB 00100000b ;5
          DB 00111111b ;6
          DB 00100000b ;7
          DB 00100000b ;8
          DB 00100000b ;9
          DB 00100000b ;10
          DB 00111111b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Ж
          DB 00000000b ;0
          DB 00000000b ;1
          DB 10001000b ;2
          DB 01001001b ;3
          DB 00101010b ;4
          DB 00101010b ;5
          DB 00011100b ;6
          DB 00011100b ;7
          DB 00101010b ;8
          DB 01001001b ;9
          DB 01001001b ;10
          DB 10001000b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;З
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00111100b ;2
          DB 01000010b ;3
          DB 00000010b ;4
          DB 00000010b ;5
          DB 00111100b ;6
          DB 00000110b ;7
          DB 00000010b ;8
          DB 00000010b ;9
          DB 01000110b ;10
          DB 00111100b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;И
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01000001b ;2
          DB 01000011b ;3
          DB 01000111b ;4
          DB 01000101b ;5
          DB 01001101b ;6
          DB 01011001b ;7
          DB 01010001b ;8
          DB 01110001b ;9
          DB 01100001b ;10
          DB 01000001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Й
          DB 00111000b ;0
          DB 00000000b ;1
          DB 01000001b ;2
          DB 01000011b ;3
          DB 01000111b ;4
          DB 01000101b ;5
          DB 01001101b ;6
          DB 01011001b ;7
          DB 01010001b ;8
          DB 01110001b ;9
          DB 01100001b ;10
          DB 01000001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;К
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01000010b ;2
          DB 01000100b ;3
          DB 01001100b ;4
          DB 01011000b ;5
          DB 01110000b ;6
          DB 01110000b ;7
          DB 01011000b ;8
          DB 01001100b ;9
          DB 01000100b ;10
          DB 01000010b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Л
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00111110b ;2
          DB 00100010b ;3
          DB 00100010b ;4
          DB 00100010b ;5
          DB 00100010b ;6
          DB 00100010b ;7
          DB 01100010b ;8
          DB 01000010b ;9
          DB 01000010b ;10
          DB 11000010b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;М
          DB 00000000b ;0
          DB 00000000b ;1
          DB 11000001b ;2
          DB 11100011b ;3
          DB 11100011b ;4
          DB 11110101b ;5
          DB 11010101b ;6
          DB 11010101b ;7
          DB 11001001b ;8
          DB 11000001b ;9
          DB 11000001b ;10
          DB 11000001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Н
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01000001b ;2
          DB 01000001b ;3
          DB 01000001b ;4
          DB 01000001b ;5
          DB 01111111b ;6
          DB 01000001b ;7
          DB 01000001b ;8
          DB 01000001b ;9
          DB 01000001b ;10
          DB 01000001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;О
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00111100b ;2
          DB 01000010b ;3
          DB 11000001b ;4
          DB 10000001b ;5
          DB 10000001b ;6
          DB 10000001b ;7
          DB 10000001b ;8
          DB 10000011b ;9
          DB 01000010b ;10
          DB 00111100b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;П
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01111111b ;2
          DB 01000001b ;3
          DB 01000001b ;4
          DB 01000001b ;5
          DB 01000001b ;6
          DB 01000001b ;7
          DB 01000001b ;8
          DB 01000001b ;9
          DB 01000001b ;10
          DB 01000001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Р
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01111100b ;2
          DB 01000110b ;3
          DB 01000010b ;4
          DB 01000010b ;5
          DB 01000110b ;6
          DB 01111000b ;7
          DB 01000000b ;8
          DB 01000000b ;9
          DB 01000000b ;10
          DB 01000000b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;С
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00011110b ;2
          DB 00110001b ;3
          DB 00100000b ;4
          DB 01000000b ;5
          DB 01000000b ;6
          DB 01000000b ;7
          DB 01000000b ;8
          DB 01100000b ;9
          DB 00100001b ;10
          DB 00011110b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Т
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01111111b ;2
          DB 00001000b ;3
          DB 00001000b ;4
          DB 00001000b ;5
          DB 00001000b ;6
          DB 00001000b ;7
          DB 00001000b ;8
          DB 00001000b ;9
          DB 00001000b ;10
          DB 00001000b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;У
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01000001b ;2
          DB 01100011b ;3
          DB 00100010b ;4
          DB 00110110b ;5
          DB 00010100b ;6
          DB 00011100b ;7
          DB 00001000b ;8
          DB 00001000b ;9
          DB 00011000b ;10
          DB 01110000b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Ф
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00001000b ;2
          DB 00011110b ;3
          DB 00101010b ;4
          DB 01001001b ;5
          DB 01001001b ;6
          DB 01001001b ;7
          DB 01001001b ;8
          DB 01101010b ;9
          DB 00111100b ;10
          DB 00001000b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Х
          DB 00000000b ;0
          DB 00000000b ;1
          DB 11000011b ;2
          DB 01100110b ;3
          DB 00110100b ;4
          DB 00011100b ;5
          DB 00011000b ;6
          DB 00011100b ;7
          DB 00110100b ;8
          DB 00100110b ;9
          DB 01100011b ;10
          DB 11000001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Ц
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01000001b ;2
          DB 01000001b ;3
          DB 01000001b ;4
          DB 01000001b ;5
          DB 01000001b ;6
          DB 01000001b ;7
          DB 01000001b ;8
          DB 01000001b ;9
          DB 01000001b ;10
          DB 01111111b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Ч
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01000001b ;2
          DB 01000001b ;3
          DB 01000001b ;4
          DB 01000001b ;5
          DB 01100001b ;6
          DB 00111111b ;7
          DB 00000001b ;8
          DB 00000001b ;9
          DB 00000001b ;10
          DB 00000001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Ш
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01001001b ;2
          DB 01001001b ;3
          DB 01001001b ;4
          DB 01001001b ;5
          DB 01001001b ;6
          DB 01001001b ;7
          DB 01001001b ;8
          DB 01001001b ;9
          DB 01001001b ;10
          DB 01111111b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Щ
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01001001b ;2
          DB 01001001b ;3
          DB 01001001b ;4
          DB 01001001b ;5
          DB 01001001b ;6
          DB 01001001b ;7
          DB 01001001b ;8
          DB 01001001b ;9
          DB 01001001b ;10
          DB 01111111b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Ъ
          DB 00000000b ;0
          DB 00000000b ;1
          DB 11100000b ;2
          DB 00100000b ;3
          DB 00100000b ;4
          DB 00100000b ;5
          DB 00111110b ;6
          DB 00100011b ;7
          DB 00100001b ;8
          DB 00100001b ;9
          DB 00100011b ;10
          DB 00111110b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Ы
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01000001b ;2
          DB 01000001b ;3
          DB 01000001b ;4
          DB 01000001b ;5
          DB 01111001b ;6
          DB 01000101b ;7
          DB 01000101b ;8
          DB 01000101b ;9
          DB 01001101b ;10
          DB 01111001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Ь
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01000000b ;2
          DB 01000000b ;3
          DB 01000000b ;4
          DB 01000000b ;5
          DB 01111100b ;6
          DB 01000110b ;7
          DB 01000010b ;8
          DB 01000010b ;9
          DB 01000110b ;10
          DB 01111100b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Э
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00111100b ;2
          DB 01000010b ;3
          DB 00000001b ;4
          DB 00000001b ;5
          DB 00111111b ;6
          DB 00000001b ;7
          DB 00000001b ;8
          DB 00000011b ;9
          DB 01000010b ;10
          DB 00111100b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Ю
          DB 00000000b ;0
          DB 00000000b ;1
          DB 01001111b ;2
          DB 01011001b ;3
          DB 01010000b ;4
          DB 01010000b ;5
          DB 01110000b ;6
          DB 01010000b ;7
          DB 01010000b ;8
          DB 01010000b ;9
          DB 01001001b ;10
          DB 01001111b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Я
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00011110b ;2
          DB 00100010b ;3
          DB 00100010b ;4
          DB 00100010b ;5
          DB 00110010b ;6
          DB 00011110b ;7
          DB 00110010b ;8
          DB 00100010b ;9
          DB 01100010b ;10
          DB 01100010b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;а
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 00011100b ;5
          DB 00100010b ;6
          DB 00000010b ;7
          DB 00111110b ;8
          DB 01000010b ;9
          DB 01000110b ;10
          DB 00111010b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;б
          DB 00000000b ;0
          DB 00011110b ;1
          DB 00100000b ;2
          DB 00100000b ;3
          DB 01011110b ;4
          DB 01100010b ;5
          DB 01000001b ;6
          DB 01000001b ;7
          DB 01000001b ;8
          DB 01000001b ;9
          DB 00100010b ;10
          DB 00011100b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;в
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01111100b ;5
          DB 01000010b ;6
          DB 01000010b ;7
          DB 01111100b ;8
          DB 01000010b ;9
          DB 01000010b ;10
          DB 01111100b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;г
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 00111111b ;5
          DB 00100000b ;6
          DB 00100000b ;7
          DB 00100000b ;8
          DB 00100000b ;9
          DB 00100000b ;10
          DB 00100000b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;д
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 00111110b ;5
          DB 00100010b ;6
          DB 00100010b ;7
          DB 00100010b ;8
          DB 01100010b ;9
          DB 01000010b ;10
          DB 11111111b ;11
          DB 10000001b ;12
          DB 10000001b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;е
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 00011110b ;5
          DB 00100011b ;6
          DB 01000001b ;7
          DB 01111111b ;8
          DB 01000000b ;9
          DB 01100000b ;10
          DB 00011111b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;ж
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 10001000b ;5
          DB 01001001b ;6
          DB 00101010b ;7
          DB 00011100b ;8
          DB 00101010b ;9
          DB 01101011b ;10
          DB 11001001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;з
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01111100b ;5
          DB 00000010b ;6
          DB 00000010b ;7
          DB 00111100b ;8
          DB 00000010b ;9
          DB 00000010b ;10
          DB 01111100b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;и
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01000010b ;5
          DB 01000110b ;6
          DB 01001110b ;7
          DB 01011010b ;8
          DB 01110010b ;9
          DB 01100010b ;10
          DB 01000010b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;й
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00100100b ;2
          DB 00111000b ;3
          DB 00000000b ;4
          DB 01000010b ;5
          DB 01000110b ;6
          DB 01001110b ;7
          DB 01011010b ;8
          DB 01110010b ;9
          DB 01100010b ;10
          DB 01000010b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;к
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01000010b ;5
          DB 01001100b ;6
          DB 01010000b ;7
          DB 01100000b ;8
          DB 01011000b ;9
          DB 01001100b ;10
          DB 01000110b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;л
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 00111110b ;5
          DB 00100010b ;6
          DB 00100010b ;7
          DB 00100010b ;8
          DB 00100010b ;9
          DB 01000010b ;10
          DB 11000010b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;м
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01100011b ;5
          DB 01010101b ;6
          DB 01010101b ;7
          DB 01010101b ;8
          DB 01001001b ;9
          DB 01000001b ;10
          DB 01000001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;н
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01000010b ;5
          DB 01000010b ;6
          DB 01000010b ;7
          DB 01111110b ;8
          DB 01000010b ;9
          DB 01000010b ;10
          DB 01000010b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;о
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 00011110b ;5
          DB 00100011b ;6
          DB 01000001b ;7
          DB 01000001b ;8
          DB 01000001b ;9
          DB 01100010b ;10
          DB 00111100b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;п
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01111110b ;5
          DB 01000010b ;6
          DB 01000010b ;7
          DB 01000010b ;8
          DB 01000010b ;9
          DB 01000010b ;10
          DB 01000010b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;}
ЭКРАН_80_25_ШРИФТ_р_ё :;{ Руские буквы от (р) до (ё) 8 Бит в ширину 16 байт в высоту кодировка CP866
          ;-------------;р
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01011110b ;5
          DB 01100011b ;6
          DB 01000001b ;7
          DB 01000001b ;8
          DB 01000001b ;9
          DB 01000010b ;10
          DB 01111100b ;11
          DB 01000000b ;12
          DB 01000000b ;13
          DB 01000000b ;14
          DB 00000000b ;15
          ;-------------;с
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 00011110b ;5
          DB 00100000b ;6
          DB 01000000b ;7
          DB 01000000b ;8
          DB 01000000b ;9
          DB 01100000b ;10
          DB 00011110b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;т
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01111111b ;5
          DB 00001000b ;6
          DB 00001000b ;7
          DB 00001000b ;8
          DB 00001000b ;9
          DB 00001000b ;10
          DB 00001000b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;у
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01000001b ;5
          DB 01100011b ;6
          DB 00100010b ;7
          DB 00100110b ;8
          DB 00010100b ;9
          DB 00010100b ;10
          DB 00011000b ;11
          DB 00011000b ;12
          DB 00010000b ;13
          DB 11100000b ;14
          DB 00000000b ;15
          ;-------------;ф
          DB 00000000b ;0
          DB 00001000b ;1
          DB 00001000b ;2
          DB 00001000b ;3
          DB 00011110b ;4
          DB 00101011b ;5
          DB 01001001b ;6
          DB 01001001b ;7
          DB 01001001b ;8
          DB 01001001b ;9
          DB 01101010b ;10
          DB 00111100b ;11
          DB 00001000b ;12
          DB 00001000b ;13
          DB 00001000b ;14
          DB 00000000b ;15
          ;-------------;х
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01100011b ;5
          DB 00110110b ;6
          DB 00011100b ;7
          DB 00001100b ;8
          DB 00010110b ;9
          DB 00110011b ;10
          DB 01100001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;ц
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01000010b ;5
          DB 01000010b ;6
          DB 01000010b ;7
          DB 01000010b ;8
          DB 01000010b ;9
          DB 01000010b ;10
          DB 01111111b ;11
          DB 00000001b ;12
          DB 00000001b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;ч
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01000010b ;5
          DB 01000010b ;6
          DB 01000010b ;7
          DB 00111110b ;8
          DB 00000010b ;9
          DB 00000010b ;10
          DB 00000010b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;ш
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01001001b ;5
          DB 01001001b ;6
          DB 01001001b ;7
          DB 01001001b ;8
          DB 01001001b ;9
          DB 01001001b ;10
          DB 01111111b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;щ
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01001001b ;5
          DB 01001001b ;6
          DB 01001001b ;7
          DB 01001001b ;8
          DB 01001001b ;9
          DB 01001001b ;10
          DB 01111111b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;ъ
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 11100000b ;5
          DB 00100000b ;6
          DB 00100000b ;7
          DB 00111100b ;8
          DB 00100010b ;9
          DB 00100010b ;10
          DB 00111100b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;ы
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01000001b ;5
          DB 01000001b ;6
          DB 01000001b ;7
          DB 01111001b ;8
          DB 01000101b ;9
          DB 01000101b ;10
          DB 01111001b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;ь
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01000000b ;5
          DB 01000000b ;6
          DB 01000000b ;7
          DB 01111100b ;8
          DB 01000010b ;9
          DB 01000010b ;10
          DB 01111100b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;э
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01111100b ;5
          DB 00000110b ;6
          DB 00000010b ;7
          DB 01111110b ;8
          DB 00000010b ;9
          DB 00000110b ;10
          DB 01111000b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;ю
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 01001111b ;5
          DB 01011001b ;6
          DB 01010000b ;7
          DB 01110000b ;8
          DB 01010000b ;9
          DB 01011001b ;10
          DB 01001111b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;я
          DB 00000000b ;0
          DB 00000000b ;1
          DB 00000000b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 00011110b ;5
          DB 00100010b ;6
          DB 00100010b ;7
          DB 00011110b ;8
          DB 00110010b ;9
          DB 00100010b ;10
          DB 01100010b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;Ё
          DB 00100100b ;0
          DB 00000000b ;1
          DB 00111111b ;2
          DB 00100000b ;3
          DB 00100000b ;4
          DB 00100000b ;5
          DB 00111111b ;6
          DB 00100000b ;7
          DB 00100000b ;8
          DB 00100000b ;9
          DB 00100000b ;10
          DB 00111111b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;-------------;ё
          DB 00000000b ;0
          DB 00110110b ;1
          DB 00110110b ;2
          DB 00000000b ;3
          DB 00000000b ;4
          DB 00011110b ;5
          DB 00100011b ;6
          DB 01000001b ;7
          DB 01111111b ;8
          DB 01000000b ;9
          DB 01100000b ;10
          DB 00011111b ;11
          DB 00000000b ;12
          DB 00000000b ;13
          DB 00000000b ;14
          DB 00000000b ;15
          ;}
;}
END IF;
;}

;// переменные для работы с мышкой на низком уровне
БУКВА_1                : DD 0; // Символ нажатой кнопки клавиатуры
КНОПКА_1               : DD 0; // Скан код нажатой кнопки клавиатуры
МЫШКА_I1               : DD 0; // Информация о мышке Нажатые кнопки и так далее
МЫШКА_X1               : DD 0;
МЫШКА_Y1               : DD 0;
;// ПРедыдущие значение данных от PS/2
БУКВА_2                : DD 0; // Символ Ранее нажатой кнопки клавиатуры
КНОПКА_2               : DD 0; // Скан код нажатой кнопки клавиатуры
МЫШКА_I2               : DD 0; // Информация о мышке Нажатые кнопки и так далее
МЫШКА_X2               : DD 0;
МЫШКА_Y2               : DD 0;




МЫШКА_ПX1: DD 0;
МЫШКА_ПY1: DD 0;
                                                        ;-КОНЕЦ:
;}
;---{ ФУНКЦИИ ДЛЯ РАБОТЫ С ПРЕРЫВАНИЯМИ     .
IF ПЛАТФОРМА = T32  ;{
TR_ЭКРАН_80_25_ВЫВОД_AX_CX_DX :;{ Функция Вывод Символ AL с атрибутами AH если AL=0 то выводит тока атрибуты
        pushad;
        mov  bx,ax          ; // Сохраняю выводимый символ и атрибуты в регистр BX
        ;-------------------;
        mov  ESI,0B8000h    ; Настраиваем регистр DI на началово Адреса видео буфера
        ;-------------------;
        mov  ch,0;
        cmp  ecx,79;
        ja .ВЫХОД;
        mov  dh,0;
        cmp  edx,24;
        ja .ВЫХОД;

        ;-------------------;
        mov  eax,2          ;  (КОД,АТРИБУТ) 2 байта на 1 символ
        mul  cl             ;  Умнажем координату по X на 2
        mov  ecx,eax        ;  Запоминаем
        mov  eax,160        ;  Помещаем в регистр AX длину 1 строки на экране
        mul  dl             ;
        ADD  AX,CX          ;
        ADD  ESI,Eax        ;
        test bl,bl          ;
        jz  .ДАЛЕЕ          ;
        MOV  byte[ES:ESI],bl   ;       (Символ)
.ДАЛЕЕ: inc  ESI            ;
        MOV  byte[ES:ESI],bh   ;       (Цвет Атрибут)
        ;-------------------;
.ВЫХОД:                     ;
        popad               ;
        ret                 ;
;==============================================================================}
;{ I00  INT0 Деление на ноль
I00:
    pushad

    popad
    iretd
;}
;{ I01  INT1
I01:
    pushad
    popad
    iretd
;}
;{ I13  ОШИБКА
I13:
pop  eax ; код ошибки
iretd
;}
;{ I32  обработчик - системный таймер IRQ0
I32:
pushad;
mov  eax,[TR_TIMER];
inc  eax;
mov  [TR_TIMER],eax;
mov  al, 20h
out  020h, al   ; ... в ведущий (Master) контроллер ...
popad;
iretd
;}
;{ I33  обработчик - клавиатура IRQ 1
I33:
pushad                      ;
;-----------------------;
call TR_PS2_ЧТЕНИЕ_64   ; // Читаю порт 64
test al,10000000b       ;
jnz .ПРОПУСТИТЬ         ; // При чтении произошла ошибка четности
test al,01000000b       ;
jnz .ПРОПУСТИТЬ         ; // ПРоизошол таймаут
test al,00000001b       ;
jz  .ВЫХОД              ; // Если нет входящих данных
test al,00100000b       ;
jnz .ВЫХОД              ; // Если это данные от мышки
;-----------------------;
.ПРОПУСТИТЬ:



mov  eax,0             ;
mov  ax,[КНОПКА_1]     ;
mov  [КНОПКА_2],ax     ;
call TR_PS2_ЧТЕНИЕ_60  ;
mov  [КНОПКА_1],al     ;
call СКАНКОД_В_БУКВУ   ;
mov  [БУКВА_1],ax      ;
mov [keypress],byte 0  ;
                .ВЫХОД:;


mov ax,[БУКВА_1];
mov [НАЖ_КНОПК],AX;
mov ax,0;
mov [БУКВА_1],ax;


mov  al, 20h
out  020h, al   ; ... в ведущий (Master) контроллер ...
out  0a0h, al   ; ... и в ведомый (Slave) контроллер.
popad                       ;
iretd
keypress :DD 1;
;}
;{ I44  обработчик - Мышка IRQ 12
I44:
pushad;
mov ax,[TR_MOUSE_X];
mov [TR_MOUSE_X0],ax;
mov ax,[TR_MOUSE_Y];
mov [TR_MOUSE_Y0],ax;
call TR_PS2_INT_74_МЫШКА;

mov  al,0
mov  ah,[ЭКРАН_80_25_ФОН];
mov  ecx,[TR_MOUSE_X0];
mov  edx,[TR_MOUSE_Y0];
call TR_ЭКРАН_80_25_ВЫВОД_AX_CX_DX;


mov  al,0
mov  ah,[МЫШ_ЦВЕТА];
mov  cx,[TR_MOUSE_X];
shr  cx,3;
mov  dx,192*2;
sub  dx,[TR_MOUSE_Y];
shr  dx,4;
call TR_ЭКРАН_80_25_ВЫВОД_AX_CX_DX;


Mov cx,[TR_MOUSE_X];
shr cx,3;
mov dx,192*2;
sub dx,[TR_MOUSE_Y];
shr dx,4;
Mov [МЫШКА_X1],cx;
Mov [МЫШКА_Y1],dx;



mov  al, 20h
out  020h, al   ; ... в ведущий (Master) контроллер ...
out  0a0h, al   ; ... и в ведомый (Slave) контроллер.
popad;
iretd

;}
;{ int_EOI Пустой обработчик. сбрасывает заявку в контроллере
EOI:
int_EOI:
; сброс заявки в контроллере прерываний: посылка End-Of-Interrupt (EOI) ...
push ax
mov  al, 20h
out  020h, al   ; ... в ведущий (Master) контроллер ...
out  0a0h, al   ; ... и в ведомый (Slave) контроллер.
pop  ax
iretd           ; возврат из прерывания
;}
;{ APIC Off
redirect_IRQ:
; BX = { BL = Начало для IRQ 0..7, BH = начало для IRQ 8..15 }
; DX = Маска прерываний IRQ ( DL - для IRQ 0..7, DH - IRQ 8..15 )

        ; APIC Off
        mov     ecx,1bh
        rdmsr
        or      ah,1000b
        wrmsr

        mov     al,11h     ; Комманда 11
        out     0a0h,al    ; Slave  PIC - Command
        out     20h,al     ; Master PIC - Command

        mov     al,bh      ;BH = начало для IRQ 8..15
        out     0a1h,al    ;Slave PIC - Data
        mov     al,bl      ;BL = Начало для IRQ 0..7
        out     21h,al     ;Master PIC - Data

        mov     al,02      ;
        out     0a1h,al    ; Slave PIC - Data
        mov     al,04      ;
        out     21h,al     ; Master PIC - Data

        mov     al,01
        out     0a1h,al    ; Slave PIC - Data
        out     21h,al     ; Master PIC - Data

        mov     al,dh      ; МАСКА DH - IRQ 8..15
        out     0a1h,al    ; Slave PIC - Data
        mov     al,dl      ; МАСКА DL - IRQ 0..7
        out     21h,al     ; Master PIC - Data

        ; APIC On
        mov     ecx,1bh
        rdmsr
        and     ah,11110111b
        wrmsr

        ret

;}
END IF ;}
IF ПЛАТФОРМА = ДОС  ;{
TR_ЭКРАН_80_25_ВЫВОД_AX_CX_DX :;{ Функция Вывод Символ AL с атрибутами AH если AL=0 то выводит тока атрибуты
        pushad;
        mov  bx,ax          ; // Сохраняю выводимый символ и атрибуты в регистр BX
        ;-------------------;
        mov  SI,0B800h      ; Настраиваем регистр DI на началово Адреса видео буфера
        ;-------------------;
        mov  ch,0;
        cmp  ecx,79;
        ja .ВЫХОД;
        mov  dh,0;
        cmp  edx,24;
        ja .ВЫХОД;

        ;-------------------;
        mov  ax,2           ;  (КОД,АТРИБУТ) 2 байта на 1 символ
        mul  cl             ;  Умнажем координату по X на 2
        mov  cx,ax          ;  Запоминаем
        mov  ax,160         ;  Помещаем в регистр AX длину 1 строки на экране
        mul  dl             ;
        ADD  AX,CX          ;
        ADD  SI,ax          ;
        test bl,bl          ;
        jz  .ДАЛЕЕ          ;
        MOV  byte[ES:SI],bl ;       (Символ)
.ДАЛЕЕ: inc  ESI            ;
        MOV  byte[ES:SI],bh ;       (Цвет Атрибут)
        ;-------------------;
.ВЫХОД:                     ;
        popad               ;
        ret                 ;
;==============================================================================}
END IF ;}
IF ПЛАТФОРМА = T16  ;{

TR_ЭКРАН_80_25_ВЫВОД_AX_CX_DX :;{ Функция Вывод Символ AL с атрибутами AH если AL=0 то выводит тока атрибуты
        pushad;
        mov  bx,ax          ; // Сохраняю выводимый символ и атрибуты в регистр BX
        ;-------------------;
        mov  SI,0B800h      ; Настраиваем регистр DI на началово Адреса видео буфера
        ;-------------------;
        mov  ch,0;
        cmp  ecx,79;
        ja .ВЫХОД;
        mov  dh,0;
        cmp  edx,24;
        ja .ВЫХОД;

        ;-------------------;
        mov  ax,2           ;  (КОД,АТРИБУТ) 2 байта на 1 символ
        mul  cl             ;  Умнажем координату по X на 2
        mov  cx,ax          ;  Запоминаем
        mov  ax,160         ;  Помещаем в регистр AX длину 1 строки на экране
        mul  dl             ;
        ADD  AX,CX          ;
        ADD  SI,ax          ;
        test bl,bl          ;
        jz  .ДАЛЕЕ          ;
        MOV  byte[ES:SI],bl ;       (Символ)
.ДАЛЕЕ: inc  ESI            ;
        MOV  byte[ES:SI],bh ;       (Цвет Атрибут)
        ;-------------------;
.ВЫХОД:                     ;
        popad               ;
        ret                 ;
;==============================================================================}
TR_ЭКРАН_80_25_ОЧИСТКА         :;{ Очистка экрана
          pushad
          ;------------------------;
          mov  ax,0xB800           ;
          mov  ES,ax               ;
          mov  SI,0                ;
          ;------------------------;
          mov  cx,2000             ; // Для счета заполняемых символов
          mov  al,' '              ; // Записываем символ
          mov  ah,[ЭКРАН_80_25_ФОН]; // Атрибуты экрана
          ;------------------------;
.ЦИКЛ:    test cx,cx               ; // Проверяем на 0 пока CX<>0
          jz  .КЦИКЛ               ; // Если CX=0 ВЫход
          MOV [ES:SI],al           ; // Записываем код выводимого символа
          inc  SI                  ; // Увеличиваем адрес
          MOV [ES:SI],ah           ; // Записываем атрибуты
          inc  SI                  ; // Увеличиваем адрес
          dec  cx                  ; // Уменьшаем счетчик
          jmp .ЦИКЛ                ; // Повторить
.КЦИКЛ:   ;------------------------;
          popad                    ;
          ret                      ;
;==============================================================================}
;{ I00  INT0 Деление на ноль
I00:
    pushad

    popad
    iret
;}
;{ I01  INT1
I01:
    pushad
    popad
    iret
;}
;{ I13  ОШИБКА
I13:
pop  eax ; код ошибки
iret
;}
;{ I32  обработчик - системный таймер IRQ0
I32:
pushad;
mov  eax,[TR_TIMER];
inc  eax;
mov  [TR_TIMER],eax;
pushf                               ; // Имитировать INT
call far [TR_INT_08_БИОС_ТАЙМЕР]    ; // Выполнить нормальную обработку
popad;
iret
;}
;{ I33  обработчик - клавиатура IRQ 1
I33:
pushad
;-----------------------;
call TR_PS2_ЧТЕНИЕ_64   ; // Читаю порт 64
test al,10000000b       ;
jnz .ПРОПУСТИТЬ         ; // При чтении произошла ошибка четности
test al,01000000b       ;
jnz .ПРОПУСТИТЬ         ; // ПРоизошол таймаут
test al,00000001b       ;
jz  .ВЫХОД              ; // Если нет входящих данных
test al,00100000b       ;
jnz .ВЫХОД              ; // Если это данные от мышки
;-----------------------;
.ПРОПУСТИТЬ:



mov  eax,0             ;
mov  ax,[КНОПКА_1]     ;
mov  [КНОПКА_2],ax     ;
call TR_PS2_ЧТЕНИЕ_60  ;
mov  [КНОПКА_1],al     ;
call СКАНКОД_В_БУКВУ   ;
mov  [БУКВА_1],ax      ;
mov  [keypress],byte 0  ;
                .ВЫХОД:;


mov ax,[БУКВА_1];
mov [НАЖ_КНОПК],AX;
mov ax,0;
mov [БУКВА_1],ax;



mov  al, 20h
out  020h, al   ; ... в ведущий (Master) контроллер ...
out  0a0h, al   ; ... и в ведомый (Slave) контроллер.

popad                  ;
iret
keypress :DD 1;
;}
;{ I44  обработчик - Мышка IRQ 12
I44:
pushad;
mov ax,[TR_MOUSE_X];
mov [TR_MOUSE_X0],ax;
mov ax,[TR_MOUSE_Y];
mov [TR_MOUSE_Y0],ax;
call TR_PS2_INT_74_МЫШКА;

mov  al,0
mov  ah,[ЭКРАН_80_25_ФОН];
mov  ecx,[TR_MOUSE_X0];
mov  edx,[TR_MOUSE_Y0];
call TR_ЭКРАН_80_25_ВЫВОД_AX_CX_DX;


mov  al,0
mov  ah,[МЫШ_ЦВЕТА];
mov  cx,[TR_MOUSE_X];
shr  cx,3;
mov  dx,192*2;
sub  dx,[TR_MOUSE_Y];
shr  dx,4;
call TR_ЭКРАН_80_25_ВЫВОД_AX_CX_DX;


Mov cx,[TR_MOUSE_X];
shr cx,3;
mov dx,192*2;
sub dx,[TR_MOUSE_Y];
shr dx,4;
Mov [МЫШКА_X1],cx;
Mov [МЫШКА_Y1],dx;

mov  al, 20h
out  020h, al   ; ... в ведущий (Master) контроллер ...
out  0a0h, al   ; ... и в ведомый (Slave) контроллер.
popad;
iret

;}
;{ int_EOI Пустой обработчик. сбрасывает заявку в контроллере
EOI:
int_EOI:
; сброс заявки в контроллере прерываний: посылка End-Of-Interrupt (EOI) ...
push ax
mov  al, 20h
out  020h, al   ; ... в ведущий (Master) контроллер ...
out  0a0h, al   ; ... и в ведомый (Slave) контроллер.
pop  ax
iretd           ; возврат из прерывания
;}
TR_INT_08_БИОС_ТАЙМЕР    :DD 0;
TR_INT_09_БИОС_КЛАВИАТУРА:DD 0;
TR_INT_74_БИОС_МЫШКА     :DD 0;

END IF ;}
;}
;---{ Автономные функции для работы с PS2  на низком уровне
;---{ Описание
; Мудуль для работы с клавиатурой и мышкой PS2
; Сперва запускаем инициализацию МЫШ_ИНИЦИАЛИЗАЦИЯ
; затем можно  использовать МЫШ_ЧТЕНИЕ для чтения данных с мышки и клавиатуры
; Результат чтения записываеться в переменные их 2 копии предыдущие и новое значение для удобства
;---}

МЫШ_ИНИЦИАЛИЗАЦИЯ:;{   ..................................

        pushad;
        IF ПЛАТФОРМА = ДОС  ;{

        mov ax,0;
        int 33h ;

        END IF;}
        IF ПЛАТФОРМА = T16  ;{
        ; Включает мыш

        END IF ;}
        IF ПЛАТФОРМА = T33  ;{
        ; Включает мыш

        mov  al,0FFh;
        Call PS2_ЗАПИСЬ_AL_В_ПОРТ_64;

        mov  al,0A8h;
        Call PS2_ЗАПИСЬ_AL_В_ПОРТ_64;

        ; Установка стандартных настроек
        mov  al,0xD4
        Call PS2_ЗАПИСЬ_AL_В_ПОРТ_64;
        mov  al,0xF6;               ;
        Call PS2_ЗАПИСЬ_AL_В_ПОРТ_60;

        ; Включение потокового режима
        mov  al,0xD4
        Call PS2_ЗАПИСЬ_AL_В_ПОРТ_64;
        mov  al,0xEA
        Call PS2_ЗАПИСЬ_AL_В_ПОРТ_60;

        ; Включение отправки отчетов
        mov  al,0xD4
        Call PS2_ЗАПИСЬ_AL_В_ПОРТ_64;
        mov  al,0xF4
        Call PS2_ЗАПИСЬ_AL_В_ПОРТ_60;


        END IF ;}
        IF ПЛАТФОРМА = T32  ;{
        ; Включает мыш

        END IF ;}
        popad;
        ret;
;==============================================================================}

МЫШ_ЧТЕНИЕ2       :;{
            pushad;
            IF ПЛАТФОРМА = ДОС  ;{
            mov ax,3;// Чтения состояния мышки
            int 33h ;
            SHR cx,3;
            SHR dx,3;
            Mov [МЫШКА_X1],cx;
            Mov [МЫШКА_Y1],dx;
            Mov [МЫШКА_I1],bx;
            END IF ;}
            IF ПЛАТФОРМА = T16  ;{
            mov  ax,[TR_BYTE0_B]        ;
            mov  ah,0                   ;
            shl  al,6                   ;
            shr  al,6                   ;
            mov  [МЫШКА_I1],ax          ;
            END IF ;}
            IF ПЛАТФОРМА = T33  ;{
            call PS2_ЧТЕНИЕ_64ПОРТА_В_AL;
            test al,100000b             ;
            jnz .ЧИТАТЬ_МЫШ             ;

            mov  ax,[КНОПКА_1]          ;
            mov  [КНОПКА_2],ax          ;

            call PS2_ЧТЕНИЕ_60ПОРТА_В_AL;
            jz  .ВЫХОД                  ;
            mov  [КНОПКА_1],al          ;
            call СКАНКОД_В_БУКВУ        ;
            mov  [БУКВА_1],ax           ;
            jmp .ВЫХОД                  ;

.ЧИТАТЬ_МЫШ:
            ;{ Запоминаем предыдущие координаты
            mov ax,[МЫШКА_I1];
            mov [МЫШКА_I2],ax;

            mov ax,[МЫШКА_X1];
            mov [МЫШКА_X2],ax;

            mov ax,[МЫШКА_Y1];
            mov [МЫШКА_Y2],ax;
            ;-----------------}
            call PS2_ЧТЕНИЕ_60ПОРТА_В_AL; // Чтение информационого байта от мышки
            jz  .ВЫХОД                  ;
            mov  [МЫШКА_I3],al          ; // Запоминаем потому что в инф байте данные о переносе и знаке
            ;---------------------------;
            call PS2_ЧТЕНИЕ_60ПОРТА_В_AL;
            jz  .ВЫХОД                  ;
            mov  [МЫШКА_ПX1],al         ;
            ;---------------------------;
            call PS2_ЧТЕНИЕ_60ПОРТА_В_AL;
            jz  .ВЫХОД                  ;
            mov  [МЫШКА_ПY1],al         ;
            ;---------------------------;
            ;{Вычисление нажатых кнопок ;
            ;---------------------------;
            mov  ax,[МЫШКА_I3]          ;
            mov  ah,0                   ;
            shl  al,6                   ;
            shr  al,6                   ;
            mov  [МЫШКА_I1],ax          ;}
            ;---------------------------;
            mov  cl,[МЫШКА_I3]
            not  cl;
            shl  cl,3
            shr  cl,7
            mov  ax,[МЫШКА_ПX1]
            mov  ah,cl;
            mov  [МЫШКА_ПX1],ax;

            mov  cl,[МЫШКА_I3]
            not  cl;
            shl  cl,2
            shr  cl,7
            mov  ax,[МЫШКА_ПY1]
            mov  ah,cl;
            mov  [МЫШКА_ПY1],ax;

            mov  ax,[МЫШКА_ПX1]
            cmp  ax,255
            jb  .МЕНЬШЕX;
            cmp  ax,256
            ja  .БОЛЬШЕX;
            jmp .ВЫХОДX;
.МЕНЬШЕX:   ;--------------------;{
            mov  cx,255          ;
            sub  cx,ax           ;
            mov  ax,[МЫШКА_X3]   ;
            sub  AX,CX           ;
            jae .МДX             ;
            mov  ax,0            ;
.МДX:       mov  [МЫШКА_X3],ax   ;
            jmp .ВЫХОДX          ;}
.БОЛЬШЕX:   ;--------------------;{
            sub  ax,255          ;
            mov  cx,ax           ;
            mov  ax,[МЫШКА_X3]   ;
            add  AX,CX           ;
            cmp  ax,XM           ;
            jbe .БДX             ;
            mov ax,XM            ;
.БДX:       mov  [МЫШКА_X3],ax   ;
            jmp .ВЫХОДX          ;}
.ВЫХОДX:



            mov  ax,[МЫШКА_ПY1]
            cmp  ax,255
            jb  .МЕНЬШЕY;
            cmp  ax,256
            ja  .БОЛЬШЕY;
            jmp .ВЫХОДY;
.МЕНЬШЕY:   ;--------------------;{
            mov  cx,255          ;
            sub  cx,ax           ;
            mov  ax,[МЫШКА_Y3]   ;
            add  AX,CX           ;
            cmp  ax,YM           ;
            jbe .МДY             ;
            mov  ax,YM           ;
.МДY:       mov  [МЫШКА_Y3],ax   ;
            jmp .ВЫХОДY          ;}
.БОЛЬШЕY:   ;--------------------;{
            sub  ax,255          ;
            mov  cx,ax           ;
            mov  ax,[МЫШКА_Y3]   ;
            sub  AX,CX           ;
            jae .БДY             ;
            mov  ax,0            ;
.БДY:       mov  [МЫШКА_Y3],ax   ;
            jmp .ВЫХОДY          ;}
.ВЫХОДY:


            mov eax,[МЫШКА_X3];
            shr ax,2;
            mov [МЫШКА_X1],eax;


            mov eax,[МЫШКА_Y3];
            shr ax,3;
            mov [МЫШКА_Y1],eax;

.ВЫХОД:


            END IF ;}
            IF ПЛАТФОРМА = T32  ;{

            mov  ax,[TR_BYTE0_B]        ;
            mov  ah,0                   ;
            shl  al,6                   ;
            shr  al,6                   ;
            mov  [МЫШКА_I1],ax          ;



            END IF ;}
            popad;
            ret;
МЫШКА_I3: dd 0;
МЫШКА_X3: dd 0;
МЫШКА_Y3: dd 0;

XM =79*2*2
YM =24*2*2*2
;==============================================================================}
PS2_ЗАПИСЬ_AL_В_ПОРТ_64 :;{
            pushad;
            mov   cl,al;
.ЦИКЛ:
            in    AL,0x64
	    test  AL,2;  // 000 000 10 b
	    jz   .ВЫХОД;
            jmp  .ЦИКЛ;
.ВЫХОД:
            mov   al,cl;
            out   0x64,al;
	    popad;
	    ret;
;==============================================================================}
PS2_ЗАПИСЬ_AL_В_ПОРТ_60 :;{
            pushad;
            MOV   CL,AL;
.ЦИКЛ:
            in    AL,64h
	    test  AL,2;
	    jz   .ВЫХОД;
            jmp  .ЦИКЛ;
.ВЫХОД:
            mov   al,CL;
            out   0x60,al;
	    popad;
	    ret;
;==============================================================================}
PS2_ЧТЕНИЕ_60ПОРТА_В_AL :;{
            mov  eax,0;
            call PS2_ОЖИДАНИЕ_ДАННЫХ_ИЗ_60_ПОРТА
            jz  .ВЫХОД;
            in   al,60h
.ВЫХОД:
	    ret;
;==============================================================================}
PS2_ЧТЕНИЕ_64ПОРТА_В_AL :;{
            mov eax,0
            in  aL,64h;
	    ret;
;==============================================================================}
СКАНКОД_В_БУКВУ:;{
                ;{Описание
    ; На входе получаем AL скан код возырвщвем в Al код буквы
    ;}
                pushad;
                mov   cl,al;
                mov   eax,0;
                mov   al,cl
                Push  cx;
                mov   Cl,al;
                xor   ax,ax;
                mov   al,cl;
                pop   CX;

                cmp   al,130;
                jb   .НЕ_ИЗВЕТНЫЙ;
                cmp   al,185;
                ja   .НЕ_ИЗВЕТНЫЙ;
                mov   si,.SCANCOD;
                sub   ax,130
                add   SI,ax;
                Mov   al,[SI];
                jmp  .ВЫХОД;
.НЕ_ИЗВЕТНЫЙ:


.ДАЛЕЕ_14:      ;--------------;
                 cmp   al,14   ; del
                 jnz  .ДАЛЕЕ_28;
                 mov   ax,3592 ;
                 jmp  .ВЫХОД   ;
                ;--------------;

.ДАЛЕЕ_28:      ;--------------;
                 cmp   al,28   ; enter
                 jnz  .ДАЛЕЕ_59;
                 mov   ax,7181 ;
                 jmp  .ВЫХОД   ;
                ;--------------;

.ДАЛЕЕ_59:      ;--------------;
                cmp   al,59    ;  F1
                jnz  .ДАЛЕЕ_61 ;
                mov   ax,15104 ;
                jmp  .ВЫХОД    ;
                ;--------------;



.ДАЛЕЕ_61:      ;--------------;
                cmp   al,61    ;  F3
                jnz  .ДАЛЕЕ_62 ;
                mov   ax,15616 ;
                jmp  .ВЫХОД    ;
                ;--------------;

.ДАЛЕЕ_62:      ;--------------;
                cmp   al,62    ;  F4
                jnz  .ДАЛЕЕ_65 ;
                mov   ax,15872 ;
                jmp  .ВЫХОД    ;
                ;--------------;



.ДАЛЕЕ_65:      ;--------------;
                cmp   al,65    ;  F7
                jnz  .ДАЛЕЕ_66 ;
                mov   ax,16640 ;
                jmp  .ВЫХОД    ;
                ;--------------;


.ДАЛЕЕ_66:      ;--------------;
                cmp   al,66    ;  F8
                jnz  .ДАЛЕЕ_67 ;
                mov   ax,16896 ;
                jmp  .ВЫХОД    ;
                ;--------------;



.ДАЛЕЕ_67:      ;--------------;
                cmp   al,67    ;  F9
                jnz  .ДАЛЕЕ_68 ;
                mov   ax,17152 ;
                jmp  .ВЫХОД    ;
                ;--------------;





.ДАЛЕЕ_68:      ;--------------;
                cmp   al,68    ;  F10
                jnz  .ДАЛЕЕ_72 ;
                mov   ax,17408 ;
                jmp  .ВЫХОД    ;
                ;--------------;



.ДАЛЕЕ_72 :     ;--------------;
                cmp   al,72    ;
                jnz  .ДАЛЕЕ_75 ; Кнопка вверх
                mov   ax,18432 ;
                jmp  .ВЫХОД    ;
                ;--------------;


.ДАЛЕЕ_75:      ;--------------;
                cmp   al,75    ;
                jnz  .ДАЛЕЕ_77 ; Кнопка Влево
                mov   ax,19200 ;
                jmp  .ВЫХОД    ;
                ;--------------;


.ДАЛЕЕ_77:      ;--------------;
                cmp   al,77    ;
                jnz  .ДАЛЕЕ_80 ; Кнопка Вправо
                mov   ax,19712 ;
                jmp  .ВЫХОД    ;
                ;--------------;




.ДАЛЕЕ_80:      ;--------------;
                cmp   al,80    ;
                jnz  .ДАЛЕЕ_XX ; Кнопка Вниз
                mov   ax,20480 ;
                jmp  .ВЫХОД    ;
                ;--------------;



.ДАЛЕЕ_XX:
                mov  ax,0  ;
.ВЫХОД:         call ВОЗВРАТИТЬ_AX
                popad    ;
                ret
                .SCANCOD:;{// Скан коды
    db   "1234567890-=",12  ;//Скан коды с 130 до 142 включительно 12 это DEL
    db 9,"qwertyuiop[]",13  ;//Скан коды с 143 до 156 включительно Первй это там послдений это Enter
    db 0,"asdfghjkl;'"      ;//Скан коды с 157 до 168 Включительно Первый неизвестно
    db "`",1,"\zxcvbnm,./",2;//Скан коды с 169 до 182 включительно 1 это лев сшифт 2 это правй сшифт
    db 0,0," ";
    ;}
                ;}
PS2_ОЖИДАНИЕ_ДАННЫХ_ИЗ_60_ПОРТА:;{
pushad
            mov ebx,100;
.ЦИКЛ:
            in   al,64h;
            test al,1;
            jnz .ВЫХОД;
            test al,100000b;
            jnz .ОШИБКА;
            test al,1000000b;
            jnz .ОШИБКА;
            dec  ebx;
            test ebx,ebx;
            jz  .ОШИБКА;
            jmp .ЦИКЛ;

.ОШИБКА:    ;in al,60h;
            mov  ax,0;
            test ax,ax;
.ВЫХОД:
popad;
ret;
;}
; PS2 ------------------------------{

TR_PS2_ИНИЦИАЛИЗАЦИЯ:;--------------{
pushad;

mov  al,0xFF             ; // Сброс контроллера PS/2
Call TR_PS2_ЗАПИСЬ_ПОР_64;

mov  al,0xA8             ; // Разрешение мыши. Эта команда сбрасывает бит 5 управляющего байта
Call TR_PS2_ЗАПИСЬ_ПОР_64;

mov  al,0xAE             ; // Разрешение клавиатуры. Эта команда сбрасывает бит 4 управляющего байта (см. ниже)
Call TR_PS2_ЗАПИСЬ_ПОР_64;



mov  al,0xD4             ; // 0xD4 Передача команды в мышку
Call TR_PS2_ЗАПИСЬ_ПОР_64;
mov  al,0xFF             ; // 0xFF Сброс мышки
Call TR_PS2_ЗАПИСЬ_ПОР_60;


mov  eax,0               ;
call TR_PS2_ЧТЕНИЕ_ПОР_60; // Читаю FA
call TR_PS2_ЧТЕНИЕ_ПОР_60; // Читаю AA
call TR_PS2_ЧТЕНИЕ_ПОР_60; // Идеентификатор мыши 0

mov  al,0x20             ; //  Чтение управляющего байта
Call TR_PS2_ЗАПИСЬ_ПОР_64; //  Что бы разрешить прерывания от мыши и клавиатуры
call TR_PS2_ЧТЕНИЕ_ПОР_60; //  Читаю состояние управляющего байта

or   al,00000011b        ; // Разрешаю прерывания от клавиатуры и мышки
mov  bl,al               ; // Копирую в BL потому что в AL будет команда 60

mov  al,0x60             ; // Комнада записи управляющего байта
Call TR_PS2_ЗАПИСЬ_ПОР_64;
mov  al,bl               ; // Передаю сам управляющий байт
Call TR_PS2_ЗАПИСЬ_ПОР_60;

call TR_ПРЕРЫВАНИЯ_ВКЛ   ;

mov  al,0xD4             ; // Передача команды в мышку
Call TR_PS2_ЗАПИСЬ_ПОР_64;
mov  al,0xF4             ; // Включение отчетов
Call TR_PS2_ЗАПИСЬ_ПОР_60;


popad;
ret;


;-----------------------------------}
TR_PS2_INT_74_МЫШКА :;--------------{
 pushad

 ;-----------------------;
 call TR_PS2_ЧТЕНИЕ_64   ; // Читаю порт 64
 test al,10000000b       ;
 jnz .ПРОПУСТИТЬ         ; // При чтении произошла ошибка четности
 test al,01000000b       ;
 jnz .ПРОПУСТИТЬ         ; // ПРоизошол таймаут
 test al,00000001b       ;
 jz  .ВЫХОД              ; // Если нет входящих данных
 test al,00100000b       ;
 jz  .ПРОПУСТИТЬ         ; // Если это данные не от мышки
;------------------------;


;----------------------;
 call TR_PS2_ЧТЕНИЕ_60 ;
 mov  ECX,[TR_NOMER_B] ;
;----------------------;

;----------------------;
                .BYTE0:;
cmp  ECX,0             ;
jnz .BYTE1             ;
mov  [TR_BYTE0_B],EAX  ;
inc  ECX               ;
mov  [TR_NOMER_B],ECX  ;
jmp .ВЫХОД             ;
;----------------------;

;----------------------;
                .BYTE1:;
cmp  ECX,1             ;
jnz .BYTE2             ;
mov  [TR_BYTE1_B],EAX  ;
inc  ECX               ;
mov  [TR_NOMER_B],ECX  ;
jmp .ВЫХОД             ;
;----------------------;

;----------------------;
                .BYTE2:;
cmp  ECX,2             ;
jnz .BYTE3             ;
mov  [TR_BYTE2_B],EAX  ;
mov  ECX,0             ;
mov  [TR_NOMER_B],ECX  ;

; Мыш по X            ; {
;---------------------;
mov  AL,[TR_BYTE0_B]  ;
test al,00010000b     ;
jnz .МИНУС_1          ;
mov  ECX,[TR_MOUSE_X] ;
mov  EDX,[TR_BYTE1_B] ;
add  ECX,EDX          ;
cmp  ECX,632          ;
JBE .НОРМ1            ;
mov  ECX,632          ;
               .НОРМ1:;
mov  [TR_MOUSE_X],ECX ;
jmp .ДАЛЬШЕ1;         ;
;---------------------;
             .МИНУС_1:;
mov  ECX,[TR_MOUSE_X] ;
mov  EDX,255          ;
SUB   DX,[TR_BYTE1_B] ;
cmp  ecx,edx          ;
JAE .НОРМ3            ;
mov  EDX,ECX          ;
               .НОРМ3:;
SUB  ECX,EDX          ;
mov  [TR_MOUSE_X],ECX ;
jmp .ДАЛЬШЕ1;         ;
;---------------------;
             .ДАЛЬШЕ1:;
;---------------------;}
; Мыш по Y            ; {
;---------------------;
mov  AL,[TR_BYTE0_B]  ;
test al,00100000b     ;
jnz .МИНУС_2          ;
mov  ECX,[TR_MOUSE_Y] ;
mov  EDX,[TR_BYTE2_B] ;
add  ECX,EDX          ;
cmp  ECX,192*2        ;
JBE .НОРМ2            ;
mov  ECX,192*2        ;
               .НОРМ2:;
mov  [TR_MOUSE_Y],ECX ;
jmp .ДАЛЬШЕ2;         ;
;---------------------;
             .МИНУС_2:;
mov  ECX,[TR_MOUSE_Y] ;
mov  EDX,255          ;
SUB  EDX,[TR_BYTE2_B] ;
cmp  ecx,edx          ;
JAE .НОРМ4            ;
mov  EDX,ECX          ;
               .НОРМ4:;
SUB  ECX,EDX          ;
mov  [TR_MOUSE_Y],ECX ;
jmp .ДАЛЬШЕ2;         ;
;---------------------;
             .ДАЛЬШЕ2:;
;---------------------;}


jmp .ВЫХОД             ;
;----------------------;

;----------------------;
                .BYTE3:;
cmp  ECX,3             ;
jnz .ЗАПРОС            ;
mov  [TR_BYTE3_B],EAX  ;
mov  ECX,0             ;
mov  [TR_NOMER_B],ECX  ;
jmp .ВЫХОД             ;
;----------------------;

;----------------------;
               .ЗАПРОС:;
call  TR_PS2_ЧТЕНИЕ_60 ;
              .ЗАПРОС2:;
call  TR_PS2_ЧТЕНИЕ_64 ;
test  al,00000010b     ;
jnz  .ВЫХОД            ;  Eсли нельзя отправить команду выход
mov  al,0xD4           ;  Передача команды в мышку
Call TR_PS2_ЗАПИСЬ_ПОР_64 ;
mov  al,0xF4           ;  Включение отчетов
Call TR_PS2_ЗАПИСЬ_ПОР_60 ;
mov  ECX,3             ;
mov  [TR_NOMER_B],ECX  ;
jmp .ВЫХОД             ;
;----------------------;

;----------------------;
           .ПРОПУСТИТЬ:;
;----------------------;
call TR_PS2_ЧТЕНИЕ_60  ;
jmp .ВЫХОД             ;
;----------------------;
                .ВЫХОД:;
popad
ret

;-----------------------------------}
TR_PS2_ЗАПИСЬ_ПОР_64:;--------------{
push eax;
call TR_PS2_ОЖИ_ЗАПИСЬ_60;
pop  eax;
out  0x64,al;
ret;
;-----------------------------------}
TR_PS2_ЗАПИСЬ_ПОР_60:;--------------{
push eax;
call TR_PS2_ОЖИ_ЗАПИСЬ_60;
pop  eax;
out  0x60,al;
ret;
;-----------------------------------}
TR_PS2_ЧТЕНИЕ_ПОР_60:;--------------{
call TR_PS2_ОЖИ_ЧТЕНИЕ_60;
in   al,0x60;
ret;
;-----------------------------------}

TR_PS2_ОЖИ_ЧТЕНИЕ_60:;--------------{
               .CIKL:;
    in   al,0x64     ; // Читаю состояние контроллера PS2
    test al,00000001b; // Если 1 то есть инфомация
    jz  .CIKL        ; // 1 выходной буфер контроллера содержит информацию (можно производить чтение из регистра данных). После чтения регистра данных этот бит сбрасывается
              .ВЫХОД:;
    ret              ;
;-----------------------------------}
TR_PS2_ОЖИ_ЗАПИСЬ_60:;--------------{
                .CIKL:;
    in   al,0x64      ; // Читаю состояние контроллера PS2
    test al,00000010b ;
    jz  .ВЫХОД        ; // Если 0 можно записывать
    test al,10000000b ;
    jnz .ПРОПУСТИТЬ   ; // Ошибка четности
    test al,01000000b ;
    jnz .ПРОПУСТИТЬ   ; // Таймаут
    test al,00000001b ;
    jnz .ПРОПУСТИТЬ   ; // Пропустить
    jmp .CIKL         ; // 0 входной буфер контроллера пуст (можно производить запись в регистр команд или данных)
    ;-----------------;
          .ПРОПУСТИТЬ:;
    test al,00000001b ; //  Если 0 можно записывать
    jz  .CIKL         ; // Если нет входных данных
    Call TR_PS2_ЧТЕНИЕ_60;
    jmp .CIKL         ;
    ;-----------------;
              .ВЫХОД :;
    ret               ;
    ;-------------------------------}

TR_PS2_ЧТЕНИЕ_60:;------------------{
mov  eax,0       ;
in   al,0x60     ;
ret              ;
;-----------------------------------}
TR_PS2_ЧТЕНИЕ_64:;------------------{
mov  eax,0       ;
in   al,0x64     ;
ret              ;
;-----------------------------------}
TR_PS2_ЗАПИСЬ_60:;------------------{
out  0x60,al     ;
ret              ;
;-----------------------------------}
TR_PS2_ЗАПИСЬ_64:;------------------{
out  0x64,al     ;
ret              ;
;-----------------------------------}

TR_PS2_ПЕРЕМЕННЫЕ:;-----------------{
TR_MOUSE_X:dd 0; // Координаты мшки по X
TR_MOUSE_Y:dd 0; // Координаты мшки по Y
TR_NOMER_B:dd 3; // Номер прочитаного байта

TR_BYTE0_B:dd 0;
TR_BYTE1_B:dd 0;
TR_BYTE2_B:dd 0;
TR_BYTE3_B:dd 0;

TR_MOUSE_X0:dd 0;
TR_MOUSE_Y0:dd 0;

;-----------------------------------}


;-----------------------------------}

;==============================================================================}

TR_ПРЕРЫВАНИЯ_ВЫКЛ:; { Запрет всех прерываний
cli
in   al, 70h
or   al, 80h
out  70h, al  ; запрет NMI
ret
;}
TR_ПРЕРЫВАНИЯ_ВКЛ :; { разрешаем аппаратные прерывания и NMI
in   al, 70h
and  al, 7Fh
out  70h, al
sti
ret
;}

;}
;{ МНЕМОНИКИ                                          -МНЕМОНИКИ:       .
                                                                       ;-ЖШРИФТ:
                                                                      ;-clBlack:
; Списко используемых директив и мнемоник ассемблера FASM
;MUL:
;DIV:
;MOV:
;ADD:
;SUB:
;CALL:
;JMP:
;JZ:
;JNZ:
;JA:
;JB:
;JAE:
;JBE:
;RET:
;PUSHAD:
;POPAD:
;POP:
;PUSH:
;TEST:
;CMP:
;INC:
;DEC:
;ORG:
;BYTE:
;WORD:
;XOR:
;SHL:
;SHR:
;INT:
;CLI:
;STI:
;IF     // Директива компилятора FASM условная компиляция IF Начало
;END    // Директива компилятора FASM условная компиляция END IF завершение
;USE16  // Директива компилятора FASM 16 Битные инструкции
;USE32  // Директива компилятора FASM 32 Битные инструкции
;TIMES  // Директива компилятора FASM Заполнение каким то значением
;DB     // Директива компилятора FASM описание последовательности байт
;DW     // Директива компилятора FASM описание последовательности Слов 2 байтовых
;DD     // Директива компилятора FASM описание последовательности Двойных Слов 4 байтовых
;FAR    // Директива компилятора FASM Дальний переход
; Заподняю списко мнемоник в след раз не придеться прописывать в ручную
; Потому что есть программа у меня ПОДСВЕТКА она сам заполнит
                                                                        ;-КОНЕЦ:
;==============================================================================}
;{ РЕГИСТРЫ                                           -РЕГИСТРЫ:        .
                                                                       ;-ЖШРИФТ:
                                                                       ;-clBlue:
;AL:
;AH:
;AX:
;BL:
;BH:
;BX:
;CL:
;CH:
;CX:
;DL:
;DH:
;DX:
;SI:
;DI:
;ES:
;DS:
;SS:
;SP:

;EAX:
;EBX:
;ECX:
;EDX:
;ESI:
;EDI:
                                                                        ;-КОНЕЦ:
;==============================================================================}
КОНЕЦ_ПРОГРАММЫ:;{

;{Конец программы для 16 бит
        IF  (ПЛАТФОРМА = T16)
        times 1474560 - ($ - 1000h + 200h)   db 0;
        END IF
        ;}
;{Конец программы для ДОС
                IF  (ПЛАТФОРМА = ДОС)

                END IF
                ;}
;{Конец программы для 32 бит
        IF  (ПЛАТФОРМА = T32)
        ;                Размер кода защищенного режима  Реального кода                 Бут-сектора
        times 1474560 - ($ - ЗАЩИЩЕННЫЙ_РЕЖИМ.СТАРТ)   - РАЗМЕР_КОДА_РЕАЛЬНОГО_РЕЖИМА - 0x200 db 0x90
        END IF
        ;}

;}































;------------------; Для отладки
;pushad             ;
;call ЭКРАН_ОЧИСТКА ;
;call КУРСОР        ;
;call ЭЛЕ_ПРОСМОТР  ;
;call СТРОКАSI;
;mov  ah,0;
;mov  al,[si]
;call ЧИСЛОAX;
;call ЭКРАН_ВЫВОД   ;
;call ОЖИДАНИЕ_ЛЮБОЙ_КНОПКИ;
;call ОЖИДАНИЕ_ЛЮБОЙ_КНОПКИ;
;popad              ;
;------------------;
